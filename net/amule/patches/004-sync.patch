--- a/acinclude.m4
+++ b/acinclude.m4
@@ -504,6 +504,67 @@ AC_DEFUN([MULE_CHECK_CCACHE],
 
 
 dnl ----------------------------------------------------
+dnl MULE_CHECK_BFD
+dnl check if bfd.h is on the system and usable
+dnl ----------------------------------------------------
+AC_DEFUN([MULE_CHECK_BFD],
+[AC_REQUIRE([MULE_CHECK_NLS])dnl
+
+	MULE_ARG_ENABLE([bfd], [no], [enable bfd support for proper backtraces])
+	MULE_IF_ENABLED([bfd], [
+		AC_MSG_CHECKING([for bfd])
+		result=no
+		for bfd_ldadd in "" "${LIBINTL}" "-ldl" "-ldl ${LIBINTL}"; do
+		    MULE_BACKUP([LIBS])
+		    MULE_BACKUP([LDFLAGS])
+		    MULE_PREPEND([LIBS], [-lbfd  ${bfd_ldadd} ${ZLIB_LIBS}])
+		    MULE_APPEND([LDFLAGS], [${ZLIB_LDFLAGS}])
+		    AC_LINK_IFELSE([
+			AC_LANG_PROGRAM([[
+					#include <ansidecl.h>
+					#include <bfd.h>
+			]], [[
+			    const char *dummy = bfd_errmsg(bfd_get_error());
+			]])
+			], [
+			   result=yes
+			   BFD_CPPFLAGS="-DHAVE_BFD"
+			   BFD_LIBS="-lbfd  ${bfd_ldadd}"
+			   MULE_RESTORE([LIBS])
+			   MULE_RESTORE([LDFLAGS])
+			   break
+		])
+		MULE_RESTORE([LIBS])
+		MULE_RESTORE([LDFLAGS])
+		done
+
+		AC_MSG_RESULT([$result])
+	])
+	AS_IF([test $result = no],
+		[MULE_WARNING([bfd.h not found or unusable, please install binutils development package if you are a developer or want to help testing aMule])])
+
+AC_SUBST([BFD_CPPFLAGS])dnl
+AC_SUBST([BFD_LIBS])dnl
+])
+
+
+dnl ----------------------------------------------------
+dnl MULE_CHECK_FLEX_EXTENDED
+dnl check if flex can produce header files
+dnl ----------------------------------------------------
+AC_DEFUN([MULE_CHECK_FLEX_EXTENDED],
+[
+	AC_MSG_CHECKING([for extended flex capabilities])
+
+	extended_flex=`flex --help | grep header-file`
+	AS_IF([test -n "$extended_flex"], [HAVE_FLEX_EXTENDED=yes], [HAVE_FLEX_EXTENDED=no])
+	AC_MSG_RESULT($HAVE_FLEX_EXTENDED)
+
+	AS_IF([test $HAVE_FLEX_EXTENDED = no], [AC_MSG_NOTICE([Your flex version doesn't support --header-file flag. This is not critical, but an upgrade is recommended])])
+])
+
+
+dnl ----------------------------------------------------
 dnl MULE_CHECK_EXCEPTIONS
 dnl Checks for broken exception-handling. This is needed
 dnl because exception handling is broken for some archs/
--- a/amule_build_install.sh
+++ b/amule_build_install.sh
@@ -42,7 +42,7 @@ function lookup_distro {
     #echo $2    # evaluates to XXX_FILENAME
     #echo ${!2} # evaluates to /home/user/dir/xxx-y.z.t.tar.gz
 
-    # remove the directory and the extension parts and assing it
+    # remove the directory and the extension parts and assign it
     # to XXX_DISTRO in $3
     case ${!2} in
 	*.gz)
@@ -92,7 +92,7 @@ function init_package_versions {
     lookup_distro 'aMule-*' AMULE_FILENAME AMULE_DISTRO
 
     echo
-    echo "Software packacge versions:"
+    echo "Software package versions:"
     echo "    cryptopp  : $CRYPTOPP_DISTRO"
     echo "    libupnp   : $LIBUPNP_DISTRO"
     echo "    wxWidgets : $WXWIDGETS_DISTRO"
--- a/autogen.sh
+++ b/autogen.sh
@@ -35,7 +35,7 @@ if expr "$confver" \> "$gettext_version"
   exit 1
 fi
 
-# Force intl regenration to get last update from installed gettext templates
+# Force intl regeneration to get last update from installed gettext templates
 rm -rf intl/*
 #if [ ! -d intl ]; then
     echo "Setting up internationalization files."
--- a/BUILDING_MACOSX.txt
+++ b/BUILDING_MACOSX.txt
@@ -9,7 +9,7 @@ WXVERSION=svn WXPORT=cocoa MULECLEAN=YES
 
 
 Those commands would build a MacOSX 10.6 (Snow Leopard) compatible application bundle for aMule and aMuleGUI
-using the architecture of the build system ( i386 or x86_64 ), with the latest SVN vesion of wxWidgets.
+using the architecture of the build system ( i386 or x86_64 ), with the latest SVN version of wxWidgets.
 
 Other parameters are explained upon execution of the script.
 
--- a/cmake/boost.cmake
+++ b/cmake/boost.cmake
@@ -1,5 +1,4 @@
-include (FindThreads)
-find_package (Boost ${MIN_BOOST_VERSION})
+include (FindBoost)
 
 if (NOT ASIO_SOCKETS)
 	include (CheckIncludeFiles)
@@ -17,7 +16,6 @@ if (NOT ASIO_SOCKETS)
 			set (CMAKE_REQUIRED_FLAGS " -DBOOST_DATE_TIME_NO_LIB -DBOOST_REGEX_NO_LIB -DBOOST_SYSTEM_NO_LIB -DBOOST_ERROR_CODE_HEADER_ONLY")
 		endif (NOT WIN32)
 
-		set (CMAKE_REQUIRED_LIBRARIES "Threads::Threads")
 		check_include_files ("boost/system/error_code.hpp;boost/asio.hpp" ASIO_SOCKETS LANGUAGE CXX)
 
 		if (ASIO_SOCKETS)
--- a/cmake/gdlib.cmake
+++ b/cmake/gdlib.cmake
@@ -1,102 +1,14 @@
-#
-# This file is part of the aMule Project.
-#
-# Copyright (c) 2011 Werner Mahr (Vollstrecker) <amule@vollstreckernet.de>
-#
-# Any parts of this program contributed by third-party developers are copyrighted
-# by their respective authors.
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA
-#
-#
-# This file uses the following variables:
-#
-#     MIN_GDLIB_VERSION -- to check if gdlib is available in a recent
-#         version for usage in your project. If MIN_GDLIB_VERSION was
-#         not set, no version-check is done.
-#
-# This file defines the folling variables
-#
-#    gdlib_FOUND -- TRUE if gdlib was found, and if version-check is done
-#        if it is new enough, otherwise FALSE
-#
-#    gdlib_CONFIG_EXECUTABLE -- Contains the complete path to gdlib-config
-#        executable
-#
-#    gdlib_VERSION -- If version-check is done, the version goes here
-#
-#    gdlib_LIB_DIR -- libdir reportet by gdlib-config
-#
-#    gdlib_INCLUDE_DIR -- include-dir reportet by gdlib-config
-#
-#    gdlib_LD_FLAGS -- ldflags reportet by gdlib-config
-#
-#    gdlib_LIBS -- libs reportet by gdlib-config
-#
-#    gdlib_CFLAGS -- cflags reportet by gdlib-config
-#
+if (NOT WIN32)
+	find_package (PkgConfig REQUIRED)
 
-if (NOT gdlib_FOUND)
-	if (NOT WIN32)
-		find_package (PkgConfig REQUIRED)
-		pkg_search_module (gdlib REQUIRED gdlib)
-		message (STATUS "gdlib version: ${gdlib_VERSION} -- OK")
-	endif()
+	pkg_search_module (gdlib REQUIRED
+		IMPORTED_TARGET GLOBAL
+		gdlib
+	)
+
+	set_property (TARGET PkgConfig::gdlib PROPERTY
+		INTERFACE_COMPILE_DEFINITIONS __GD__
+	)
 
-	if (NOT gdlib_FOUND)
-		find_program (gdlib_CONFIG_EXECUTABLE gdlib-config
-			ONLY_CMAKE_FIND_ROOT_PATH
-		)
-
-		if (gdlib_CONFIG_EXECUTABLE)
-			execute_process (COMMAND ${gdlib_CONFIG_EXECUTABLE} --version
-				OUTPUT_VARIABLE gdlib_VERSION
-			)
-
-			string (REGEX REPLACE "(\r?\n)+$" "" gdlib_VERSION "${gdlib_VERSION}")
-
-			if (${gdlib_VERSION} VERSION_LESS ${MIN_GDLIB_VERSION})
-				message (FATAL_ERROR "gdlib version ${gdlib_VERSION} -- too old")
-			else()
-				message (STATUS "gdlib version ${gdlib_VERSION} -- OK")
-				set (gdlib_FOUND TRUE)
-
-				execute_process (COMMAND ${gdlib_CONFIG_EXECUTABLE} --libdir
-					OUTPUT_VARIABLE gdlib_LIB_DIR
-				)
-
-				execute_process (COMMAND ${gdlib_CONFIG_EXECUTABLE} --includedir
-					OUTPUT_VARIABLE gdlib_INCLUDE_DIR
-				)
-
-				execute_process (COMMAND ${gdlib_CONFIG_EXECUTABLE} --ldflags
-					OUTPUT_VARIABLE gdlib_LDFLAGS
-				)
-
-				execute_process (COMMAND ${gdlib_CONFIG_EXECUTABLE} --libs
-					OUTPUT_VARIABLE gdlib_LIBRARIES
-				)
-
-				execute_process (COMMAND ${gdlib_CONFIG_EXECUTABLE} --cflags
-					OUTPUT_VARIABLE gdlib_CFLAGS
-				)
-			endif()
-		endif()
-	endif()
-
-	if (gdlib_FOUND)
-		set (gdlib_CFLAGS "${gdlib_CFLAGS} __GD__")
-	endif()
+	message (STATUS "gdlib version: ${gdlib_VERSION} -- OK")
 endif()
--- a/cmake/nls.cmake
+++ b/cmake/nls.cmake
@@ -60,7 +60,6 @@ if (NOT YYENABLE_NLS)
 	if (ENABLE_NLS)
 		message (STATUS "Everything is fine. aMule can be localized")
 		set (YYENABLE_NLS TRUE CACHE INTERNAL "For parser, php-parser and to not recheck for nls-support" FORCE)
-		add_subdirectory (po)
 	else()
 		message (STATUS "You need to install GNU gettext/gettext-tools to compile aMule with i18n support.")
 	endif()
--- a/cmake/wx.cmake
+++ b/cmake/wx.cmake
@@ -26,244 +26,277 @@
 # findWX module supports check of version
 # 
 # Furthermore it sets the LIBS, LIBDIR and DEFS needed for compilation.
-# This can be controled by setting wx_NEED_BASE and wx_NEED_GUI vars.
+# This can be controlled by setting wx_NEED_BASE and wx_NEED_GUI vars.
 #
 
-INCLUDE (CheckCXXSymbolExists)
-INCLUDE (ExternalProject)
+include (CheckCXXSymbolExists)
 
-#IF (BUILT_WX)
-	#SET (BUILT_WX ${BUILT_WX} CACHE BOOL "Remeber that wx was built" FORCE)
+if (wx_NEED_BASE)
+	set (BASE "base")
+	list (APPEND WX_COMPONENTS BASE)
 
-	#EXTERNALPROJECT_ADD (WX
-		#GIT_REPOSITORY https://github.com/wxWidgets/wxWidgets.git
-		#GIT_TAG v3.1.2
-		#CONFIGURE_COMMAND ""
-		#BUILD_COMMAND ""
-		#INSTALL_COMMAND ""
-		#EXCLUDE_FROM_ALL TRUE
-	#)
-
-	#EXTERNALPROJECT_GET_PROPERTY (WX SOURCE_DIR)
-
-	#IF (WIN32)
-		#SET (wxWidgets_ROOT_DIR ${CMAKE_INSTALL_PREFIX})
-	#ELSE (WIN32)
-		#INSTALL (CODE
-			#"EXECUTE_PROCESS (
-				#COMMAND ${CMAKE_MAKE_PROGRAM} clean
-				#WORKING_DIRECTORY ${SOURCE_DIR}
-			#)
-
-			#EXECUTE_PROCESS (
-				#COMMAND ./configure --prefix=${CMAKE_INSTALL_PREFIX}
-				#WORKING_DIRECTORY ${SOURCE_DIR}
-			#)
-
-			#EXECUTE_PROCESS (
-				#COMMAND ${CMAKE_MAKE_PROGRAM} install
-				#WORKING_DIRECTORY ${SOURCE_DIR}
-			#)"
-		#)
-
-		#SET (wxWidgets_CONFIG_EXECUTABLE ${SOURCE_DIR}/wx-config CACHE FILEPATH "Location of wxWidgets library configuration provider binary (wx-config)." FORCE)
-	#ENDIF (WIN32)
-#ENDIF (BUILT_WX)
-
-#IF (NOT DOWNLOAD_AND_BUILD_DEPS)
-	SET (wx_REQUIRED "REQUIRED")
-#ELSE (NOT DOWNLOAD_AND_BUILD_DEPS)
-#	UNSET (wx_REQUIRED)
-#ENDIF (NOT DOWNLOAD_AND_BUILD_DEPS)
-
-IF (wx_NEED_BASE)
-	SET (BASE "base")
-	LIST (APPEND WX_COMPONENTS BASE)
-
-	ADD_LIBRARY (wxWidgets::BASE
+	add_library (wxWidgets::BASE
 		UNKNOWN
 		IMPORTED
 	)
-ENDIF (wx_NEED_BASE)
+endif()
 
-IF (wx_NEED_ADV)
-	SET (ADV "adv")
-	LIST (APPEND WX_COMPONENTS ADV)
+if (wx_NEED_ADV)
+	set (ADV "adv")
+	list (APPEND WX_COMPONENTS ADV)
 
-	ADD_LIBRARY (wxWidgets::ADV
+	add_library (wxWidgets::ADV
 		UNKNOWN
 		IMPORTED
 	)
-ENDIF (wx_NEED_ADV)
+endif()
 
-IF (wx_NEED_GUI)
-	SET (CORE "core")
-	LIST (APPEND WX_COMPONENTS CORE)
+if (wx_NEED_GUI)
+	set (CORE "core")
+	list (APPEND WX_COMPONENTS CORE)
 
-	ADD_LIBRARY (wxWidgets::CORE
+	add_library (wxWidgets::CORE
 		UNKNOWN
 		IMPORTED
 	)
-ENDIF (wx_NEED_GUI)
+endif()
 
-IF (wx_NEED_NET)
-	SET (NET "net")
-	LIST (APPEND WX_COMPONENTS NET)
+if (wx_NEED_NET)
+	set (NET "net")
+	list (APPEND WX_COMPONENTS NET)
 
-	ADD_LIBRARY (wxWidgets::NET
+	add_library (wxWidgets::NET
 		UNKNOWN
 		IMPORTED
 	)
-ENDIF (wx_NEED_NET)
+endif()
 
-#IF (DOWNLOAD_AND_BUILD_DEPS)
-#	UNSET (WX_REQUIRED)
-#ELSE (DOWNLOAD_AND_BUILD_DEPS)
-	SET (WX_REQUIRED "REQUIRED")
-#ENDIF (DOWNLOAD_AND_BUILD_DEPS)
-
-IF (wxWidgets_BASE_DEFINITIONS)
-	SET (WX_QUIET QUIET)
-ENDIF (wxWidgets_BASE_DEFINITIONS)
-
-IF (WX_COMPONENTS)
-	FOREACH (COMPONENT ${WX_COMPONENTS})
-		IF (${COMPONENT} STREQUAL ADV AND wxWidgets_VERSION_STRING VERSION_GREATER_EQUAL 3.1.2 AND NOT WX_QUIET)
-			MESSAGE (STATUS "wx_Version 3.1.2 or newer detected. Disabling wx_ADV")
-			CONTINUE()
-		ENDIF (${COMPONENT} STREQUAL ADV AND wxWidgets_VERSION_STRING VERSION_GREATER_EQUAL 3.1.2 AND NOT WX_QUIET)
-
-		IF (NOT wxWidgets_${COMPONENT}_LIBRARY AND NOT (wxWidgets_${COMPONENT}_LIBRARY_RELEASE AND wxWidgets_${COMPONENT}_LIBRARY_DEBUG))
-			FIND_PACKAGE (wxWidgets ${MIN_WX_VERSION} ${WX_QUIET} ${WX_REQUIRED} COMPONENTS ${${COMPONENT}})
-		ENDIF (NOT wxWidgets_${COMPONENT}_LIBRARY AND NOT (wxWidgets_${COMPONENT}_LIBRARY_RELEASE AND wxWidgets_${COMPONENT}_LIBRARY_DEBUG))
-
-		IF (WIN32)
-			SET_PROPERTY (TARGET wxWidgets::${COMPONENT}
-							PROPERTY IMPORTED_LOCATION_RELEASE ${WX_${${COMPONENT}}}
+if (WX_COMPONENTS)
+	foreach (COMPONENT ${WX_COMPONENTS})
+		if (${COMPONENT} STREQUAL ADV AND wxWidgets_VERSION_STRING VERSION_GREATER_EQUAL 3.1.2 AND NOT WX_QUIET)
+			message (STATUS "wx_Version 3.1.2 or newer detected. Disabling wx_ADV")
+			continue()
+		endif()
+
+		if (NOT ${${COMPONENT}}_COMPLETE AND NOT (wxWidgets_${COMPONENT}_LIBRARY_RELEASE AND wxWidgets_${COMPONENT}_LIBRARY_DEBUG))
+			message (STATUS "Searching for wx-${COMPONENT}")
+			find_package (wxWidgets ${MIN_WX_VERSION} QUIET REQUIRED COMPONENTS ${${COMPONENT}})
+			message(STATUS "Found usable wx-${COMPONENT}: ${wxWidgets_VERSION_STRING}")
+		endif()
+
+		if (WIN32)
+			set_property (TARGET wxWidgets::${COMPONENT}
+				PROPERTY IMPORTED_LOCATION_RELEASE ${WX_${${COMPONENT}}}
 			)
 
-			SET_PROPERTY (TARGET wxWidgets::${COMPONENT}
-							PROPERTY IMPORTED_LOCATION_DEBUG ${WX_${${COMPONENT}}d}
+			set_property (TARGET wxWidgets::${COMPONENT}
+				PROPERTY IMPORTED_LOCATION_DEBUG ${WX_${${COMPONENT}}d}
 			)
 
-			SET (wxWidgets_DEFINITIONS ${wxWidgets_DEFINITIONS} WXUSINGDLL)
+			set (wxWidgets_DEFINITIONS ${wxWidgets_DEFINITIONS} WXUSINGDLL)
 
-			IF (${COMPONENT} STREQUAL CORE)
-				SET (wxWidgets_DEFINITIONS ${wxWidgets_DEFINITIONS} wxUSE_GUI=1)
-				SET (CMAKE_REQUIRED_INCLUDES ${wxWidgets_INCLUDE_DIRS})
+			if (${COMPONENT} STREQUAL CORE)
+				set (wxWidgets_DEFINITIONS ${wxWidgets_DEFINITIONS} wxUSE_GUI=1)
+				set (CMAKE_REQUIRED_INCLUDES ${wxWidgets_INCLUDE_DIRS})
 
-				IF (NOT UNICODE_SUPPORT)
-					UNSET (UNICODE_SUPPORT CACHE)
+				if (NOT UNICODE_SUPPORT)
+					unset (UNICODE_SUPPORT CACHE)
 
 					CHECK_CXX_SYMBOL_EXISTS (wxUSE_UNICODE
 						wx/setup.h
 						UNICODE_SUPPORT
 					)
-				ENDIF (NOT UNICODE_SUPPORT)
+				endif()
 
-				UNSET (CMAKE_REQUIRED_INCLUDES)
+				unset (CMAKE_REQUIRED_INCLUDES)
 
-				IF (UNICODE_SUPPORT)
-					SET (wxWidgets_DEFINITIONS ${wxWidgets_DEFINITIONS} _UNICODE)
-				ENDIF (UNICODE_SUPPORT)
-			ENDIF (${COMPONENT} STREQUAL CORE)
+				if (UNICODE_SUPPORT)
+					set (wxWidgets_DEFINITIONS ${wxWidgets_DEFINITIONS} _UNICODE)
+				endif()
+			endif()
 
-			SET (wxWidgets_${COMPONENT}_LIBRARY_RELEASE ${WX_${${COMPONENT}}} CACHE STRING "Libs to use when linking to ${COMPONENT}" FORCE)
-			SET (wxWidgets_${COMPONENT}_LIBRARY_DEBUG ${WX_${${COMPONENT}}d} CACHE STRING "Libs to use when linking to ${COMPONENT}" FORCE)
+			set (wxWidgets_${COMPONENT}_LIBRARY_RELEASE ${WX_${${COMPONENT}}} CACHE STRING "Libs to use when linking to ${COMPONENT}" FORCE)
+			set (wxWidgets_${COMPONENT}_LIBRARY_DEBUG ${WX_${${COMPONENT}}d} CACHE STRING "Libs to use when linking to ${COMPONENT}" FORCE)
 
-			MARK_AS_ADVANCED (wxWidgets_${COMPONENT}_LIBRARY_RELEASE
+			mark_as_advanced (wxWidgets_${COMPONENT}_LIBRARY_RELEASE
 				wxWidgets_${COMPONENT}_LIBRARY_DEBUG
 			)
-		ELSE (WIN32)
-			FOREACH (LIB IN LISTS wxWidgets_LIBRARIES)
-				IF ("${LIB}" MATCHES "^-l(.*)$")
-					SET (LIB_TO_SEARCH ${CMAKE_MATCH_1})
-
-					FIND_LIBRARY (${LIB_TO_SEARCH}_SEARCH
-						${LIB_TO_SEARCH}
-						PATHS ${wxWidgets_LIBRARY_DIRS}
-					)
-
-					IF (${LIB_TO_SEARCH}_SEARCH AND ${${LIB_TO_SEARCH}_SEARCH} MATCHES ${${COMPONENT}})
-						SET_PROPERTY (TARGET wxWidgets::${COMPONENT}
-							PROPERTY IMPORTED_LOCATION ${${LIB_TO_SEARCH}_SEARCH}
-						)
-					ELSE (${LIB_TO_SEARCH}_SEARCH AND ${${LIB_TO_SEARCH}_SEARCH} MATCHES ${${COMPONENT}})
-						FOREACH (TGT ${WX_COMPONENTS})
-							IF (${${LIB_TO_SEARCH}_SEARCH} MATCHES ${${TGT}} AND TARGET wxWidgets::${TGT})
-								TARGET_LINK_LIBRARIES (wxWidgets::${COMPONENT}
-									INTERFACE wxWidgets::${TGT}
-								)
-							ELSEIF (NOT TARGET wxWidgets::${TGT})
-								MESSAGE (FATAL_ERROR "Tried to add dependency for wxWidgets::${TGT} but didn't find a target wxWidgets::${COMPONENT}")
-							ENDIF (${${LIB_TO_SEARCH}_SEARCH} MATCHES ${${TGT}} AND TARGET wxWidgets::${TGT})
-						ENDFOREACH (TGT ${WX_COMPONENTS})
-					ENDIF (${LIB_TO_SEARCH}_SEARCH AND ${${LIB_TO_SEARCH}_SEARCH} MATCHES ${${COMPONENT}})
-				ENDIF ("${LIB}" MATCHES "^-l(.*)$")
-			ENDFOREACH (LIB IN LISTS wxWidgets_LIBRARIES)
+		else()
+			if (${${${COMPONENT}}_COMPLETE})
+				set_property (TARGET wxWidgets::${COMPONENT} PROPERTY
+					IMPORTED_LOCATION ${${${COMPONENT}}_LOC}
+				)
+
+				if (${${COMPONENT}}_DEPS)
+					if ("Threads::Threads" IN_LIST ${${COMPONENT}}_DEPS)
+						include (FindThreads)
+					endif()
 
-			SET (wxWidgets_${COMPONENT}_LIBRARY ${wxWidgets_${COMPONENT}_LIBRARY} CACHE STRING "Libs to use when linking to ${COMPONENT}" FORCE)
+					target_link_libraries (wxWidgets::${COMPONENT}
+						INTERFACE ${${${COMPONENT}}_DEPS}
+					)
+				endif()
 
-			MARK_AS_ADVANCED (wxWidgets_${COMPONENT_NAME}_LIBRARY
-				wxWidgets_${COMPONENT_NAME}_DEFINITIONS
-			)
-		ENDIF (WIN32)
+				if (${${COMPONENT}}_INCS)
+					set_property (TARGET wxWidgets::${COMPONENT} PROPERTY
+						INTERFACE_INCLUDE_DIRECTORIES ${${${COMPONENT}}_INCS}
+					)
+				endif()
 
-		SET_TARGET_PROPERTIES (wxWidgets::${COMPONENT} PROPERTIES
-			INTERFACE_COMPILE_DEFINITIONS "${wxWidgets_DEFINITIONS};$<$<CONFIG:Debug>:__WXDEBUG__>"
-			INTERFACE_INCLUDE_DIRECTORIES "${wxWidgets_INCLUDE_DIRS}"
-		)
-
-		UNSET (wxWidgets_DEFINITIONS)
-	ENDFOREACH (COMPONENT ${WX_COMPONENTS})
-
-	IF (wxWidgets_VERSION_STRING VERSION_LESS 3.1.2)
-		TARGET_LINK_LIBRARIES (wxWidgets::ADV
-			INTERFACE wxWidgets::BASE
-		)
-	ENDIF (wxWidgets_VERSION_STRING VERSION_LESS 3.1.2)
+				if (${${COMPONENT}}_DEFS)
+					set_property (TARGET wxWidgets::${COMPONENT} PROPERTY
+						INTERFACE_COMPILE_DEFINITIONS ${${${COMPONENT}}_DEFS}
+					)
+				endif()
+			else()
+				foreach (LIB IN LISTS wxWidgets_LIBRARIES)
+					if ("${LIB}" MATCHES "^-l(.*)$")
+						if (${CMAKE_MATCH_1})
+							list (APPEND ${COMPONENT}_DEPS wxWidgets::${${CMAKE_MATCH_1}})
+							list (REMOVE_ITEM wxWidgets_LIBRARIES "${LIB}")
+
+							foreach (entry IN LISTS wxWidgets_LIBRARIES)
+								if (DEFINED ${${CMAKE_MATCH_1}}_DEPS AND "${entry}" IN_LIST "${${CMAKE_MATCH_1}}_DEPS")
+									list (REMOVE_ITEM ${${CMAKE_MATCH_1}}_DEPS "${entry}")
+									list (REMOVE_ITEM wxWidgets_LIBRARIES "${entry}")
+								endif()
+
+								if (DEFINED ${${CMAKE_MATCH_1}}_REMAINS AND "${entry}" IN_LIST "${${CMAKE_MATCH_1}}_REMAINS")
+									list (REMOVE_ITEM ${${CMAKE_MATCH_1}}_REMAINS "${entry}")
+									list (REMOVE_ITEM wxWidgets_LIBRARIES "${entry}")
+								endif()
+							endforeach()
+						else()
+							set (LIB_TO_SEARCH ${CMAKE_MATCH_1})
+
+							find_library (${LIB_TO_SEARCH}_SEARCH
+								${LIB_TO_SEARCH}
+								PATHS ${wxWidgets_LIBRARY_DIRS}
+							)
+
+							if (${LIB_TO_SEARCH}_SEARCH)
+								set (${${COMPONENT}}_LOC ${${LIB_TO_SEARCH}_SEARCH}
+									CACHE
+									INTERNAL
+									"location of ${COMPONENT} lib"
+									FORCE
+								)
 
-	TARGET_LINK_LIBRARIES (wxWidgets::CORE
-		INTERFACE wxWidgets::BASE
-	)
-	TARGET_LINK_LIBRARIES (wxWidgets::NET
-		INTERFACE wxWidgets::BASE
-	)
+								set (${LIB_TO_SEARCH} ${COMPONENT})
+								list (REMOVE_ITEM wxWidgets_LIBRARIES "${LIB}")
+							endif()
+						endif()
+					endif()
+				endforeach()
+
+				foreach (LIB IN LISTS wxWidgets_LIBRARIES)
+					if ("${LIB}" MATCHES "^-L.*")
+						list (REMOVE_ITEM wxWidgets_LIBRARIES "${LIB}")
+					elseif ("${LIB}" STREQUAL "")
+						continue()
+					else()
+						if (${LIB} STREQUAL "-pthread")
+							if (NOT TARGET Threads::Threads)
+								include (FindThreads)
+							endif()
+
+							if (TARGET Threads::Threads)
+								list (APPEND ${COMPONENT}_DEPS "Threads::Threads")
+								list (REMOVE_ITEM wxWidgets_LIBRARIES "${LIB}")
+							else()
+								message (FATAL_ERROR "wxWidgets::${COMPONENT} needs threads, but it was not found")
+							endif()
+						else()
+							message ("${LIB} nicht behandelt")
+						endif()
+					endif()
+				endforeach()
+
+				foreach (dep IN LISTS ${COMPONENT}_DEPS)
+					get_target_property (int_deps
+						${dep}
+						INTERFACE_LINK_LIBRARIES
+					)
 
-	SET (wxWidgets_INCLUDE_DIRS ${wxWidgets_INCLUDE_DIRS} CACHE STRING "Where to find wx header files" FORCE)
+					if (${int_deps} IN_LIST ${COMPONENT}_DEPS)
+						list (REMOVE_ITEM ${COMPONENT}_DEPS ${int_deps})
+					endif()
+
+					get_target_property (int_incs
+						${dep}
+						INTERFACE_INCLUDE_DIRECTORIES
+					)
 
-	MARK_AS_ADVANCED (wxWidgets_INCLUDE_DIRS
-		wxWidgets_BASE_DEFINITIONS
-	)
-ENDIF (WX_COMPONENTS)
+					if (int_incs)
+						foreach (inc IN LISTS int_incs)
+							if (${inc} IN_LIST wxWidgets_INCLUDE_DIRS)
+								list (REMOVE_ITEM wxWidgets_INCLUDE_DIRS ${int_incs})
+							endif()
+						endforeach()
+					endif()
+
+					get_target_property (int_defs
+						${dep}
+						INTERFACE_COMPILE_DEFINITIONS
+					)
+
+					if (int_defs)
+						foreach (def IN LISTS int_defs)
+							if (${def} IN_LIST wxWidgets_DEFINITIONS)
+								list (REMOVE_ITEM wxWidgets_DEFINITIONS ${int_defs})
+							endif()
+						endforeach()
+					endif()
+				endforeach()
+
+				set_property (TARGET wxWidgets::${COMPONENT} PROPERTY
+					IMPORTED_LOCATION ${${${COMPONENT}}_LOC}
+				)
+
+				set (${${COMPONENT}}_DEPS ${${COMPONENT}_DEPS}
+					CACHE
+					INTERNAL
+					"Deps of ${COMPONENT}"
+					FORCE
+				)
+
+				target_link_libraries (wxWidgets::${COMPONENT}
+					INTERFACE ${${COMPONENT}_DEPS}
+				)
+
+				set (${${COMPONENT}}_INCS ${wxWidgets_INCLUDE_DIRS}
+					CACHE
+					INTERNAL
+					"Incs of ${COMPONENT}"
+					FORCE
+				)
+
+				if (wxWidgets_INCLUDE_DIRS)
+					set_property (TARGET wxWidgets::${COMPONENT} PROPERTY
+						INTERFACE_INCLUDE_DIRECTORIES ${wxWidgets_INCLUDE_DIRS}
+					)
+				endif()
+
+				set (${${COMPONENT}}_DEFS ${wxWidgets_DEFINITIONS}
+					CACHE
+					INTERNAL
+					"Defs of ${COMPONENT}"
+					FORCE
+				)
+
+				if (wxWidgets_DEFINITIONS)
+					set_property (TARGET wxWidgets::${COMPONENT} PROPERTY
+						INTERFACE_COMPILE_DEFINITIONS ${wxWidgets_DEFINITIONS}
+					)
+				endif()
 
-#IF (DOWNLOAD_AND_BUILD_DEPS AND NOT wxWidgets_FOUND AND NOT BUILT_WX)
-	#IF (WIN32)
-		#EXTERNALPROJECT_ADD (WX
-			#GIT_REPOSITORY https://github.com/wxWidgets/wxWidgets.git
-			#GIT_TAG v3.1.2
-			#GIT_PROGRESS TRUE
-			#BUILD_IN_SOURCE FALSE
-			#CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX} -DwxUSE_IPV6=OFF -DwxBUILD_COMPATIBILITY=2.8
-			#BUILD_COMMAND ${CMAKE_COMMAND} --build . --config Debug
-			#COMMAND ${CMAKE_COMMAND} --build . --config Release
-			#INSTALL_COMMAND ${CMAKE_COMMAND} --install . --config Debug
-			#COMMAND ${CMAKE_COMMAND} --install . --config Release
-		#)
-	#ELSE (WIN32)
-		#EXTERNALPROJECT_ADD (WX
-			#GIT_REPOSITORY https://github.com/wxWidgets/wxWidgets.git
-			#GIT_TAG v3.1.2
-			#GIT_PROGRESS TRUE
-			#BUILD_IN_SOURCE TRUE
-			#CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}
-			#CONFIGURE_COMMAND ./autogen.sh
-			#BUILD_COMMAND ./configure --enable-debug --prefix=<SOURCE_DIR>
-			#INSTALL_COMMAND ${CMAKE_MAKE_PROGRAM}
-		#)
-	#ENDIF (WIN32)
-
-
-	#LIST (APPEND EXTERNAL_DEPS WX)
-	#SET (RECONF_COMMAND ${RECONF_COMMAND} -DBUILT_WX=TRUE)
-#ENDIF (DOWNLOAD_AND_BUILD_DEPS AND NOT wxWidgets_FOUND AND NOT BUILT_WX)
+				set (${${COMPONENT}}_COMPLETE TRUE
+					CACHE
+					INTERNAL
+					"${COMPONENT} is complete"
+					FORCE
+				)
+			endif()
+		endif()
+	endforeach()
+endif()
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -16,7 +16,7 @@ set (DEFAULT_BUILD_TYPE "Release")
 set (RECONF_COMMAND ${CMAKE_COMMAND})
 
 if (EXISTS "${CMAKE_SOURCE_DIR}/.git")
-	SET (DEFAULT_BUILD_TYPE "Debug")
+	set (DEFAULT_BUILD_TYPE "Debug")
 endif()
 
 # Set the possible values of build type for cmake-gui
@@ -132,6 +132,11 @@ if (BUILD_REMOTEGUI)
 	)
 endif()
 
+if (ENABLE_NLS)
+	include (FindGettext)
+	add_subdirectory (po)
+endif()
+
 add_subdirectory (docs)
 add_subdirectory (src)
 
--- a/configure.ac
+++ b/configure.ac
@@ -180,7 +180,7 @@ MULE_IF_ENABLED_ANY([monolithic, amule-d
 		equivalent variable and wxWidgets version is 2.8.12 or above.
 		])]
 	)
-	AS_IF([test "${WX_VERSION_FULL}" = "2.9.0"], [AC_MSG_ERROR([
+	AS_IF([test "$WX_VERSION_MAJOR""$WX_VERSION_MINOR" -lt 32], [AC_MSG_ERROR([
 		This version of wxWidgets is known to not work with aMule.
 		Please upgrade to a newer version.]
 		)]
--- a/m4/boost.m4
+++ b/m4/boost.m4
@@ -22,7 +22,7 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 m4_define([_BOOST_SERIAL], [m4_translit([
-# serial 25
+# serial 39
 ], [#
 ], [])])
 
@@ -86,9 +86,10 @@ dnl boost-lib-version =
 dnl # 2 "conftest.cc" 3
 dnl                    "1_56"
 dnl
-dnl So get rid of the # lines, and glue the remaining ones together.
+dnl So get rid of the # and empty lines, and glue the remaining ones together.
 (eval "$ac_cpp conftest.$ac_ext") 2>&AS_MESSAGE_LOG_FD |
   grep -v '#' |
+  grep -v '^[[[:space:]]]*$' |
   tr -d '\r' |
   tr -s '\n' ' ' |
   $SED -n -e "$1" >conftest.i 2>&1],
@@ -110,8 +111,7 @@ AC_LANG_POP([C++])dnl
 # On # success, defines HAVE_BOOST.  On failure, calls the optional
 # ACTION-IF-NOT-FOUND action if one was supplied.
 # Otherwise aborts with an error message.
-dnl *aMule* AC_DEFUN_ONCE([BOOST_REQUIRE],
-AC_DEFUN([BOOST_REQUIRE],
+AC_DEFUN_ONCE([BOOST_REQUIRE],
 [AC_REQUIRE([AC_PROG_CXX])dnl
 AC_REQUIRE([AC_PROG_GREP])dnl
 echo "$as_me: this is boost.m4[]_BOOST_SERIAL" >&AS_MESSAGE_LOG_FD
@@ -123,9 +123,9 @@ IFS=$boost_save_IFS
 shift
 boost_version_req=`expr "$[1]" '*' 100000 + "$[2]" '*' 100 + "$[3]"`
 boost_version_req_string=$[1].$[2].$[3]
-dnl *aMule* AC_ARG_WITH([boost],
-dnl *aMule*    [AS_HELP_STRING([--with-boost=DIR],
-dnl *aMule*                    [prefix of Boost $1 @<:@guess@:>@])])dnl
+AC_ARG_WITH([boost],
+   [AS_HELP_STRING([--with-boost=DIR],
+                   [prefix of Boost $1 @<:@guess@:>@])])dnl
 AC_ARG_VAR([BOOST_ROOT],[Location of Boost installation])dnl
 # If BOOST_ROOT is set and the user has not provided a value to
 # --with-boost, then treat BOOST_ROOT as if it the user supplied it.
@@ -226,7 +226,7 @@ AC_LANG_POP([C++])dnl
   AC_CACHE_CHECK([for Boost's header version],
     [boost_cv_lib_version],
     [m4_pattern_allow([^BOOST_LIB_VERSION$])dnl
-     _BOOST_SED_CPP([[/^boost-lib-version = /{s///;s/[\" ]//g;p;q;}]],
+     _BOOST_SED_CPP([[/^.*boost-lib-version = /{s///;s/[\" ]//g;p;q;}]],
                     [#include <boost/version.hpp>
 boost-lib-version = BOOST_LIB_VERSION],
     [boost_cv_lib_version=`cat conftest.i`])])
@@ -288,14 +288,17 @@ fi
 
 # BOOST_FIND_LIBS([COMPONENT-NAME], [CANDIDATE-LIB-NAMES],
 #                 [PREFERRED-RT-OPT], [HEADER-NAME], [CXX-TEST],
-#                 [CXX-PROLOGUE])
+#                 [CXX-PROLOGUE], [CXX-POST-INCLUDE-PROLOGUE],
+#                 [ERROR_ON_UNUSABLE])
 # --------------------------------------------------------------
 # Look for the Boost library COMPONENT-NAME (e.g., `thread', for
 # libboost_thread) under the possible CANDIDATE-LIB-NAMES (e.g.,
 # "thread_win32 thread").  Check that HEADER-NAME works and check that
 # libboost_LIB-NAME can link with the code CXX-TEST.  The optional
 # argument CXX-PROLOGUE can be used to include some C++ code before
-# the `main' function.
+# the `main' function. The CXX-POST-INCLUDE-PROLOGUE can be used to
+# include some code before the `main' function, but after the
+# `#include <HEADER-NAME>'.
 #
 # Invokes BOOST_FIND_HEADER([HEADER-NAME]) (see above).
 #
@@ -309,6 +312,9 @@ fi
 # builds.  Some sample values for PREFERRED-RT-OPT: (nothing), mt, d, mt-d, gdp
 # ...  If you want to make sure you have a specific version of Boost
 # (eg, >= 1.33) you *must* invoke BOOST_REQUIRE before this macro.
+#
+# ERROR_ON_UNUSABLE can be set to "no" if the caller does not want their
+# configure to fail
 AC_DEFUN([BOOST_FIND_LIBS],
 [AC_REQUIRE([BOOST_REQUIRE])dnl
 AC_REQUIRE([_BOOST_FIND_COMPILER_TAG])dnl
@@ -317,26 +323,32 @@ AC_REQUIRE([_BOOST_GUESS_WHETHER_TO_USE_
 if test x"$boost_cv_inc_path" = xno; then
   AC_MSG_NOTICE([Boost not available, not searching for the Boost $1 library])
 else
-dnl The else branch is huge and wasn't intended on purpose.
+dnl The else branch is huge and wasn't indented on purpose.
 AC_LANG_PUSH([C++])dnl
 AS_VAR_PUSHDEF([Boost_lib], [boost_cv_lib_$1])dnl
 AS_VAR_PUSHDEF([Boost_lib_LDFLAGS], [boost_cv_lib_$1_LDFLAGS])dnl
 AS_VAR_PUSHDEF([Boost_lib_LDPATH], [boost_cv_lib_$1_LDPATH])dnl
 AS_VAR_PUSHDEF([Boost_lib_LIBS], [boost_cv_lib_$1_LIBS])dnl
-BOOST_FIND_HEADER([$4])
+AS_IF([test x"$8" = "xno"], [not_found_header='true'])
+BOOST_FIND_HEADER([$4], [$not_found_header])
 boost_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
 AC_CACHE_CHECK([for the Boost $1 library], [Boost_lib],
                [_BOOST_FIND_LIBS($@)])
 case $Boost_lib in #(
+  (yes) _AC_MSG_LOG_CONFTEST
+    AC_DEFINE(AS_TR_CPP([HAVE_BOOST_$1]), [1], [Defined if the Boost $1 library is available])dnl
+    AC_SUBST(AS_TR_CPP([BOOST_$1_LDFLAGS]), [$Boost_lib_LDFLAGS])dnl
+    AC_SUBST(AS_TR_CPP([BOOST_$1_LDPATH]), [$Boost_lib_LDPATH])dnl
+    AC_SUBST([BOOST_LDPATH], [$Boost_lib_LDPATH])dnl
+    AC_SUBST(AS_TR_CPP([BOOST_$1_LIBS]), [$Boost_lib_LIBS])dnl
+    ;;
   (no) _AC_MSG_LOG_CONFTEST
-    AC_MSG_ERROR([cannot find the flags to link with Boost $1])
+    AS_IF([test x"$8" != "xno"], [
+      AC_MSG_ERROR([cannot find flags to link with the Boost $1 library (libboost-$1)])
+    ])
     ;;
 esac
-AC_SUBST(AS_TR_CPP([BOOST_$1_LDFLAGS]), [$Boost_lib_LDFLAGS])dnl
-AC_SUBST(AS_TR_CPP([BOOST_$1_LDPATH]), [$Boost_lib_LDPATH])dnl
-AC_SUBST([BOOST_LDPATH], [$Boost_lib_LDPATH])dnl
-AC_SUBST(AS_TR_CPP([BOOST_$1_LIBS]), [$Boost_lib_LIBS])dnl
 CPPFLAGS=$boost_save_CPPFLAGS
 AS_VAR_POPDEF([Boost_lib])dnl
 AS_VAR_POPDEF([Boost_lib_LDFLAGS])dnl
@@ -349,16 +361,20 @@ fi
 
 # BOOST_FIND_LIB([LIB-NAME],
 #                [PREFERRED-RT-OPT], [HEADER-NAME], [CXX-TEST],
-#                [CXX-PROLOGUE])
+#                [CXX-PROLOGUE], [CXX-POST-INCLUDE-PROLOGUE],
+#                [ERROR_ON_UNUSABLE])
 # --------------------------------------------------------------
 # Backward compatibility wrapper for BOOST_FIND_LIBS.
+# ERROR_ON_UNUSABLE can be set to "no" if the caller does not want their
+# configure to fail
 AC_DEFUN([BOOST_FIND_LIB],
 [BOOST_FIND_LIBS([$1], $@)])
 
 
 # _BOOST_FIND_LIBS([LIB-NAME], [CANDIDATE-LIB-NAMES],
 #                 [PREFERRED-RT-OPT], [HEADER-NAME], [CXX-TEST],
-#                 [CXX-PROLOGUE])
+#                 [CXX-PROLOGUE], [CXX-POST-INCLUDE-PROLOGUE],
+#                 [ERROR_ON_UNUSABLE])
 # --------------------------------------------------------------
 # Real implementation of BOOST_FIND_LIBS: rely on these local macros:
 # Boost_lib, Boost_lib_LDFLAGS, Boost_lib_LDPATH, Boost_lib_LIBS
@@ -370,6 +386,9 @@ AC_DEFUN([BOOST_FIND_LIB],
 # usually installed.  If we can't find the standard variants, we try
 # to enforce -mt (for instance on MacOSX, libboost_thread.dylib
 # doesn't exist but there's -obviously- libboost_thread-mt.dylib).
+#
+# ERROR_ON_UNUSABLE can be set to "no" if the caller does not want their
+# configure to fail
 AC_DEFUN([_BOOST_FIND_LIBS],
 [Boost_lib=no
   case "$3" in #(
@@ -396,7 +415,8 @@ AC_DEFUN([_BOOST_FIND_LIBS],
     AC_MSG_ERROR([the libext variable is empty, did you invoke Libtool?])
   boost_save_ac_objext=$ac_objext
   # Generate the test file.
-  AC_LANG_CONFTEST([AC_LANG_PROGRAM([#include <$4>
+  AC_LANG_CONFTEST([AC_LANG_PROGRAM([$7
+#include <$4>
 $6], [$5])])
 dnl Optimization hacks: compiling C++ is slow, especially with Boost.  What
 dnl we're trying to do here is guess the right combination of link flags
@@ -416,7 +436,10 @@ dnl empty because the test file is gener
 dnl start the for loops).
   AC_COMPILE_IFELSE([],
     [ac_objext=do_not_rm_me_plz],
-    [AC_MSG_ERROR([cannot compile a test that uses Boost $1])])
+    [AS_IF([test x"$8" != x"no"], [
+       AC_MSG_ERROR([cannot compile a test that uses Boost $1])
+     ])
+    ])
   ac_objext=$boost_save_ac_objext
   boost_failed_libs=
 # Don't bother to ident the following nested for loops, only the 2
@@ -426,12 +449,15 @@ for boost_tag_ in -$boost_cv_lib_tag '';
 for boost_ver_ in -$boost_cv_lib_version ''; do
 for boost_mt_ in $boost_mt -mt ''; do
 for boost_rtopt_ in $boost_rtopt '' -d; do
-  for boost_lib in \
-    boost_$boost_lib_$boost_tag_$boost_mt_$boost_rtopt_$boost_ver_ \
-    boost_$boost_lib_$boost_tag_$boost_rtopt_$boost_ver_ \
-    boost_$boost_lib_$boost_tag_$boost_mt_$boost_ver_ \
-    boost_$boost_lib_$boost_tag_$boost_ver_
+  for boost_full_suffix in \
+    $boost_last_suffix \
+    x$boost_tag_$boost_mt_$boost_rtopt_$boost_ver_ \
+    x$boost_tag_$boost_rtopt_$boost_ver_ \
+    x$boost_tag_$boost_mt_$boost_ver_ \
+    x$boost_tag_$boost_ver_
   do
+    boost_real_suffix=`echo "$boost_full_suffix" | sed 's/^x//'`
+    boost_lib="boost_$boost_lib_$boost_real_suffix"
     # Avoid testing twice the same lib
     case $boost_failed_libs in #(
       (*@$boost_lib@*) continue;;
@@ -480,7 +506,7 @@ dnl generated only once above (before we
            *)
             for boost_cv_rpath_link_ldflag in -Wl,-R, -Wl,-rpath,; do
               LDFLAGS="$boost_save_LDFLAGS -L$boost_ldpath $boost_cv_rpath_link_ldflag$boost_ldpath"
-              LIBS="$boost_save_LIBS $Boost_lib_LIBS"
+              LIBS="$Boost_lib_LIBS $boost_save_LIBS"
               _BOOST_AC_LINK_IFELSE([],
                 [boost_rpath_link_ldflag_found=yes
                 break],
@@ -496,6 +522,7 @@ dnl generated only once above (before we
         test x"$boost_ldpath" != x &&
           Boost_lib_LDFLAGS="-L$boost_ldpath $boost_cv_rpath_link_ldflag$boost_ldpath"
         Boost_lib_LDPATH="$boost_ldpath"
+        boost_last_suffix="$boost_full_suffix"
         break 7
       else
         boost_failed_libs="$boost_failed_libs@$boost_lib@"
@@ -534,6 +561,14 @@ m4_popdef([BOOST_Library])dnl
 ])
 ])
 
+
+# BOOST_ANY()
+# ------------
+# Look for Boost.Any
+BOOST_DEFUN([Any],
+[BOOST_FIND_HEADER([boost/any.hpp])])
+
+
 # BOOST_ARRAY()
 # -------------
 # Look for Boost.Array
@@ -548,6 +583,37 @@ BOOST_DEFUN([Asio],
 [AC_REQUIRE([BOOST_SYSTEM])dnl
 BOOST_FIND_HEADER([boost/asio.hpp])])
 
+# BOOST_BIMAP()
+# ------------
+# Look for Boost.Bimap
+BOOST_DEFUN([Bimap],
+[BOOST_FIND_HEADER([boost/bimap.hpp])])
+
+
+# BOOST_ASSIGN()
+# -------------
+# Look for Boost.Assign
+BOOST_DEFUN([Assign],
+[BOOST_FIND_HEADER([boost/assign.hpp])])
+
+
+# BOOST_ATOMIC([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
+# -------------------------------
+# Look for Boost.Atomic.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+BOOST_DEFUN([Atomic],
+[BOOST_FIND_LIB([atomic], [$1],
+                [boost/atomic.hpp],
+                [boost::atomic<int> a;],
+                [ ],
+                [#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif], [$2])
+])# BOOST_ATOMIC
+
 
 # BOOST_BIND()
 # ------------
@@ -556,7 +622,14 @@ BOOST_DEFUN([Bind],
 [BOOST_FIND_HEADER([boost/bind.hpp])])
 
 
-# BOOST_CHRONO()
+# BOOST_CAST()
+# ------------
+# Look for Boost.Cast
+BOOST_DEFUN([Cast],
+[BOOST_FIND_HEADER([boost/cast.hpp])])
+
+
+# BOOST_CHRONO([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # --------------
 # Look for Boost.Chrono.
 BOOST_DEFUN([Chrono],
@@ -564,7 +637,7 @@ BOOST_DEFUN([Chrono],
 # added as of 1.35.0.  If we have a version <1.35, we must not attempt to
 # find Boost.System as it didn't exist by then.
 if test $boost_major_version -ge 135; then
-  BOOST_SYSTEM([$1])
+  BOOST_SYSTEM([$1], [$2])
 fi # end of the Boost.System check.
 boost_filesystem_save_LIBS=$LIBS
 boost_filesystem_save_LDFLAGS=$LDFLAGS
@@ -573,7 +646,7 @@ LIBS="$LIBS $BOOST_SYSTEM_LIBS"
 LDFLAGS="$LDFLAGS $BOOST_SYSTEM_LDFLAGS"
 BOOST_FIND_LIB([chrono], [$1],
                 [boost/chrono.hpp],
-                [boost::chrono::thread_clock d;])
+                [boost::chrono::thread_clock d;], [], [], [$2])
 if test $enable_static_boost = yes && test $boost_major_version -ge 135; then
   BOOST_CHRONO_LIBS="$BOOST_CHRONO_LIBS $BOOST_SYSTEM_LIBS"
 fi
@@ -582,7 +655,7 @@ LDFLAGS=$boost_filesystem_save_LDFLAGS
 ])# BOOST_CHRONO
 
 
-# BOOST_CONTEXT([PREFERRED-RT-OPT])
+# BOOST_CONTEXT([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # -----------------------------------
 # Look for Boost.Context.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.
@@ -590,17 +663,76 @@ LDFLAGS=$boost_filesystem_save_LDFLAGS
 # * This library was introduced in Boost 1.51.0
 # * The signatures of make_fcontext() and jump_fcontext were changed in 1.56.0
 # * A dependency on boost_thread appears in 1.57.0
+# * The implementation details were moved to boost::context::detail in 1.61.0
+# * 1.61 also introduces execution_context_v2, which is the "lowest common
+#   denominator" for boost::context presence since then.
+# * boost::context::fiber was introduced in 1.69 and execution_context_v2 was
+#   removed in 1.72
 BOOST_DEFUN([Context],
 [boost_context_save_LIBS=$LIBS
  boost_context_save_LDFLAGS=$LDFLAGS
 if test $boost_major_version -ge 157; then
-  BOOST_THREAD([$1])
+  BOOST_THREAD([$1], [$2])
   m4_pattern_allow([^BOOST_THREAD_(LIBS|LDFLAGS)$])dnl
   LIBS="$LIBS $BOOST_THREAD_LIBS"
   LDFLAGS="$LDFLAGS $BOOST_THREAD_LDFLAGS"
 fi
+
+if test $boost_major_version -ge 169; then
+
 BOOST_FIND_LIB([context], [$1],
-                [boost/context/all.hpp],[[
+                [boost/context/fiber.hpp], [[
+namespace ctx=boost::context;
+int a;
+ctx::fiber source{[&a](ctx::fiber&& sink){
+    a=0;
+    int b=1;
+    for(;;){
+        sink=std::move(sink).resume();
+        int next=a+b;
+        a=b;
+        b=next;
+    }
+    return std::move(sink);
+}};
+for (int j=0;j<10;++j) {
+    source=std::move(source).resume();
+}
+return a == 34;
+]], [], [], [$2])
+
+elif test $boost_major_version -ge 161; then
+
+BOOST_FIND_LIB([context], [$1],
+                [boost/context/execution_context_v2.hpp], [[
+namespace ctx=boost::context;
+int res=0;
+int n=35;
+ctx::execution_context<int> source(
+    [n, &res](ctx::execution_context<int> sink, int) mutable {
+        int a=0;
+        int b=1;
+        while(n-->0){
+            auto result=sink(a);
+            sink=std::move(std::get<0>(result));
+            auto next=a+b;
+            a=b;
+            b=next;
+        }
+        return sink;
+    });
+for(int i=0;i<10;++i){
+    auto result=source(i);
+    source=std::move(std::get<0>(result));
+    res = std::get<1>(result);
+}
+return res == 34;
+]], [], [], [$2])
+
+else
+
+BOOST_FIND_LIB([context], [$1],
+                [boost/context/fcontext.hpp],[[
 
 // creates a stack
 void * stack_pointer = new void*[4096];
@@ -655,7 +787,10 @@ static void f(intptr_t i) {
     ctx::jump_fcontext(&fc, fcm, i * 2);
 }
 #endif
-])
+], [], [], [$2])
+
+fi
+
 LIBS=$boost_context_save_LIBS
 LDFLAGS=$boost_context_save_LDFLAGS
 ])# BOOST_CONTEXT
@@ -670,7 +805,7 @@ BOOST_FIND_HEADER([boost/lexical_cast.hp
 ])# BOOST_CONVERSION
 
 
-# BOOST_COROUTINE([PREFERRED-RT-OPT])
+# BOOST_COROUTINE([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # -----------------------------------
 # Look for Boost.Coroutine.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.  This library was introduced in Boost
@@ -680,10 +815,10 @@ BOOST_DEFUN([Coroutine],
 boost_coroutine_save_LIBS=$LIBS
 boost_coroutine_save_LDFLAGS=$LDFLAGS
 # Link-time dependency from coroutine to context
-BOOST_CONTEXT([$1])
+BOOST_CONTEXT([$1], [$2])
 # Starting from Boost 1.55 a dependency on Boost.System is added
 if test $boost_major_version -ge 155; then
-  BOOST_SYSTEM([$1])
+  BOOST_SYSTEM([$1], [$2])
 fi
 m4_pattern_allow([^BOOST_(CONTEXT|SYSTEM)_(LIBS|LDFLAGS)])
 LIBS="$LIBS $BOOST_CONTEXT_LIBS $BOOST_SYSTEM_LIBS"
@@ -691,7 +826,8 @@ LDFLAGS="$LDFLAGS $BOOST_CONTEXT_LDFLAGS
 
 # in 1.53 coroutine was a header only library
 if test $boost_major_version -eq 153; then
-  BOOST_FIND_HEADER([boost/coroutine/coroutine.hpp])
+  AS_IF([test x"$2" = "xno"], [not_found_header='true'])
+  BOOST_FIND_HEADER([boost/coroutine/coroutine.hpp], [$not_found_header])
 else
   BOOST_FIND_LIB([coroutine], [$1],
 		  [boost/coroutine/coroutine.hpp],
@@ -702,7 +838,7 @@ else
   #else
   boost::coroutines::asymmetric_coroutine<int>::pull_type coro; coro.get();
   #endif
-  ])
+  ], [], [], [$2])
 fi
 # Link-time dependency from coroutine to context, existed only in 1.53, in 1.54
 # coroutine doesn't use context from its headers but from its library.
@@ -727,18 +863,25 @@ BOOST_DEFUN([CRC],
 ])# BOOST_CRC
 
 
-# BOOST_DATE_TIME([PREFERRED-RT-OPT])
+# BOOST_DATE_TIME([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # -----------------------------------
 # Look for Boost.Date_Time.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.
 BOOST_DEFUN([Date_Time],
 [BOOST_FIND_LIB([date_time], [$1],
                 [boost/date_time/posix_time/posix_time.hpp],
-                [boost::posix_time::ptime t;])
+                [boost::posix_time::ptime t;], [], [], [$2])
 ])# BOOST_DATE_TIME
 
 
-# BOOST_FILESYSTEM([PREFERRED-RT-OPT])
+# BOOST_EXCEPTION()
+# ------------
+# Look for Boost.Exception
+BOOST_DEFUN([Exception],
+[BOOST_FIND_HEADER([boost/exception/all.hpp])])
+
+
+# BOOST_FILESYSTEM([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # ------------------------------------
 # Look for Boost.Filesystem.  For the documentation of PREFERRED-RT-OPT, see
 # the documentation of BOOST_FIND_LIB above.
@@ -749,7 +892,7 @@ BOOST_DEFUN([Filesystem],
 # added as of 1.35.0.  If we have a version <1.35, we must not attempt to
 # find Boost.System as it didn't exist by then.
 if test $boost_major_version -ge 135; then
-  BOOST_SYSTEM([$1])
+  BOOST_SYSTEM([$1], [$2])
 fi # end of the Boost.System check.
 boost_filesystem_save_LIBS=$LIBS
 boost_filesystem_save_LDFLAGS=$LDFLAGS
@@ -757,7 +900,8 @@ m4_pattern_allow([^BOOST_SYSTEM_(LIBS|LD
 LIBS="$LIBS $BOOST_SYSTEM_LIBS"
 LDFLAGS="$LDFLAGS $BOOST_SYSTEM_LDFLAGS"
 BOOST_FIND_LIB([filesystem], [$1],
-                [boost/filesystem/path.hpp], [boost::filesystem::path p;])
+                [boost/filesystem/path.hpp], [boost::filesystem::path p;],
+                [], [], [$2])
 if test $enable_static_boost = yes && test $boost_major_version -ge 135; then
   BOOST_FILESYSTEM_LIBS="$BOOST_FILESYSTEM_LIBS $BOOST_SYSTEM_LIBS"
 fi
@@ -802,6 +946,13 @@ BOOST_DEFUN([Function],
 [BOOST_FIND_HEADER([boost/function.hpp])])
 
 
+# BOOST_FUSION()
+# -----------------
+# Look for Boost.Fusion
+BOOST_DEFUN([Fusion],
+[BOOST_FIND_HEADER([boost/fusion/sequence.hpp])])
+
+
 # BOOST_GEOMETRY()
 # ----------------
 # Look for Boost.Geometry (new since 1.47.0).
@@ -810,7 +961,7 @@ BOOST_DEFUN([Geometry],
 ])# BOOST_GEOMETRY
 
 
-# BOOST_GRAPH([PREFERRED-RT-OPT])
+# BOOST_GRAPH([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # -------------------------------
 # Look for Boost.Graphs.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.
@@ -819,34 +970,43 @@ BOOST_DEFUN([Graph],
 boost_graph_save_LDFLAGS=$LDFLAGS
 # Link-time dependency from graph to regex was added as of 1.40.0.
 if test $boost_major_version -ge 140; then
-  BOOST_REGEX([$1])
+  BOOST_REGEX([$1], [$2])
   m4_pattern_allow([^BOOST_REGEX_(LIBS|LDFLAGS)$])dnl
   LIBS="$LIBS $BOOST_REGEX_LIBS"
   LDFLAGS="$LDFLAGS $BOOST_REGEX_LDFLAGS"
 fi
 BOOST_FIND_LIB([graph], [$1],
-                [boost/graph/adjacency_list.hpp], [boost::adjacency_list<> g;])
+                [boost/graph/adjacency_list.hpp], [boost::adjacency_list<> g;],
+                [], [], [$2])
 LIBS=$boost_graph_save_LIBS
 LDFLAGS=$boost_graph_save_LDFLAGS
 ])# BOOST_GRAPH
 
 
-# BOOST_IOSTREAMS([PREFERRED-RT-OPT])
+# BOOST_HASH()
+# ------------
+# Look for Boost.Functional/Hash
+BOOST_DEFUN([Hash],
+[BOOST_FIND_HEADER([boost/functional/hash.hpp])])
+
+
+# BOOST_IOSTREAMS([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # -----------------------------------
 # Look for Boost.IOStreams.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.
 BOOST_DEFUN([IOStreams],
 [BOOST_FIND_LIB([iostreams], [$1],
                 [boost/iostreams/device/file_descriptor.hpp],
-                [boost::iostreams::file_descriptor fd; fd.close();])
+                [boost::iostreams::file_descriptor fd; fd.close();],
+                [], [], [$2])
 ])# BOOST_IOSTREAMS
 
 
-# BOOST_HASH()
+# BOOST_ITERATOR()
 # ------------
-# Look for Boost.Functional/Hash
-BOOST_DEFUN([Hash],
-[BOOST_FIND_HEADER([boost/functional/hash.hpp])])
+# Look for Boost.Iterator
+BOOST_DEFUN([Iterator],
+[BOOST_FIND_HEADER([boost/iterator/iterator_adaptor.hpp])])
 
 
 # BOOST_LAMBDA()
@@ -856,7 +1016,7 @@ BOOST_DEFUN([Lambda],
 [BOOST_FIND_HEADER([boost/lambda/lambda.hpp])])
 
 
-# BOOST_LOCALE()
+# BOOST_LOCALE([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # --------------
 # Look for Boost.Locale
 BOOST_DEFUN([Locale],
@@ -865,40 +1025,40 @@ boost_locale_save_LIBS=$LIBS
 boost_locale_save_LDFLAGS=$LDFLAGS
 # require SYSTEM for boost-1.50.0 and up
 if test $boost_major_version -ge 150; then
-  BOOST_SYSTEM([$1])
+  BOOST_SYSTEM([$1], [$2])
   m4_pattern_allow([^BOOST_SYSTEM_(LIBS|LDFLAGS)$])dnl
   LIBS="$LIBS $BOOST_SYSTEM_LIBS"
   LDFLAGS="$LDFLAGS $BOOST_SYSTEM_LDFLAGS"
 fi # end of the Boost.System check.
 BOOST_FIND_LIB([locale], [$1],
     [boost/locale.hpp],
-    [[boost::locale::generator gen; std::locale::global(gen(""));]])
+    [[boost::locale::generator gen; std::locale::global(gen(""));]], [], [], [$2])
 LIBS=$boost_locale_save_LIBS
 LDFLAGS=$boost_locale_save_LDFLAGS
 ])# BOOST_LOCALE
 
-# BOOST_LOG([PREFERRED-RT-OPT])
+# BOOST_LOG([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # -----------------------------
 # Look for Boost.Log.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.
 BOOST_DEFUN([Log],
 [boost_log_save_LIBS=$LIBS
 boost_log_save_LDFLAGS=$LDFLAGS
-BOOST_SYSTEM([$1])
-BOOST_FILESYSTEM([$1])
-BOOST_DATE_TIME([$1])
+BOOST_SYSTEM([$1], [$2])
+BOOST_FILESYSTEM([$1], [$2])
+BOOST_DATE_TIME([$1], [$2])
 m4_pattern_allow([^BOOST_(SYSTEM|FILESYSTEM|DATE_TIME)_(LIBS|LDFLAGS)$])dnl
 LIBS="$LIBS $BOOST_DATE_TIME_LIBS $BOOST_FILESYSTEM_LIBS $BOOST_SYSTEM_LIBS"
 LDFLAGS="$LDFLAGS $BOOST_DATE_TIME_LDFLAGS $BOOST_FILESYSTEM_LDFLAGS $BOOST_SYSTEM_LDFLAGS"
 BOOST_FIND_LIB([log], [$1],
     [boost/log/core/core.hpp],
-    [boost::log::attribute a; a.get_value();])
+    [boost::log::attribute a; a.get_value();], [], [], [$2])
 LIBS=$boost_log_save_LIBS
 LDFLAGS=$boost_log_save_LDFLAGS
 ])# BOOST_LOG
 
 
-# BOOST_LOG_SETUP([PREFERRED-RT-OPT])
+# BOOST_LOG_SETUP([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # -----------------------------------
 # Look for Boost.Log.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.
@@ -911,7 +1071,7 @@ LIBS="$LIBS $BOOST_LOG_LIBS"
 LDFLAGS="$LDFLAGS $BOOST_LOG_LDFLAGS"
 BOOST_FIND_LIB([log_setup], [$1],
     [boost/log/utility/setup/from_settings.hpp],
-    [boost::log::basic_settings<char> bs; bs.empty();])
+    [boost::log::basic_settings<char> bs; bs.empty();], [], [], [$2])
 LIBS=$boost_log_setup_save_LIBS
 LDFLAGS=$boost_log_setup_save_LDFLAGS
 ])# BOOST_LOG_SETUP
@@ -929,7 +1089,7 @@ BOOST_DEFUN([Math],
 [BOOST_FIND_HEADER([boost/math/special_functions.hpp])])
 
 
-# BOOST_MPI([PREFERRED-RT-OPT])
+# BOOST_MPI([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # -------------------------------
 # Look for Boost MPI.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.  Uses MPICXX variable if it is
@@ -946,12 +1106,20 @@ BOOST_FIND_LIB([mpi], [$1],
                [boost/mpi.hpp],
                [int argc = 0;
                 char **argv = 0;
-                boost::mpi::environment env(argc,argv);])
+                boost::mpi::environment env(argc,argv);],
+               [], [], [$2])
 CXX=${boost_save_CXX}
 CXXCPP=${boost_save_CXXCPP}
 ])# BOOST_MPI
 
 
+# BOOST_MPL()
+# ------------------
+# Look for Boost.MPL
+BOOST_DEFUN([MPL],
+[BOOST_FIND_HEADER([boost/mpl/for_each.hpp])])
+
+
 # BOOST_MULTIARRAY()
 # ------------------
 # Look for Boost.MultiArray
@@ -959,6 +1127,13 @@ BOOST_DEFUN([MultiArray],
 [BOOST_FIND_HEADER([boost/multi_array.hpp])])
 
 
+# BOOST_MULTIINDEXCCONTAINER()
+# ------------------
+# Look for Boost.MultiIndexContainer
+BOOST_DEFUN([MultiIndexContainer],
+[BOOST_FIND_HEADER([boost/multi_index_container.hpp])])
+
+
 # BOOST_NUMERIC_UBLAS()
 # --------------------------
 # Look for Boost.NumericUblas (Basic Linear Algebra)
@@ -989,6 +1164,25 @@ BOOST_DEFUN([Preprocessor],
 [BOOST_FIND_HEADER([boost/preprocessor/repeat.hpp])])
 
 
+# BOOST_PROPERTY_TREE([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
+# -----------------------------------------
+# Look for Boost.Property_Tree.  For the documentation of PREFERRED-RT-OPT,
+# see the documentation of BOOST_FIND_LIB above.
+BOOST_DEFUN([Property_Tree],
+[BOOST_FIND_LIB([property_tree], [$1],
+                [boost/property_tree/ptree.hpp],
+                [boost::property_tree::ptree pt; boost::property_tree::read_xml d("test", pt);],
+                [], [], [$2])
+])# BOOST_PROPERTY_TREE
+
+
+# BOOST_RANDOM()
+# --------------------
+# Look for Boost.Random
+BOOST_DEFUN([Random],
+[BOOST_FIND_HEADER([boost/random/random_number_generator.hpp])])
+
+
 # BOOST_RANGE()
 # --------------------
 # Look for Boost.Range
@@ -1009,14 +1203,15 @@ BOOST_DEFUN([Uuid],
 [BOOST_FIND_HEADER([boost/uuid/uuid.hpp])])
 
 
-# BOOST_PROGRAM_OPTIONS([PREFERRED-RT-OPT])
+# BOOST_PROGRAM_OPTIONS([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # -----------------------------------------
 # Look for Boost.Program_options.  For the documentation of PREFERRED-RT-OPT,
 # see the documentation of BOOST_FIND_LIB above.
 BOOST_DEFUN([Program_Options],
 [BOOST_FIND_LIB([program_options], [$1],
                 [boost/program_options.hpp],
-                [boost::program_options::options_description d("test");])
+                [boost::program_options::options_description d("test");],
+                [], [], [$2])
 ])# BOOST_PROGRAM_OPTIONS
 
 
@@ -1032,7 +1227,7 @@ boost_python_save_$1=$$1
 $1="$$1 $BOOST_PYTHON_$1"])
 
 
-# BOOST_PYTHON([PREFERRED-RT-OPT])
+# BOOST_PYTHON([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # --------------------------------
 # Look for Boost.Python.  For the documentation of PREFERRED-RT-OPT,
 # see the documentation of BOOST_FIND_LIB above.
@@ -1043,7 +1238,7 @@ _BOOST_PYTHON_CONFIG([LIBS],      [libs]
 m4_pattern_allow([^BOOST_PYTHON_MODULE$])dnl
 BOOST_FIND_LIBS([python], [python python3], [$1],
                 [boost/python.hpp],
-                [], [BOOST_PYTHON_MODULE(empty) {}])
+                [], [BOOST_PYTHON_MODULE(empty) {}], [], [$2])
 CPPFLAGS=$boost_python_save_CPPFLAGS
 LDFLAGS=$boost_python_save_LDFLAGS
 LIBS=$boost_python_save_LIBS
@@ -1057,18 +1252,26 @@ BOOST_DEFUN([Ref],
 [BOOST_FIND_HEADER([boost/ref.hpp])])
 
 
-# BOOST_REGEX([PREFERRED-RT-OPT])
+# BOOST_REGEX([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # -------------------------------
 # Look for Boost.Regex.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.
 BOOST_DEFUN([Regex],
 [BOOST_FIND_LIB([regex], [$1],
                 [boost/regex.hpp],
-                [boost::regex exp("*"); boost::regex_match("foo", exp);])
+                [boost::regex exp("*"); boost::regex_match("foo", exp);],
+                [], [], [$2])
 ])# BOOST_REGEX
 
 
-# BOOST_SERIALIZATION([PREFERRED-RT-OPT])
+# BOOST_SCOPE_EXIT()
+# ------------
+# Look for Boost.ScopeExit.
+BOOST_DEFUN([SCOPE_EXIT],
+[BOOST_FIND_HEADER([boost/scope_exit.hpp])])
+
+
+# BOOST_SERIALIZATION([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # ---------------------------------------
 # Look for Boost.Serialization.  For the documentation of PREFERRED-RT-OPT, see
 # the documentation of BOOST_FIND_LIB above.
@@ -1076,18 +1279,20 @@ BOOST_DEFUN([Serialization],
 [BOOST_FIND_LIB([serialization], [$1],
                 [boost/archive/text_oarchive.hpp],
                 [std::ostream* o = 0; // Cheap way to get an ostream...
-                boost::archive::text_oarchive t(*o);])
+                boost::archive::text_oarchive t(*o);],
+                [], [], [$2])
 ])# BOOST_SERIALIZATION
 
 
-# BOOST_SIGNALS([PREFERRED-RT-OPT])
+# BOOST_SIGNALS([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # ---------------------------------
 # Look for Boost.Signals.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.
 BOOST_DEFUN([Signals],
 [BOOST_FIND_LIB([signals], [$1],
                 [boost/signal.hpp],
-                [boost::signal<void ()> s;])
+                [boost::signal<void ()> s;],
+                [], [], [$2])
 ])# BOOST_SIGNALS
 
 
@@ -1123,7 +1328,7 @@ BOOST_DEFUN([String_Algo],
 ])
 
 
-# BOOST_SYSTEM([PREFERRED-RT-OPT])
+# BOOST_SYSTEM([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # --------------------------------
 # Look for Boost.System.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.  This library was introduced in Boost
@@ -1131,11 +1336,11 @@ BOOST_DEFUN([String_Algo],
 BOOST_DEFUN([System],
 [BOOST_FIND_LIB([system], [$1],
                 [boost/system/error_code.hpp],
-                [boost::system::error_code e; e.clear();])
+                [boost::system::error_code e; e.clear();], [], [], [$2])
 ])# BOOST_SYSTEM
 
 
-# BOOST_TEST([PREFERRED-RT-OPT])
+# BOOST_TEST([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # ------------------------------
 # Look for Boost.Test.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.
@@ -1145,11 +1350,11 @@ BOOST_FIND_LIB([unit_test_framework], [$
                [boost/test/unit_test.hpp], [BOOST_CHECK(2 == 2);],
                [using boost::unit_test::test_suite;
                test_suite* init_unit_test_suite(int argc, char ** argv)
-               { return NULL; }])
+               { return NULL; }], [], [$2])
 ])# BOOST_TEST
 
 
-# BOOST_THREAD([PREFERRED-RT-OPT])
+# BOOST_THREAD([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # ---------------------------------
 # Look for Boost.Thread.  For the documentation of PREFERRED-RT-OPT, see the
 # documentation of BOOST_FIND_LIB above.
@@ -1163,7 +1368,7 @@ boost_thread_save_LDFLAGS=$LDFLAGS
 boost_thread_save_CPPFLAGS=$CPPFLAGS
 # Link-time dependency from thread to system was added as of 1.49.0.
 if test $boost_major_version -ge 149; then
-BOOST_SYSTEM([$1])
+BOOST_SYSTEM([$1], [$2])
 fi # end of the Boost.System check.
 m4_pattern_allow([^BOOST_SYSTEM_(LIBS|LDFLAGS)$])dnl
 LIBS="$LIBS $BOOST_SYSTEM_LIBS $boost_cv_pthread_flag"
@@ -1182,7 +1387,7 @@ if test $boost_major_version -lt 148; th
 fi
 BOOST_FIND_LIBS([thread], [thread$boost_thread_lib_ext],
                 [$1],
-                [boost/thread.hpp], [boost::thread t; boost::mutex m;])
+                [boost/thread.hpp], [boost::thread t; boost::mutex m;], [], [], [$2])
 
 case $host_os in
   (*mingw*) boost_thread_w32_socket_link=-lws2_32;;
@@ -1258,7 +1463,7 @@ BOOST_FIND_HEADER([boost/ptr_container/p
 ])# BOOST_POINTER_CONTAINER
 
 
-# BOOST_WAVE([PREFERRED-RT-OPT])
+# BOOST_WAVE([PREFERRED-RT-OPT], [ERROR_ON_UNUSABLE])
 # ------------------------------
 # NOTE: If you intend to use Wave/Spirit with thread support, make sure you
 # call BOOST_THREAD first.
@@ -1276,7 +1481,7 @@ LDFLAGS="$LDFLAGS $BOOST_SYSTEM_LDFLAGS
 $BOOST_DATE_TIME_LDFLAGS $BOOST_THREAD_LDFLAGS"
 BOOST_FIND_LIB([wave], [$1],
                 [boost/wave.hpp],
-                [boost::wave::token_id id; get_token_name(id);])
+                [boost::wave::token_id id; get_token_name(id);], [], [], [$2])
 LIBS=$boost_wave_save_LIBS
 LDFLAGS=$boost_wave_save_LDFLAGS
 ])# BOOST_WAVE
@@ -1344,10 +1549,11 @@ AC_CACHE_CHECK([for the flags needed to
                            -pthreads -mthreads -lpthread --thread-safe -mt";;
   esac
   # Generate the test file.
-  AC_LANG_CONFTEST([AC_LANG_PROGRAM([#include <pthread.h>],
-    [pthread_t th; pthread_join(th, 0);
-    pthread_attr_init(0); pthread_cleanup_push(0, 0);
-    pthread_create(0,0,0,0); pthread_cleanup_pop(0);])])
+  AC_LANG_CONFTEST([AC_LANG_PROGRAM([#include <pthread.h>
+    void *f(void*){ return 0; }],
+    [pthread_t th; pthread_create(&th,0,f,0); pthread_join(th,0);
+    pthread_attr_t attr; pthread_attr_init(&attr); pthread_cleanup_push(0, 0);
+    pthread_cleanup_pop(0);])])
   for boost_pthread_flag in '' $boost_pthread_flags; do
     boost_pthread_ok=false
 dnl Re-use the test file already generated.
@@ -1409,6 +1615,77 @@ if test x$boost_cv_inc_path != xno; then
   # I'm not sure about my test for `il' (be careful: Intel's ICC pre-defines
   # the same defines as GCC's).
   for i in \
+    "defined __clang__ && __clang_major__ == 14 && __clang_minor__ == 0 @ clang140" \
+    "defined __clang__ && __clang_major__ == 13 && __clang_minor__ == 0 @ clang130" \
+    "defined __clang__ && __clang_major__ == 12 && __clang_minor__ == 0 @ clang120" \
+    "defined __clang__ && __clang_major__ == 11 && __clang_minor__ == 1 @ clang111" \
+    "defined __clang__ && __clang_major__ == 11 && __clang_minor__ == 0 @ clang110" \
+    "defined __clang__ && __clang_major__ == 10 && __clang_minor__ == 0 @ clang100" \
+    "defined __clang__ && __clang_major__ == 9 && __clang_minor__ == 0 @ clang90" \
+    "defined __clang__ && __clang_major__ == 8 && __clang_minor__ == 0 @ clang80" \
+    "defined __clang__ && __clang_major__ == 7 && __clang_minor__ == 0 @ clang70" \
+    "defined __clang__ && __clang_major__ == 6 && __clang_minor__ == 0 @ clang60" \
+    "defined __clang__ && __clang_major__ == 5 && __clang_minor__ == 0 @ clang50" \
+    "defined __clang__ && __clang_major__ == 4 && __clang_minor__ == 0 @ clang40" \
+    "defined __clang__ && __clang_major__ == 3 && __clang_minor__ == 9 @ clang39" \
+    "defined __clang__ && __clang_major__ == 3 && __clang_minor__ == 8 @ clang38" \
+    "defined __clang__ && __clang_major__ == 3 && __clang_minor__ == 7 @ clang37" \
+    _BOOST_mingw_test(11, 2) \
+    _BOOST_gcc_test(11, 2) \
+    _BOOST_mingw_test(11, 1) \
+    _BOOST_gcc_test(11, 1) \
+    _BOOST_mingw_test(10, 3) \
+    _BOOST_gcc_test(10, 3) \
+    _BOOST_mingw_test(10, 2) \
+    _BOOST_gcc_test(10, 2) \
+    _BOOST_mingw_test(10, 1) \
+    _BOOST_gcc_test(10, 1) \
+    _BOOST_mingw_test(9, 3) \
+    _BOOST_gcc_test(9, 3) \
+    _BOOST_mingw_test(9, 2) \
+    _BOOST_gcc_test(9, 2) \
+    _BOOST_mingw_test(9, 1) \
+    _BOOST_gcc_test(9, 1) \
+    _BOOST_mingw_test(9, 0) \
+    _BOOST_gcc_test(9, 0) \
+    _BOOST_mingw_test(8, 5) \
+    _BOOST_gcc_test(8, 5) \
+    _BOOST_mingw_test(8, 4) \
+    _BOOST_gcc_test(8, 4) \
+    _BOOST_mingw_test(8, 3) \
+    _BOOST_gcc_test(8, 3) \
+    _BOOST_mingw_test(8, 2) \
+    _BOOST_gcc_test(8, 2) \
+    _BOOST_mingw_test(8, 1) \
+    _BOOST_gcc_test(8, 1) \
+    _BOOST_mingw_test(8, 0) \
+    _BOOST_gcc_test(8, 0) \
+    _BOOST_mingw_test(7, 4) \
+    _BOOST_gcc_test(7, 4) \
+    _BOOST_mingw_test(7, 3) \
+    _BOOST_gcc_test(7, 3) \
+    _BOOST_mingw_test(7, 2) \
+    _BOOST_gcc_test(7, 2) \
+    _BOOST_mingw_test(7, 1) \
+    _BOOST_gcc_test(7, 1) \
+    _BOOST_mingw_test(7, 0) \
+    _BOOST_gcc_test(7, 0) \
+    _BOOST_mingw_test(6, 5) \
+    _BOOST_gcc_test(6, 5) \
+    _BOOST_mingw_test(6, 4) \
+    _BOOST_gcc_test(6, 4) \
+    _BOOST_mingw_test(6, 3) \
+    _BOOST_gcc_test(6, 3) \
+    _BOOST_mingw_test(6, 2) \
+    _BOOST_gcc_test(6, 2) \
+    _BOOST_mingw_test(6, 1) \
+    _BOOST_gcc_test(6, 1) \
+    _BOOST_mingw_test(6, 0) \
+    _BOOST_gcc_test(6, 0) \
+    _BOOST_mingw_test(5, 5) \
+    _BOOST_gcc_test(5, 5) \
+    _BOOST_mingw_test(5, 4) \
+    _BOOST_gcc_test(5, 4) \
     _BOOST_mingw_test(5, 3) \
     _BOOST_gcc_test(5, 3) \
     _BOOST_mingw_test(5, 2) \
--- a/m4/gettext.m4
+++ b/m4/gettext.m4
@@ -425,7 +425,7 @@ AC_DEFUN([AM_PO_SUBDIRS],
               test -n "$as_me" && echo "$as_me: setting ALL_LINGUAS in configure.in is obsolete" || echo "setting ALL_LINGUAS in configure.in is obsolete"
             fi
             ALL_LINGUAS_=`sed -e "/^#/d" "$ac_given_srcdir/$ac_dir/LINGUAS"`
-            # Hide the ALL_LINGUAS assigment from automake.
+            # Hide the ALL_LINGUAS assignment from automake.
             eval 'ALL_LINGUAS''=$ALL_LINGUAS_'
           fi
           case "$ac_given_srcdir" in
--- a/m4/muleboost.m4
+++ b/m4/muleboost.m4
@@ -54,7 +54,7 @@ esac
 # Adds a configure flag --with-boost[=DIR]. You may optionally specify the
 # location of boost headers (or sources), if they are in a non-standard
 # location. If --with-boost if not given, nothing is done. Otherwise it
-# checks for the required minumum Boost version, and Boost.Asio. If everything
+# checks for the required minimum Boost version, and Boost.Asio. If everything
 # is fine, defines ASIO_SOCKETS. If the Boost sources are found, also defines
 # HAVE_BOOST_SOURCES. Other flags defined for using Boost:
 #   - BOOST_CPPFLAGS
--- a/Makefile.am
+++ b/Makefile.am
@@ -7,7 +7,7 @@ endif
 SUBDIRS += docs src unittests
 
 EXTRA_DIST = amule.rc amule.ico amule.png convert.ico \
-	aMule.spec \
+	README.Debian-Packages aMule-CVS.spec aMule.spec \
 	amule_build_install.sh autogen.sh \
 	po/l10n.xsl
 
@@ -56,5 +56,5 @@ MAINTAINERCLEANFILES = ABOUT-NLS \
 					   missing \
 					   mkinstalldirs
 
-EXTRA__DIST__SUBDIRS = aMule.app
+EXTRA__DIST__SUBDIRS = aMule.app debian
 include $(top_srcdir)/automake/dist-hook.am
--- a/platforms/MacOSX/cocoa-mule/English.lproj/MainMenu.nib/designable.nib
+++ b/platforms/MacOSX/cocoa-mule/English.lproj/MainMenu.nib/designable.nib
@@ -2074,7 +2074,7 @@ ELIAAAAAAAgACAAIAAgAAQABAAEAAQ</bytes>
 							<object class="NSTextFieldCell" key="NSCell" id="252325160">
 								<int key="NSCellFlags">68288064</int>
 								<int key="NSCellFlags2">272761856</int>
-								<string key="NSContents">Conection status</string>
+								<string key="NSContents">Connection status</string>
 								<reference key="NSSupport" ref="26"/>
 								<reference key="NSControlView" ref="264279150"/>
 								<reference key="NSBackgroundColor" ref="16080844"/>
--- a/platforms/Windows/MSVC10/libs/libGeoIP/readme.txt
+++ b/platforms/Windows/MSVC10/libs/libGeoIP/readme.txt
@@ -1,6 +1,6 @@
 How to build aMule with GeoIP support
 
-The MaxMind GeoIP library can detect the country an IP adress comes from. aMule uses this information
+The MaxMind GeoIP library can detect the country an IP address comes from. aMule uses this information
 to display a little country flag for each source or ed2k server.
 Since this is an external library it is disabled by default. This is how to enable it:
 
--- a/platforms/Windows/MSVC12/libs/libGeoIP/readme.txt
+++ b/platforms/Windows/MSVC12/libs/libGeoIP/readme.txt
@@ -1,6 +1,6 @@
 How to build aMule with GeoIP support
 
-The MaxMind GeoIP library can detect the country an IP adress comes from. aMule uses this information
+The MaxMind GeoIP library can detect the country an IP address comes from. aMule uses this information
 to display a little country flag for each source or ed2k server.
 Since this is an external library it is disabled by default. This is how to enable it:
 
--- a/README.md
+++ b/README.md
@@ -96,7 +96,7 @@ You can contribute to aMule several ways
   [translate aMule's documentation][9] to your language.
 * Fixing the wiki. aMule's wiki contains a lot of old, outdated information,
   that is simply not true anymore. One should read through the pages, update
-  manuals and references and remove obsolate information.
+  manuals and references and remove obsolete information.
 
 [6]: https://github.com/amule-project/amule/pulls  "aMule Pull Requests"
 [7]: http://wiki.amule.org/wiki/Translations	   "Translating aMule"
--- a/src/amule.cpp
+++ b/src/amule.cpp
@@ -95,11 +95,7 @@
 #ifndef AMULE_DAEMON
 	#ifdef __WXMAC__
 		#include <CoreFoundation/CFBundle.h>  // Do_not_auto_remove
-		#if wxCHECK_VERSION(2, 9, 0)
-			#include <wx/osx/core/cfstring.h>  // Do_not_auto_remove
-		#else
-			#include <wx/mac/corefoundation/cfstring.h>  // Do_not_auto_remove
-		#endif
+		#include <wx/osx/core/cfstring.h>  // Do_not_auto_remove
 	#endif
 	#include <wx/msgdlg.h>
 
@@ -638,11 +634,7 @@ bool CamuleApp::OnInit()
 			if (absoluteUrl) {
 				CFStringRef amulewebCfstr = CFURLCopyFileSystemPath(absoluteUrl, kCFURLPOSIXPathStyle);
 				CFRelease(absoluteUrl);
-	#if wxCHECK_VERSION(2, 9, 0)
 				amulewebPath = wxCFStringRef(amulewebCfstr).AsString(wxLocale::GetSystemEncoding());
-	#else
-				amulewebPath = wxMacCFStringHolder(amulewebCfstr).AsString(wxLocale::GetSystemEncoding());
-	#endif
 			}
 		}
 #endif
--- a/src/amuled.cpp
+++ b/src/amuled.cpp
@@ -71,11 +71,6 @@
 	#include <wx/ffile.h>
 #endif
 
-#ifdef AMULED_APPTRAITS
-	#include <wx/unix/execute.h>
-#endif
-
-
 BEGIN_EVENT_TABLE(CamuleDaemonApp, wxAppConsole)
 
 #ifndef ASIO_SOCKETS
@@ -123,440 +118,6 @@ END_EVENT_TABLE()
 
 IMPLEMENT_APP(CamuleDaemonApp)
 
-#ifdef AMULED28_SOCKETS
-/*
- * Socket handling in wxBase
- *
- */
-class CSocketSet {
-		int m_count;
-		int m_fds[FD_SETSIZE], m_fd_idx[FD_SETSIZE];
-		GSocket *m_gsocks[FD_SETSIZE];
-
-		fd_set m_set;
-	public:
-		CSocketSet();
-		void AddSocket(GSocket *);
-		void RemoveSocket(GSocket *);
-		void FillSet(int &max_fd);
-
-		void Detected(void (GSocket::*func)());
-
-		fd_set *Set() { return &m_set; }
-};
-
-CSocketSet::CSocketSet()
-{
-	m_count = 0;
-	for(int i = 0; i < FD_SETSIZE; i++) {
-		m_fds[i] = 0;
-		m_fd_idx[i] = 0xffff;
-		m_gsocks[i] = 0;
-	}
-}
-
-void CSocketSet::AddSocket(GSocket *socket)
-{
-	wxASSERT(socket);
-
-	int fd = socket->m_fd;
-
-	if ( fd == -1 ) {
-		return;
-	}
-
-	wxASSERT( (fd > 2) && (fd < FD_SETSIZE) );
-
-	if ( m_gsocks[fd] ) {
-		return;
-	}
-	m_fds[m_count] = fd;
-	m_fd_idx[fd] = m_count;
-	m_gsocks[fd] = socket;
-	m_count++;
-}
-
-void CSocketSet::RemoveSocket(GSocket *socket)
-{
-	wxASSERT(socket);
-
-	int fd = socket->m_fd;
-
-	if ( fd == -1 ) {
-		return;
-	}
-
-	wxASSERT( (fd > 2) && (fd < FD_SETSIZE) );
-
-	int i = m_fd_idx[fd];
-	if ( i == 0xffff ) {
-		return;
-	}
-	wxASSERT(m_fds[i] == fd);
-	m_fds[i] = m_fds[m_count-1];
-	m_gsocks[fd] = 0;
-	m_fds[m_count-1] = 0;
-	m_fd_idx[fd] = 0xffff;
-	m_fd_idx[m_fds[i]] = i;
-	m_count--;
-}
-
-void CSocketSet::FillSet(int &max_fd)
-{
-	FD_ZERO(&m_set);
-
-	for(int i = 0; i < m_count; i++) {
-	    FD_SET(m_fds[i], &m_set);
-	    if ( m_fds[i] > max_fd ) {
-		max_fd = m_fds[i];
-	    }
-	}
-}
-
-void CSocketSet::Detected(void (GSocket::*func)())
-{
-	for (int i = 0; i < m_count; i++) {
-		int fd = m_fds[i];
-		if ( FD_ISSET(fd, &m_set) ) {
-			GSocket *socket = m_gsocks[fd];
-			(*socket.*func)();
-		}
-	}
-}
-
-CAmuledGSocketFuncTable::CAmuledGSocketFuncTable() : m_lock(wxMUTEX_RECURSIVE)
-{
-	m_in_set = new CSocketSet;
-	m_out_set = new CSocketSet;
-
-	m_lock.Unlock();
-}
-
-void CAmuledGSocketFuncTable::AddSocket(GSocket *socket, GSocketEvent event)
-{
-	wxMutexLocker lock(m_lock);
-
-	if ( event == GSOCK_INPUT ) {
-		m_in_set->AddSocket(socket);
-	} else {
-		m_out_set->AddSocket(socket);
-	}
-}
-
-void CAmuledGSocketFuncTable::RemoveSocket(GSocket *socket, GSocketEvent event)
-{
-	wxMutexLocker lock(m_lock);
-
-	if ( event == GSOCK_INPUT ) {
-		m_in_set->RemoveSocket(socket);
-	} else {
-		m_out_set->RemoveSocket(socket);
-	}
-}
-
-void CAmuledGSocketFuncTable::RunSelect()
-{
-	wxMutexLocker lock(m_lock);
-
-	int max_fd = -1;
-	m_in_set->FillSet(max_fd);
-	m_out_set->FillSet(max_fd);
-
-	struct timeval tv;
-	tv.tv_sec = 0;
-	tv.tv_usec = 10000; // 10ms
-
-	int result = select(max_fd + 1, m_in_set->Set(), m_out_set->Set(), 0, &tv);
-	if ( result > 0 ) {
-		m_in_set->Detected(&GSocket::Detected_Read);
-		m_out_set->Detected(&GSocket::Detected_Write);
-	}
-}
-
-GSocketGUIFunctionsTable *CDaemonAppTraits::GetSocketGUIFunctionsTable()
-{
-	return m_table;
-}
-
-bool CAmuledGSocketFuncTable::OnInit()
-{
-	return true;
-}
-
-void CAmuledGSocketFuncTable::OnExit()
-{
-}
-
-bool CAmuledGSocketFuncTable::CanUseEventLoop()
-{
-	/*
-	 * FIXME: (lfroen) Not sure whether it's right.
-	 * I will review it later.
-	 */
-	return false;
-}
-
-bool CAmuledGSocketFuncTable::Init_Socket(GSocket *)
-{
-	return true;
-}
-
-void CAmuledGSocketFuncTable::Destroy_Socket(GSocket *)
-{
-}
-
-void CAmuledGSocketFuncTable::Install_Callback(GSocket *sock, GSocketEvent e)
-{
-	AddSocket(sock, e);
-}
-
-void CAmuledGSocketFuncTable::Uninstall_Callback(GSocket *sock, GSocketEvent e)
-{
-	RemoveSocket(sock, e);
-}
-
-void CAmuledGSocketFuncTable::Enable_Events(GSocket *socket)
-{
-	Install_Callback(socket, GSOCK_INPUT);
-	Install_Callback(socket, GSOCK_OUTPUT);
-}
-
-void CAmuledGSocketFuncTable::Disable_Events(GSocket *socket)
-{
-	Uninstall_Callback(socket, GSOCK_INPUT);
-	Uninstall_Callback(socket, GSOCK_OUTPUT);
-}
-
-
-CDaemonAppTraits::CDaemonAppTraits(CAmuledGSocketFuncTable *table)
-:
-wxConsoleAppTraits(),
-m_oldSignalChildAction(),
-m_newSignalChildAction(),
-m_table(table),
-m_lock(wxMUTEX_RECURSIVE),
-m_sched_delete()
-{
-	m_lock.Unlock();
-}
-
-
-void CDaemonAppTraits::ScheduleForDestroy(wxObject *object)
-{
-	wxMutexLocker lock(m_lock);
-
-	//delete object;
-	m_sched_delete.push_back(object);
-}
-
-void CDaemonAppTraits::RemoveFromPendingDelete(wxObject *object)
-{
-	wxMutexLocker lock(m_lock);
-
-	for(std::list<wxObject *>::iterator i = m_sched_delete.begin();
-		i != m_sched_delete.end(); i++) {
-			if ( *i == object ) {
-				m_sched_delete.erase(i);
-				return;
-			}
-		}
-}
-
-void CDaemonAppTraits::DeletePending()
-{
-	wxMutexLocker lock(m_lock);
-
-	while ( !m_sched_delete.empty() ) {
-		std::list<wxObject *>::iterator i = m_sched_delete.begin();
-		wxObject *object = *i;
-		delete object;
-	}
-	//m_sched_delete.erase(m_sched_delete.begin(), m_sched_delete.end());
-}
-
-wxAppTraits *CamuleDaemonApp::CreateTraits()
-{
-	return new CDaemonAppTraits(m_table);
-}
-
-#else	// AMULED28_SOCKETS
-
-#ifdef AMULED_APPTRAITS
-
-CDaemonAppTraits::CDaemonAppTraits()
-:
-wxConsoleAppTraits(),
-m_oldSignalChildAction(),
-m_newSignalChildAction()
-{
-}
-
-wxAppTraits *CamuleDaemonApp::CreateTraits()
-{
-	return new CDaemonAppTraits();
-}
-
-#endif	// AMULED_APPTRAITS
-
-#endif	// !AMULED28_SOCKETS
-
-#if defined(__WXMAC__) && !wxCHECK_VERSION(2, 9, 0)
-#include <wx/stdpaths.h> // Do_not_auto_remove (guess)
-static wxStandardPathsCF gs_stdPaths;
-wxStandardPathsBase& CDaemonAppTraits::GetStandardPaths()
-{
-	return gs_stdPaths;
-}
-#endif
-
-
-#ifdef AMULED28_EVENTLOOP
-
-CamuleDaemonApp::CamuleDaemonApp()
-:
-m_Exit(false)
-#ifdef AMULED28_SOCKETS
-,m_table(new CAmuledGSocketFuncTable())
-#endif
-{
-	// work around problem from http://trac.wxwidgets.org/ticket/2145
-	wxPendingEventsLocker = new wxCriticalSection;
-}
-
-#endif	// AMULED28_EVENTLOOP
-
-
-#ifdef AMULED_APPTRAITS
-
-static EndProcessDataMap endProcDataMap;
-
-int CDaemonAppTraits::WaitForChild(wxExecuteData &execData)
-{
-	int status = 0;
-	pid_t result = 0;
-	// Build the log message
-	wxString msg;
-	msg << wxT("WaitForChild() has been called for child process with pid `") <<
-		execData.pid <<
-		wxT("'. ");
-
-	if (execData.flags & wxEXEC_SYNC) {
-		result = AmuleWaitPid(execData.pid, &status, 0, &msg);
-		if (result == -1 || (!WIFEXITED(status) && !WIFSIGNALED(status))) {
-			msg << wxT(" Waiting for subprocess termination failed.");
-			AddDebugLogLineN(logGeneral, msg);
-		}
-	} else {
-		/** wxEXEC_ASYNC */
-		// Give the process a chance to start or forked child to exit
-		// 1 second is enough time to fail on "path not found"
-		wxSleep(1);
-		result = AmuleWaitPid(execData.pid, &status, WNOHANG, &msg);
-		if (result == 0) {
-			// Add a WxEndProcessData entry to the map, so that we can
-			// support process termination
-			wxEndProcessData *endProcData = new wxEndProcessData();
-			endProcData->pid = execData.pid;
-			endProcData->process = execData.process;
-			endProcData->tag = 0;
-			endProcDataMap[execData.pid] = endProcData;
-
-			status = execData.pid;
-		} else {
-			// if result != 0, then either waitpid() failed (result == -1)
-			// and there is nothing we can do, or the child has changed
-			// status, which means it is probably dead.
-			status = 0;
-		}
-	}
-
-	// Log our passage here
-	AddDebugLogLineN(logGeneral, msg);
-
-	return status;
-}
-
-
-void OnSignalChildHandler(int /*signal*/, siginfo_t *siginfo, void * /*ucontext*/)
-{
-	// Build the log message
-	wxString msg;
-	msg << wxT("OnSignalChildHandler() has been called for child process with pid `") <<
-		siginfo->si_pid <<
-		wxT("'. ");
-	// Make sure we leave no zombies by calling waitpid()
-	int status = 0;
-	pid_t result = AmuleWaitPid(siginfo->si_pid, &status, WNOHANG, &msg);
-	if (result != 1 && result != 0 && (WIFEXITED(status) || WIFSIGNALED(status))) {
-		// Fetch the wxEndProcessData structure corresponding to this pid
-		EndProcessDataMap::iterator it = endProcDataMap.find(siginfo->si_pid);
-		if (it != endProcDataMap.end()) {
-			wxEndProcessData *endProcData = it->second;
-			// Remove this entry from the process map
-			endProcDataMap.erase(siginfo->si_pid);
-			// Save the exit code for the wxProcess object to read later
-			endProcData->exitcode = result != -1 && WIFEXITED(status) ?
-				WEXITSTATUS(status) : -1;
-			// Make things work as in wxGUI
-			wxHandleProcessTermination(endProcData);
-
-			// wxHandleProcessTermination() will "delete endProcData;"
-			// So we do not delete it again, ok? Do not uncomment this line.
-			//delete endProcData;
-		} else {
-			msg << wxT(" Error: the child process pid is not on the pid map.");
-		}
-	}
-
-	// Log our passage here
-	AddDebugLogLineN(logGeneral, msg);
-}
-
-
-pid_t AmuleWaitPid(pid_t pid, int *status, int options, wxString *msg)
-{
-	*status = 0;
-	pid_t result = waitpid(pid, status, options);
-	if (result == -1) {
-		*msg << CFormat(wxT("Error: waitpid() call failed: %m."));
-	} else if (result == 0) {
-		if (options & WNOHANG)  {
-			*msg << wxT("The child is alive.");
-		} else {
-			*msg << wxT("Error: waitpid() call returned 0 but "
-				"WNOHANG was not specified in options.");
-		}
-	} else {
-		if (WIFEXITED(*status)) {
-			*msg << wxT("Child has terminated with status code `") <<
-				WEXITSTATUS(*status) <<
-				wxT("'.");
-		} else if (WIFSIGNALED(*status)) {
-			*msg << wxT("Child was killed by signal `") <<
-				WTERMSIG(*status) <<
-				wxT("'.");
-			if (WCOREDUMP(*status)) {
-				*msg << wxT(" A core file has been dumped.");
-			}
-		} else if (WIFSTOPPED(*status)) {
-			*msg << wxT("Child has been stopped by signal `") <<
-				WSTOPSIG(*status) <<
-				wxT("'.");
-#ifdef WIFCONTINUED /* Only found in recent kernels. */
-		} else if (WIFCONTINUED(*status)) {
-			*msg << wxT("Child has received `SIGCONT' and has continued execution.");
-#endif
-		} else {
-			*msg << wxT("The program was not able to determine why the child has signaled.");
-		}
-	}
-
-	return result;
-}
-
-#endif	// AMULED_APPTRAITS
-
-
 #ifdef __WINDOWS__
 //
 // CTRL-C-Handler
@@ -599,48 +160,7 @@ int CamuleDaemonApp::OnRun()
 	SetConsoleCtrlHandler((PHANDLER_ROUTINE) CtrlHandler, TRUE);
 #endif // __WINDOWS__
 
-#ifdef AMULED_APPTRAITS
-	// Process the return code of dead children so that we do not create
-	// zombies. wxBase does not implement wxProcess callbacks, so no one
-	// actually calls wxHandleProcessTermination() in console applications.
-	// We do our best here.
-	DEBUG_ONLY( int ret = 0; )
-	DEBUG_ONLY( ret = ) sigaction(SIGCHLD, NULL, &m_oldSignalChildAction);
-	m_newSignalChildAction = m_oldSignalChildAction;
-	m_newSignalChildAction.sa_sigaction = OnSignalChildHandler;
-	m_newSignalChildAction.sa_flags |=  SA_SIGINFO;
-	m_newSignalChildAction.sa_flags &= ~SA_RESETHAND;
-	DEBUG_ONLY( ret = ) sigaction(SIGCHLD, &m_newSignalChildAction, NULL);
-#ifdef __DEBUG__
-	if (ret == -1) {
-		AddDebugLogLineC(logStandard, CFormat(wxT("CamuleDaemonApp::OnRun(): Installation of SIGCHLD callback with sigaction() failed: %m.")));
-	} else {
-		AddDebugLogLineN(logGeneral, wxT("CamuleDaemonApp::OnRun(): Installation of SIGCHLD callback with sigaction() succeeded."));
-	}
-#endif
-#endif	// AMULED_APPTRAITS
-
-#ifdef AMULED28_EVENTLOOP
-
-	while ( !m_Exit ) {
-#ifdef AMULED28_SOCKETS
-		m_table->RunSelect();
-		ProcessPendingEvents();
-		((CDaemonAppTraits *)GetTraits())->DeletePending();
-#else
-		wxMilliSleep(10);
-		ProcessPendingEvents();
-#endif
-	}
-
-	// ShutDown is being called twice. Once here and again in OnExit().
-	ShutDown();
-
-	return 0;
-
-#else
 	return wxApp::OnRun();
-#endif
 }
 
 bool CamuleDaemonApp::OnInit()
@@ -741,34 +261,8 @@ bool CamuleDaemonApp::Initialize(int& ar
 
 int CamuleDaemonApp::OnExit()
 {
-#ifdef AMULED28_SOCKETS
-	/*
-	 * Stop all socket threads before entering
-	 * shutdown sequence.
-	 */
-	delete listensocket;
-	listensocket = 0;
-	if (clientudp) {
-		delete clientudp;
-		clientudp = NULL;
-	}
-#endif
-
 	ShutDown();
-
-#ifdef AMULED_APPTRAITS
-	DEBUG_ONLY( int ret = ) sigaction(SIGCHLD, &m_oldSignalChildAction, NULL);
-#ifdef __DEBUG__
-	if (ret == -1) {
-		AddDebugLogLineC(logStandard, CFormat(wxT("CamuleDaemonApp::OnRun(): second sigaction() failed: %m.")));
-	} else {
-		AddDebugLogLineN(logGeneral, wxT("CamuleDaemonApp::OnRun(): Uninstallation of SIGCHLD callback with sigaction() succeeded."));
-	}
-#endif
-#endif // AMULED_APPTRAITS
-
 	delete core_timer;
-
 	return CamuleApp::OnExit();
 }
 
--- a/src/amuleDlg.cpp
+++ b/src/amuleDlg.cpp
@@ -211,7 +211,7 @@ m_clientSkinNames(CLIENT_SKIN_SIZE)
 	wxSystemOptions::SetOption(wxT("msw.remap"), 0);
 #endif
 
-#if !(wxCHECK_VERSION(2, 9, 0) && defined(__WXMAC__))
+#if !defined(__WXMAC__)
 	// this crashes on Mac with wx 2.9
 	SetIcon(wxICON(aMule));
 #endif
@@ -628,9 +628,7 @@ void CamuleDlg::AddLogLine(const wxStrin
 		wxFont font = style.GetFont();
 		font.SetWeight(addtostatusbar ? wxFONTWEIGHT_BOLD : wxFONTWEIGHT_NORMAL);
 		style.SetFont(font);
-#if wxCHECK_VERSION(2, 9, 0)
 		style.SetFontSize(8);
-#endif
 		ct->SetDefaultStyle(style);
 		ct->AppendText(bufferline);
 		ct->ShowPosition( ct->GetLastPosition() - 1 );
@@ -786,7 +784,7 @@ void CamuleDlg::ShowConnectionState(bool
 	if ( (true == skinChanged) || (currentState != s_oldState) ) {
 		wxWindowUpdateLocker freezer(m_wndToolbar);
 
-		wxToolBarToolBase* toolbarTool = m_wndToolbar->RemoveTool(ID_BUTTONCONNECT);
+		wxToolBarToolBase* toolbarTool = m_wndToolbar->FindById(ID_BUTTONCONNECT);
 
 		switch (currentState) {
 			case ECS_Connecting:
@@ -807,8 +805,6 @@ void CamuleDlg::ShowConnectionState(bool
 				toolbarTool->SetNormalBitmap(m_tblist.GetBitmap(0));
 		}
 
-		m_wndToolbar->InsertTool(0, toolbarTool);
-		m_wndToolbar->Realize();
 		m_wndToolbar->EnableTool(ID_BUTTONCONNECT, (thePrefs::GetNetworkED2K() || thePrefs::GetNetworkKademlia()) && theApp->ipfilter->IsReady());
 
 		s_oldState = currentState;
@@ -1078,11 +1074,7 @@ void CamuleDlg::OnMinimize(wxIconizeEven
 			// Veto.
 		} else {
 			if (m_wndTaskbarNotifier && thePrefs::DoMinToTray()) {
-#if wxCHECK_VERSION(2, 9, 0)
 				Show(!evt.IsIconized());
-#else
-				Show(!evt.Iconized());
-#endif
 			}
 			else {
 				evt.Skip();
@@ -1374,19 +1366,11 @@ void CamuleDlg::Create_Toolbar(bool orie
 	}
 
 	if (!m_wndToolbar) {
-        #if wxCHECK_VERSION(3, 1, 2)
-            m_wndToolbar = CreateToolBar(
-                (orientation ? wxTB_VERTICAL : wxTB_HORIZONTAL) |
-                wxNO_BORDER | wxTB_TEXT | wxTB_FLAT |
-                wxCLIP_CHILDREN | wxTB_NODIVIDER);
-        #else
-            m_wndToolbar = CreateToolBar(
-                (orientation ? wxTB_VERTICAL : wxTB_HORIZONTAL) |
-                wxNO_BORDER | wxTB_TEXT | wxTB_3DBUTTONS |
-                wxTB_FLAT | wxCLIP_CHILDREN | wxTB_NODIVIDER);
-        #endif
+		m_wndToolbar = CreateToolBar((orientation ? wxTB_VERTICAL : wxTB_HORIZONTAL) |
+					      wxNO_BORDER | wxTB_TEXT | wxTB_FLAT |
+					      wxCLIP_CHILDREN | wxTB_NODIVIDER);
 
-			m_wndToolbar->SetToolBitmapSize(wxSize(32, 32));
+		m_wndToolbar->SetToolBitmapSize(wxSize(32, 32));
 	}
 
 	Apply_Toolbar_Skin(m_wndToolbar);
@@ -1439,7 +1423,7 @@ void CamuleDlg::DoNetworkRearrange()
 	wxWindowUpdateLocker freezer(this);
 #endif
 
-	wxToolBarToolBase* toolbarTool = m_wndToolbar->RemoveTool(ID_BUTTONNETWORKS);
+	wxToolBarToolBase* toolbarTool = m_wndToolbar->FindById(ID_BUTTONNETWORKS);
 
 	// set the log windows
 	wxNotebook* logs_notebook = CastChild( ID_SRVLOG_NOTEBOOK, wxNotebook);
@@ -1532,12 +1516,9 @@ void CamuleDlg::DoNetworkRearrange()
 
 	// Tool bar
 
-	m_wndToolbar->InsertTool(2, toolbarTool);
 	m_wndToolbar->EnableTool(ID_BUTTONNETWORKS, (thePrefs::GetNetworkED2K() || thePrefs::GetNetworkKademlia()));
 	m_wndToolbar->EnableTool(ID_BUTTONCONNECT, (thePrefs::GetNetworkED2K() || thePrefs::GetNetworkKademlia()) && theApp->ipfilter->IsReady());
 
-	m_wndToolbar->Realize();
-
 	ShowConnectionState();	// status in the bottom right
 	m_searchwnd->FixSearchTypes();
 }
--- a/src/amule-gui.cpp
+++ b/src/amule-gui.cpp
@@ -28,6 +28,7 @@
 #include <common/ClientVersion.h>
 
 #include <wx/clipbrd.h>			// Needed for wxClipBoard
+#include <wx/sizer.h>
 #include <wx/tokenzr.h>			// Needed for wxStringTokenizer
 
 #include "SharedFilesWnd.h"		// Needed for CSharedFilesWnd
@@ -98,6 +99,11 @@ IMPLEMENT_APP(CamuleGuiApp)
 
 CamuleGuiBase::CamuleGuiBase()
 {
+	// Disable these checks for now.  The code really needs updating to
+	// eliminate these inconsistent flag uses, but these checks are new
+	// since wx3.0, and this should just return us to what 3.0 did.
+	wxSizerFlags::DisableConsistencyChecks();
+
 	amuledlg = NULL;
 }
 
--- a/src/amule.h
+++ b/src/amule.h
@@ -434,116 +434,10 @@ extern CamuleGuiApp *theApp;
 
 #else /* ! AMULE_DAEMON */
 
-// wxWidgets 2.8 requires special code for event handling and sockets.
-// 2.9 doesn't, so standard event loop and sockets can be used
-//
-// Windows: aMuled compiles with 2.8 (without the special code),
-// but works only with 2.9
-
-#if !wxCHECK_VERSION(2, 9, 0)
-	// wx 2.8 needs a hand-made event loop in any case
-	#define AMULED28_EVENTLOOP
-
-	#ifndef ASIO_SOCKETS
-		// MSW: can't run amuled with 2.8 without ASIO sockets, just get it compiled
-		#ifndef __WINDOWS__
-			#define AMULED28_SOCKETS
-		#endif
-	#endif
-#endif
-
-#ifdef AMULED28_SOCKETS
-#include <wx/socket.h>
-
-class CSocketSet;
-
-
-class CAmuledGSocketFuncTable : public GSocketGUIFunctionsTable
-{
-private:
-	CSocketSet *m_in_set, *m_out_set;
-
-	wxMutex m_lock;
-public:
-	CAmuledGSocketFuncTable();
-
-	void AddSocket(GSocket *socket, GSocketEvent event);
-	void RemoveSocket(GSocket *socket, GSocketEvent event);
-	void RunSelect();
-
-	virtual bool OnInit();
-	virtual void OnExit();
-	virtual bool CanUseEventLoop();
-	virtual bool Init_Socket(GSocket *socket);
-	virtual void Destroy_Socket(GSocket *socket);
-	virtual void Install_Callback(GSocket *socket, GSocketEvent event);
-	virtual void Uninstall_Callback(GSocket *socket, GSocketEvent event);
-	virtual void Enable_Events(GSocket *socket);
-	virtual void Disable_Events(GSocket *socket);
-};
-
-
-#endif // AMULED28_SOCKETS
-
-// AppTrait functionality is required for 2.8 wx sockets
-// Otherwise it's used to prevent zombie child processes,
-// which stops working with wx 2.9.5.
-// So disable it there (no idea if this has a noticeable impact).
-
-#if !wxCHECK_VERSION(2, 9, 5) && !defined(__WINDOWS__)
-#define AMULED_APPTRAITS
-#endif
-
-#ifdef AMULED_APPTRAITS
-
-typedef std::map<int, class wxEndProcessData *> EndProcessDataMap;
-
-#include <wx/apptrait.h>
-
-class CDaemonAppTraits : public wxConsoleAppTraits
-{
-private:
-	struct sigaction m_oldSignalChildAction;
-	struct sigaction m_newSignalChildAction;
-
-#ifdef AMULED28_SOCKETS
-	CAmuledGSocketFuncTable *m_table;
-	wxMutex m_lock;
-	std::list<wxObject *> m_sched_delete;
-public:
-	CDaemonAppTraits(CAmuledGSocketFuncTable *table);
-	virtual GSocketGUIFunctionsTable* GetSocketGUIFunctionsTable();
-	virtual void ScheduleForDestroy(wxObject *object);
-	virtual void RemoveFromPendingDelete(wxObject *object);
-
-	void DeletePending();
-#else	// AMULED28_SOCKETS
-public:
-	CDaemonAppTraits();
-#endif	// !AMULED28_SOCKETS
-
-	virtual int WaitForChild(wxExecuteData& execData);
-
-#if defined(__WXMAC__) && !wxCHECK_VERSION(2, 9, 0)
-	virtual wxStandardPathsBase& GetStandardPaths();
-#endif
-};
-
-void OnSignalChildHandler(int signal, siginfo_t *siginfo, void *ucontext);
-pid_t AmuleWaitPid(pid_t pid, int *status, int options, wxString *msg);
-
-#endif // AMULED_APPTRAITS
-
 
 class CamuleDaemonApp : public CamuleApp
 {
 private:
-#ifdef AMULED28_EVENTLOOP
-	bool m_Exit;
-#endif
-#ifdef AMULED28_SOCKETS
-	CAmuledGSocketFuncTable *m_table;
-#endif
 	bool OnInit();
 	int OnRun();
 	int OnExit();
@@ -557,20 +451,7 @@ private:
 	// This function are overridden to perform this.
 	virtual bool Initialize(int& argc_, wxChar **argv_);
 
-#ifdef AMULED_APPTRAITS
-	struct sigaction m_oldSignalChildAction;
-	struct sigaction m_newSignalChildAction;
 public:
-	wxAppTraits *CreateTraits();
-#endif // AMULED_APPTRAITS
-
-public:
-
-#ifdef AMULED28_EVENTLOOP
-	CamuleDaemonApp();
-
-	void ExitMainLoop() { m_Exit = true; }
-#endif
 
 	bool CopyTextToClipboard(wxString strText);
 
--- a/src/amule-remote-gui.h
+++ b/src/amule-remote-gui.h
@@ -253,7 +253,7 @@ public:
 	}
 
 	//
-	// Following are like basicly same code as in webserver. Eventually it must
+	// Following are like basically same code as in webserver. Eventually it must
 	// be same class
 	//
 	void DoRequery(int cmd, int tag)
--- a/src/antiLeech_wx.h
+++ b/src/antiLeech_wx.h
@@ -23,10 +23,10 @@
 #define _istpunct(var)		iswpunct(var)
 #define _istspace(var)		iswspace(var)
 #define _istxdigit(var)		iswxdigit(var)
-//inline float _tstof(const wchar_t* str){
-//	wchar_t** ptail = NULL;
-//	return wcstof(str, ptail);
-//}
+inline float _tstof(const wchar_t* str){
+	wchar_t** ptail = NULL;
+	return wcstof(str, ptail);
+}
 //This function is not used. by Orzogc Lee
 //But I think there is no need to removing, linker will remove it.
 /*
--- a/src/BarShader.cpp
+++ b/src/BarShader.cpp
@@ -61,7 +61,7 @@ void CBarShader::SetHeight(unsigned heig
 	if( m_Height != height ) {
 		m_Height = height;
 
-		// Reset the modifers
+		// Reset the modifiers
 		if ( m_Modifiers ) {
 			delete[] m_Modifiers;
 			m_Modifiers = NULL;
@@ -90,7 +90,7 @@ void CBarShader::Set3dDepth(unsigned dep
 	if ( m_used3dlevel != depth ) {
 		m_used3dlevel = depth;
 
-		// Reset the modifers
+		// Reset the modifiers
 		if ( m_Modifiers ) {
 			delete[] m_Modifiers;
 			m_Modifiers = NULL;
--- a/src/BarShader.h
+++ b/src/BarShader.h
@@ -102,7 +102,7 @@ public:
 	 * @param colour The colour of the new span.
 	 *
 	 * Calling this function fill the specified range with the specified color.
-	 * Any spans completly or partially covered by the new span are either
+	 * Any spans completely or partially covered by the new span are either
 	 * removed or resized. If the value of end is larger than the current
 	 * filesize, the filesize is increased to the value of end.
 	 */
@@ -120,7 +120,7 @@ public:
 	}
 
 	/**
-	 * Draws the bar on the specifed wxDC.
+	 * Draws the bar on the specified wxDC.
 	 *
 	 * @param dc The wxDC upon which the bar should be drawn.
 	 * @param iLeft The left position from where to start drawing.
@@ -128,7 +128,7 @@ public:
 	 * @param bFlat 3D effect is not applied if this is true.
 	 *
 	 * This functions draws the bar with the height and width specified
-	 * through either the contructor or with SetWidth() and SetHeight().
+	 * through either the constructor or with SetWidth() and SetHeight().
 	 */
 	void Draw( wxDC* dc, int iLeft, int iTop, bool bFlat );
 
@@ -142,9 +142,9 @@ private:
 	unsigned	m_Width;
 	//! The height of the drawn bar
 	unsigned	m_Height;
-	//! The virtual filesize assosiated with the bar
+	//! The virtual filesize associated with the bar
 	uint64	m_FileSize;
-	//! Pointer to array of modifers used to create 3D effect. Size is (m_Height+1)/2 when set.
+	//! Pointer to array of modifiers used to create 3D effect. Size is (m_Height+1)/2 when set.
 	double*	m_Modifiers;
 	//! The current 3d level
 	uint16	m_used3dlevel;
--- a/src/BaseClient.cpp
+++ b/src/BaseClient.cpp
@@ -23,6 +23,11 @@
 // Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA
 //
 
+//Dynamic Leech Protect - Bill Lee
+#ifdef AMULE_DLP
+#include "DLP.h"
+#endif
+
 #include <wx/wx.h>
 #include <wx/mstream.h>
 #include <wx/tokenzr.h>
@@ -83,14 +88,8 @@
 #include "kademlia/kademlia/UDPFirewallTester.h"
 #include "kademlia/routing/RoutingZone.h"
 
-//Dynamic Leech Protect - Bill Lee
-#ifdef AMULE_DLP
-#include "DLP.h"
-#endif
-
 //#define __PACKET_DEBUG__
 
-
 // some client testing variables
 static wxString crash_name = wxT("[Invalid User Name]");
 static wxString empty_name = wxT("[Empty User Name]");
--- a/src/CatDialog.h
+++ b/src/CatDialog.h
@@ -39,7 +39,7 @@ class wxBitmap;
  * the user can add or change them.
  *
  * It is a self-contained entity, and does not rely on the categories staying
- * the same while the dialog is visble, though it will overwrite any changes
+ * the same while the dialog is visible, though it will overwrite any changes
  * made to the selected category in the mean time. Also, if the selected category
  * has been deleted then it will simply be readded.
  *
@@ -83,7 +83,7 @@ private:
 
 
 	/**
-	 * Event-handler for selecting incomming dir.
+	 * Event-handler for selecting incoming dir.
 	 */
 	void OnBnClickedBrowse(wxCommandEvent& evt);
 
--- a/src/CFile.cpp
+++ b/src/CFile.cpp
@@ -87,10 +87,6 @@ char* mktemp( char * path ) { return pat
 #	define   O_BINARY    (0)
 #endif  //__UNIX__
 
-#if defined(__WINDOWS__) && !wxCHECK_VERSION(3, 1, 0)
-#include <wx/msw/mslu.h>
-#endif
-
 
 // The following defines handle different names across platforms,
 // and ensures that we use 64b IO on windows (only 32b by default).
@@ -271,7 +267,7 @@ bool CFile::Open(const CPath& fileName,
 	m_fd = _wopen(m_filePath.GetRaw().c_str(), flags, accessMode);
 #else
 	Unicode2CharBuf tmpFileName = filename2char(m_filePath.GetRaw());
-	wxASSERT_MSG(tmpFileName, wxT("Convertion failed in CFile::Open"));
+	wxASSERT_MSG(tmpFileName, wxT("Conversion failed in CFile::Open"));
 	m_fd = open(tmpFileName, flags, accessMode);
 #endif
 	syscall_check(m_fd != fd_invalid, m_filePath, wxT("opening file"));
@@ -363,7 +359,10 @@ sint64 CFile::doWrite(const void* buffer
 
 sint64 CFile::doSeek(sint64 offset) const
 {
-	MULE_VALIDATE_STATE(IsOpened(), wxT("Cannot seek on closed file."));
+	if (!IsOpened()) {
+		throw CSeekFailureException(wxT("Cannot seek on closed file."));
+	}
+
 	MULE_VALIDATE_PARAMS(offset >= 0, wxT("Invalid position, must be positive."));
 
 	sint64 result = SEEK_FD(m_fd, offset, SEEK_SET);
--- a/src/CFile.h
+++ b/src/CFile.h
@@ -107,7 +107,7 @@ public:
 	void Reopen(OpenMode mode);
 
 	/**
-	 * Calling Create is equivilant of calling open with OpenMode 'write'.
+	 * Calling Create is equivalent of calling open with OpenMode 'write'.
 	 *
 	 * @param overwrite Specifies if the target file should be overwritten,
 	 *                  in case that it already exists.
@@ -127,7 +127,7 @@ public:
 
 
 	/**
-	 * Returns the file descriptior assosiated with the file.
+	 * Returns the file descriptor associated with the file.
 	 *
 	 * Note that direct manipulation of the descriptor should
 	 * be avoided! That's what this class is for.
--- a/src/ChatSelector.cpp
+++ b/src/ChatSelector.cpp
@@ -189,7 +189,7 @@ bool CChatSelector::ProcessMessage(uint6
 	bool newtab = !session;
 
 	if ( !session ) {
-		// This must be a mesage from a client that is not already chatting
+		// This must be a message from a client that is not already chatting
 		if (client_name.IsEmpty()) {
 			// Core did not send us the name.
 			// This must NOT happen.
@@ -310,7 +310,7 @@ void CChatSelector::EndSession(uint64 cl
 }
 
 
-// Refresh the tab assosiated with a client
+// Refresh the tab associated with a client
 void CChatSelector::RefreshFriend(uint64 toupdate_id, const wxString& new_name)
 {
 	wxASSERT( toupdate_id );
--- a/src/ChatSelector.h
+++ b/src/ChatSelector.h
@@ -55,7 +55,7 @@ public:
 	 *
 	 * If newline is false, then no newlines will be at the end of added text,
 	 * even if the passed string ends with newlines. Multiline strings are
-	 * broken into indivudual lines and each are timestamped with the same date.
+	 * broken into individual lines and each are timestamped with the same date.
 	 */
 	void AddText( const wxString& text, const wxTextAttr& style, bool newline = true );
 };
--- a/src/ChatWnd.h
+++ b/src/ChatWnd.h
@@ -61,22 +61,22 @@ protected:
 	 */
 	void	OnNMRclickChatTab(wxMouseEvent& evt);
 	/**
-	 * Event-handler fo the Close item on the popup-menu.
+	 * Event-handler of the Close item on the popup-menu.
 	 */
 	void	OnPopupClose(wxCommandEvent& evt);
 
 	/**
-	 * Event-handler fo the CloseAll item on the popup-menu.
+	 * Event-handler of the CloseAll item on the popup-menu.
 	 */
 	void	OnPopupCloseAll(wxCommandEvent& evt);
 
 	/**
-	 * Event-handler fo the CloseOthers item on the popup-menu.
+	 * Event-handler of the CloseOthers item on the popup-menu.
 	 */
 	void	OnPopupCloseOthers(wxCommandEvent& evt);
 
 	/**
-	 * Event-handler fo the AddFriend item on the popup-menu.
+	 * Event-handler of the AddFriend item on the popup-menu.
 	 */
 	void	OnAddFriend(wxCommandEvent& evt);
 
--- a/src/ClientCreditsList.cpp
+++ b/src/ClientCreditsList.cpp
@@ -184,7 +184,7 @@ void CClientCreditsList::SaveList()
 			uint32 count = 0;
 
 			file.WriteUInt8( CREDITFILE_VERSION );
-			// Temporary place-holder for number of stucts
+			// Temporary place-holder for number of structs
 			file.WriteUInt32( 0 );
 
 			ClientMap::iterator it = m_mapClients.begin();
@@ -392,7 +392,7 @@ bool CClientCreditsList::VerifyIdent(CCl
 		wxASSERT ( challenge != 0 );
 		PokeUInt32(abyBuffer+m_nMyPublicKeyLen, challenge);
 
-		// v2 security improvments (not supported by 29b, not used as default by 29c)
+		// v2 security improvements (not supported by 29b, not used as default by 29c)
 		uint8 nChIpSize = 0;
 		if (byChaIPKind != 0){
 			nChIpSize = 5;
--- a/src/ClientList.cpp
+++ b/src/ClientList.cpp
@@ -110,7 +110,7 @@ void CClientList::AddClient( CUpDownClie
 
 		//Notify_ClientCtrlAddClient( toadd );
 
-		// We always add the ID/ptr pair, regardles of the actual ID value
+		// We always add the ID/ptr pair, regardless of the actual ID value
 		m_clientList.insert( IDMapPair( toadd->GetUserIDHybrid(), CCLIENTREF(toadd, wxT("CClientList::AddClient m_clientList.insert"))) );
 
 		// We only add the IP if it is valid
@@ -976,7 +976,7 @@ void CClientList::CleanUpClientList()
 {
 	// We remove clients which are not needed any more by time
 	// this check is also done on CUpDownClient::Disconnected, however it will not catch all
-	// cases (if a client changes the state without beeing connected
+	// cases (if a client changes the state without being connected
 	//
 	// Adding this check directly to every point where any state changes would be more effective,
 	// is however not compatible with the current code, because there are points where a client has
--- a/src/ClientList.h
+++ b/src/ClientList.h
@@ -95,7 +95,7 @@ public:
 	 * Updates the recorded IP of the specified client.
 	 *
 	 * @param client The client to have its entry updated.
-	 * @param newIP The new IP adress of the client.
+	 * @param newIP The new IP address of the client.
 	 *
 	 * This function is to be called before the client actually changes its
 	 * IP-address, and will update the old entry with the new value. There
@@ -145,7 +145,7 @@ public:
 	 * Replaces a new client-instance with the an already existing client, if one such exist.
 	 *
 	 * @param client A pointer to the pointer of the new instance.
-	 * @param sender The socket assosiated with the new instance.
+	 * @param sender The socket associated with the new instance.
 	 *
 	 * Call this function when a new client-instance has been created. This function will then
 	 * compare it against all existing clients and see if we already have an instance matching
@@ -202,7 +202,7 @@ public:
 	 * Returns the number of tracked client.
 	 *
 	 * @param dwIP The IP-adress which of the clients.
-	 * @return The number of clients tracked at the specifed IP.
+	 * @return The number of clients tracked at the specified IP.
 	 */
 	uint16	GetClientsFromIP(uint32 dwIP);
 
@@ -211,7 +211,7 @@ public:
 	 *
 	 * @param dwIP The IP of the client.
 	 * @param nPort The port of the client.
-	 * @param pNewHash The userhash assosiated with the client.
+	 * @param pNewHash The userhash associated with the client.
 	 *
 	 */
 	bool	ComparePriorUserhash( uint32 dwIP, uint16 nPort, void* pNewHash );
--- a/src/ClientRef.cpp
+++ b/src/ClientRef.cpp
@@ -24,7 +24,7 @@
 //
 
 #include "ClientRef.h"
-#include "amule.h"				// Needed fot theApp
+#include "amule.h"				// Needed for theApp
 
 #ifdef CLIENT_GUI
 #include "UpDownClientEC.h"	// Needed for CUpDownClient
--- a/src/ClientTCPSocket.cpp
+++ b/src/ClientTCPSocket.cpp
@@ -34,7 +34,7 @@
 #include "Preferences.h"	// Needed for thePrefs
 #include "Packet.h"		// Needed for CPacket
 #include "Statistics.h"		// Needed for theStats
-#include "Logger.h"		// Neeed for logRemoteClient
+#include "Logger.h"		// Needed for logRemoteClient
 #include "updownclient.h"	// Needed for CUpDownClient
 #include <common/Format.h>	// Needed for CFormat
 #include "amule.h"		// Needed for theApp
@@ -260,7 +260,7 @@ void CClientTCPSocket::Disconnect(const
 	byConnected = ES_DISCONNECTED;
 	if (m_client) {
 		if (m_client->Disconnected(strReason, true)) {
-			// Somehow, Safe_Delete() is beeing called by Disconnected(),
+			// Somehow, Safe_Delete() is being called by Disconnected(),
 			// or any other function that sets m_client to NULL,
 			// so we must check m_client first.
 			if (m_client) {
@@ -340,7 +340,7 @@ bool CClientTCPSocket::ProcessPacket(con
 			theStats::AddDownOverheadOther(size);
 			bool bNewClient = !m_client;
 			if (bNewClient) {
-				// create new client to save standart informations
+				// create new client to save standard information
 				m_client = new CUpDownClient(this);
 			}
 
@@ -368,7 +368,7 @@ bool CClientTCPSocket::ProcessPacket(con
 					m_client->Safe_Delete();
 					m_client = NULL;
 				}
-				Disconnect(wxT("Paranoid disconecting: ") + reason);
+				Disconnect(wxT("Paranoid disconnecting: ") + reason);
 				return false;
 			}
 
@@ -389,14 +389,14 @@ bool CClientTCPSocket::ProcessPacket(con
 			// and the var. "client" will point to the known client.
 			// if not we keep our new-constructed client ;)
 			if (theApp->clientlist->AttachToAlreadyKnown(&m_client,this)) {
-				// update the old client informations
+				// update the old client information
 				bIsMuleHello = m_client->ProcessHelloPacket(buffer, size);
 			} else {
 				theApp->clientlist->AddClient(m_client);
 				m_client->SetCommentDirty();
 			}
 			Notify_SharedCtrlRefreshClient( m_client->ECID(), AVAILABLE_SOURCE );
-			// send a response packet with standart informations
+			// send a response packet with standard information
 			if ((m_client->GetHashType() == SO_EMULE) && !bIsMuleHello) {
 				m_client->SendMuleInfoPacket(false);
 			}
@@ -1023,7 +1023,7 @@ bool CClientTCPSocket::ProcessExtPacket(
 	DumpMem(buffer,size);
 	#endif
 
-	// 0.42e - except the catchs on mem exception and file exception
+	// 0.42e - except the catches on mem exception and file exception
 	if (!m_client) {
 		throw wxString(wxT("Unknown clients sends extended protocol packet"));
 	}
@@ -1934,7 +1934,7 @@ void CClientTCPSocket::OnError(int nErro
 		}
 	} else {
 		if (theLogger.IsEnabled(logClient) && nErrorCode != 107) {
-			// 0    -> No Error / Disconect
+			// 0    -> No Error / Disconnect
 			// 107  -> Transport endpoint is not connected
 			if (m_client) {
 				if (!m_client->GetUserName().IsEmpty()) {
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -77,17 +77,21 @@ if (BUILD_AMULECMD)
 	)
 
 	target_link_libraries (amulecmd
-		mulecommon
-		mulesocket
-		ec
+		PRIVATE mulecommon
+		PRIVATE mulesocket
+		PRIVATE ec
 	)
 
 	if (HAVE_BFD)
-		target_link_libraries (amulecmd ${LIBBFD})
+		target_link_libraries (amulecmd 
+			PRIVATE ${LIBBFD}
+		)
 	endif (HAVE_BFD)
 
 	if (HAVE_LIBREADLINE)
-		target_link_libraries (amulecmd ${READLINE_LIBRARIES})
+		target_link_libraries (amulecmd
+			PRIVATE ${READLINE_LIBRARIES}
+		)
 	endif()
 
 	install (TARGETS amulecmd
@@ -118,17 +122,17 @@ if (BUILD_DAEMON)
 	)
 
 	target_link_libraries (amuled
-		ec
-		muleappcommon
-		muleappcore
-		mulecommon
-		mulesocket
-		wxWidgets::NET
+		PRIVATE ec
+		PRIVATE muleappcommon
+		PRIVATE muleappcore
+		PRIVATE mulecommon
+		PRIVATE mulesocket
+		PRIVATE wxWidgets::NET
 	)
 
 	if (HAVE_BFD)
 		target_link_libraries (amuled
-			${LIBBFD}
+			PRIVATE ${LIBBFD}
 		)
 	endif()
 
@@ -162,7 +166,7 @@ if (BUILD_ED2K)
 
 	if (WIN32)
 		target_link_libraries (ed2k
-			shlwapi.lib
+			PRIVATE shlwapi.lib
 		)
 	endif()
 
@@ -189,33 +193,45 @@ if (BUILD_MONOLITHIC)
 	endif()
 
 	target_link_libraries (amule
-		ec
-		muleappcommon
-		muleappcore
-		muleappgui
-		mulecommon
-		mulesocket
-		$<$<VERSION_LESS:${wxWidgets_VERSION_STRING},3.1.2>:wxWidgets::ADV>
-		wxWidgets::NET
+		PRIVATE ec
+		PRIVATE muleappcommon
+		PRIVATE muleappcore
+		PRIVATE muleappgui
+		PRIVATE mulecommon
+		PRIVATE mulesocket
+		PRIVATE $<$<VERSION_LESS:${wxWidgets_VERSION_STRING},3.1.2>:wxWidgets::ADV>
+		PRIVATE wxWidgets::NET
 	)
 
 	if (HAVE_BFD)
-		target_link_libraries (amule ${LIBBFD})
+		target_link_libraries (amule
+			PRIVATE ${LIBBFD}
+		)
 	endif()
 
 	if (WIN32)
 		target_link_libraries (amule
-			shlwapi.lib
+			PRIVATE shlwapi.lib
 		)
 
-		set_target_properties (amule
-			PROPERTIES WIN32_EXECUTABLE TRUE
+		set_target_properties (amule PROPERTIES
+			WIN32_EXECUTABLE TRUE
 		)
 	endif()
 
 	install (TARGETS amule
 		RUNTIME DESTINATION bin
 	)
+
+	install (FILES aMule.xpm
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/pixmaps"
+		RENAME amule.xpm
+	)
+
+	install (FILES aMule.xpm
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/pixmaps"
+		RENAME amulegui.xpm
+	)
 endif (BUILD_MONOLITHIC)
 
 if (BUILD_REMOTEGUI)
@@ -241,24 +257,24 @@ if (BUILD_REMOTEGUI)
 	)
 
 	target_link_libraries (amulegui
-		ec
-		muleappcommon
-		muleappgui
-		mulecommon
-		mulesocket
-		$<$<VERSION_LESS:${wxWidgets_VERSION_STRING},3.1.2>:wxWidgets::ADV>
-		wxWidgets::NET
+		PRIVATE ec
+		PRIVATE muleappcommon
+		PRIVATE muleappgui
+		PRIVATE mulecommon
+		PRIVATE mulesocket
+		PRIVATE $<$<VERSION_LESS:${wxWidgets_VERSION_STRING},3.1.2>:wxWidgets::ADV>
+		PRIVATE wxWidgets::NET
 	)
 
 	if (HAVE_BFD)
 		target_link_libraries (amulegui
-			${LIBBFD}
+			PRIVATE ${LIBBFD}
 		)
 	endif()
 
 	if (WIN32)
-		set_target_properties (amulegui
-			PROPERTIES WIN32_EXECUTABLE TRUE
+		set_target_properties (amulegui PROPERTIES
+			WIN32_EXECUTABLE TRUE
 		)
 	endif()
 
@@ -289,6 +305,11 @@ if (NEED_LIB_MULEAPPCOMMON)
 		Timer.cpp
 	)
 
+	add_dependencies (muleappcommon
+		generate_ECCodes.h
+		generate_ECTagTypes.h
+	)
+
 	target_compile_definitions (muleappcommon
 		PRIVATE wxUSE_GUI=0
 		PRIVATE WXUSINGDLL
@@ -299,13 +320,11 @@ if (NEED_LIB_MULEAPPCOMMON)
 		PUBLIC ${EC_INCLUDE_DIR}
 		PRIVATE ${INCLUDE_INCLUDE_DIR}
 		PRIVATE ${LIBS_INCLUDE_DIR}
-		PRIVATE ${wxWidgets_INCLUDE_DIRS}
 		PRIVATE ${ZLIB_INCLUDE_DIR}
 	)
 
-	add_dependencies (muleappcommon
-		generate_ECCodes.h
-		generate_ECTagTypes.h
+	target_link_libraries(muleappcommon
+		PUBLIC wxWidgets::BASE
 	)
 
 	if (ENABLE_UPNP)
@@ -390,7 +409,6 @@ if (NEED_LIB_MULEAPPCORE)
 		PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}
 		PRIVATE ${INCLUDE_INCLUDE_DIR}
 		PRIVATE ${LIBS_INCLUDE_DIR}
-		PRIVATE ${wxWidgets_INCLUDE_DIRS}
 	)
 
 	if (ENABLE_UPNP)
@@ -400,7 +418,8 @@ if (NEED_LIB_MULEAPPCORE)
 	endif()
 
 	target_link_libraries (muleappcore
-		CRYPTOPP::CRYPTOPP
+		PUBLIC wxWidgets::BASE
+		PRIVATE CRYPTOPP::CRYPTOPP
 	)
 endif()
 
@@ -432,9 +451,9 @@ if (NEED_LIB_MULEAPPGUI)
 	)
 
 	target_include_directories (muleappgui
-		PRIVATE ${amule_BINARY_DIR}
-		PRIVATE ${INCLUDE_INCLUDE_DIR}
-		PRIVATE ${LIBS_INCLUDE_DIR}
+		PUBLIC ${amule_BINARY_DIR}
+		PUBLIC ${INCLUDE_INCLUDE_DIR}
+		PUBLIC ${LIBS_INCLUDE_DIR}
 	)
 
 	target_link_libraries (muleappgui
@@ -457,24 +476,19 @@ IF (NEED_LIB_MULESOCKET)
 	)
 	
 	target_include_directories (mulesocket
-		PRIVATE ${amule_BINARY_DIR}
+		PUBLIC ${amule_BINARY_DIR}
 		PUBLIC ${INCLUDE_INCLUDE_DIR}
 		PUBLIC ${LIBS_INCLUDE_DIR}
 	)
 
 	if (ENABLE_BOOST)
-		target_include_directories (mulesocket
-			PRIVATE ${Boost_INCLUDE_DIR}
-			PRIVATE ${wxWidgets_INCLUDE_DIRS}
-		)
-
 		target_link_libraries (mulesocket
-			${Boost_LIBRARIES}
-			wxWidgets::BASE
+			PRIVATE ${Boost_LIBRARIES}
+			PUBLIC wxWidgets::BASE
 		)
 	else()
 		target_link_libraries (mulesocket
-			wxWidgets::NET
+			PUBLIC wxWidgets::NET
 		)
 	endif()
 endif()
--- a/src/ColorFrameCtrl.cpp
+++ b/src/ColorFrameCtrl.cpp
@@ -61,7 +61,7 @@ END_EVENT_TABLE()
 /////////////////////////////////////////////////////////////////////////////
 void CColorFrameCtrl::SetFrameBrushColour(const wxColour& colour)
 {
-	m_brushFrame = *(wxTheBrushList->FindOrCreateBrush(colour, wxSOLID));
+	m_brushFrame = *(wxTheBrushList->FindOrCreateBrush(colour, wxBRUSHSTYLE_SOLID));
 
 	Refresh(FALSE);
 }  // SetFrameColor
@@ -70,7 +70,7 @@ void CColorFrameCtrl::SetFrameBrushColou
 /////////////////////////////////////////////////////////////////////////////
 void CColorFrameCtrl::SetBackgroundBrushColour(const wxColour& colour)
 {
-	m_brushBack = *(wxTheBrushList->FindOrCreateBrush(colour, wxSOLID));
+	m_brushBack = *(wxTheBrushList->FindOrCreateBrush(colour, wxBRUSHSTYLE_SOLID));
 
 	// clear out the existing garbage, re-start with a clean plot
 	Refresh(FALSE);
--- a/src/DeadSourceList.h
+++ b/src/DeadSourceList.h
@@ -39,9 +39,9 @@ class CUpDownClient;
  * This class keeps track of "invalid" sources.
  *
  * A dead source is a source that has been evaluated as being useles
- * which can be due to serveral reasons, such as not responding to
+ * which can be due to several reasons, such as not responding to
  * queries. This list then allows for those sources to be ignored
- * for an set ammount of time in order to avoid the overhead of
+ * for an set amount of time in order to avoid the overhead of
  * trying to connect to them.
  *
  * This is important, since these sources would be removed and readded
--- a/src/DirectoryTreeCtrl.cpp
+++ b/src/DirectoryTreeCtrl.cpp
@@ -114,7 +114,7 @@ void CDirectoryTreeCtrl::Init()
 		drives >>= 1;
 		for (char drive = 'C'; drive <= 'Z'; drive++) {
 			drives >>= 1;
-			if (! (drives & 1)) { // skip non existant drives
+			if (! (drives & 1)) { // skip non existent drives
 				continue;
 			}
 			wxString driveStr = CFormat(wxT("%c:")) % drive;
--- a/src/DLP.cpp
+++ b/src/DLP.cpp
@@ -16,15 +16,14 @@
 //
 #include "Logger.h"
 
+#include "DLP.h"
+#include "antiLeech.h"
 #include <wx/dynlib.h>                          /* Needed for wxDynamicLibrary */
 
+#include "DLPPref.h"
 #include "Preferences.h"	// Needed for CPreferences
 #include "amule.h"		// Needed for theApp
 
-#include "DLP.h"
-#include "antiLeech.h"
-#include "DLPPref.h"
-
 #include <wx/stdpaths.h>                        /* Needed for wxStandardPaths */
 
 #define PRE_CHECK(tag)	if( (!c->IsBanned()) && antiLeech && (thePrefs::GetDLPCheckMask() & tagn) )
@@ -63,7 +62,6 @@ bool DLP::DLPCheck(CUpDownClient* c){
 	CString clientver(c->GetClientVerString());
 	CString uname(c->GetUserName());
 	CString uhash(wxString(c->GetUserHash().EncodeSTL().c_str(), wxConvUTF8));
-	CString fullip(Uint32_16toStringIP_Port(c->GetConnectIP(),c->GetUserPort()));
 	
 	//CheckGhostMod
 	if(prefs & PF_GHOSTMOD) {
@@ -99,16 +97,11 @@ bool DLP::DLPCheck(CUpDownClient* c){
 			tmp = ret.c_str();
 		}
 	}
-
-	if (c->HasLowID() && (tmp == NULL)) {
-		ret = _("Ban Low ID");
-		tmp = ret.c_str();
-	}
-
+	
 	if (tmp != NULL) {
 		ret = tmp;
 		wxString wxInfo;
-		wxInfo.Printf(wxT("_%s_%s_%s_%s_%s"), uhash.c_str(), ret.c_str(), fullip.c_str(), clientver.c_str(), uname.c_str());
+		wxInfo.Printf(wxT("[%s] %s"), ret.c_str(), c->GetClientFullInfo().c_str());
 		c->Ban();
 		theApp->AddDLPMessageLine(wxInfo);
 		return true;
--- a/src/DownloadClient.cpp
+++ b/src/DownloadClient.cpp
@@ -902,7 +902,7 @@ void CUpDownClient::ProcessBlockPacket(c
 				// Found reserved block
 
 				if (cur_block->block->StartOffset == nStartPos) {
-					// This block just started transfering. Set the start time.
+					// This block just started transferring. Set the start time.
 					m_last_block_start = ::GetTickCountFullRes();
 				}
 
@@ -1155,7 +1155,7 @@ int CUpDownClient::unzip(Pending_Block_S
 
 
 // Speed is now updated only when data was received, calculated as
-// (data received) / (time since last receiption)
+// (data received) / (time since last reception)
 // and slightly filtered (10s average).
 // Result is quite precise now and makes the DownloadRateAdjust workaround obsolete.
 
@@ -1403,7 +1403,7 @@ uint8 CUpDownClient::GetObfuscationStatu
 	return ret;
 }
 
-// IgnoreNoNeeded = will switch to files of which this source has no needed parts (if no better fiels found)
+// IgnoreNoNeeded = will switch to files of which this source has no needed parts (if no better files found)
 // ignoreSuspensions = ignore timelimit for A4Af jumping
 // bRemoveCompletely = do not readd the file which the source is swapped from to the A4AF lists (needed if deleting or stopping a file)
 // toFile = Try to swap to this partfile only
@@ -1480,7 +1480,7 @@ bool CUpDownClient::SwapToAnotherFile(bo
 
 			m_reqfile->RemoveDownloadingSource( this );
 
-			// Do we want to remove it completly? Say if the old file is getting deleted
+			// Do we want to remove it completely? Say if the old file is getting deleted
 			if ( !bRemoveCompletely ) {
 				m_reqfile->AddA4AFSource( this );
 
@@ -1624,7 +1624,7 @@ void CUpDownClient::ProcessAICHAnswer(co
 			 && ahMasterHash == pPartFile->GetAICHHashset()->GetMasterHash())
 		{
 			if(pPartFile->GetAICHHashset()->ReadRecoveryData(request.m_nPart*PARTSIZE, &data)){
-				// finally all checks passed, everythings seem to be fine
+				// finally all checks passed, everything seems to be fine
 				AddDebugLogLineN(logAICHTransfer, wxT("AICH Packet Answer: Succeeded to read and validate received recoverydata"));
 				CAICHHashSet::RemoveClientAICHRequest(this);
 				pPartFile->AICHRecoveryDataAvailable(request.m_nPart);
@@ -1666,7 +1666,7 @@ void CUpDownClient::ProcessAICHRequest(c
 			pKnownFile->GetAICHHashset()->GetMasterHash().Write(&fileResponse);
 			if (pKnownFile->GetAICHHashset()->CreatePartRecoveryData(nPart*PARTSIZE, &fileResponse)){
 				AddDebugLogLineN(logAICHTransfer,
-					CFormat(wxT("AICH Packet Request: Sucessfully created and send recoverydata for '%s' to %s"))
+					CFormat(wxT("AICH Packet Request: Successfully created and send recoverydata for '%s' to %s"))
 						% pKnownFile->GetFileName() % GetClientFullInfo());
 
 				CPacket* packAnswer = new CPacket(fileResponse, OP_EMULEPROT, OP_AICHANSWER);
--- a/src/DownloadListCtrl.cpp
+++ b/src/DownloadListCtrl.cpp
@@ -221,7 +221,7 @@ void CDownloadListCtrl::RemoveFile( CPar
 	// Ensure that any list-entries are removed
 	ShowFile( file, false );
 
-	// Find the assosiated list-item
+	// Find the associated list-item
 	ListItems::iterator it = m_ListItems.find( file );
 
 	if ( it != m_ListItems.end() ) {
@@ -850,7 +850,7 @@ void CDownloadListCtrl::OnDrawItem(
 		dc->SetTextForeground(wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHTTEXT));
 		dc->SetPen( colour.Blend(65).GetPen() );
 	} else {
-		dc->SetBackground(*(wxTheBrushList->FindOrCreateBrush(wxSystemSettings::GetColour(wxSYS_COLOUR_LISTBOX), wxSOLID)));
+		dc->SetBackground(*(wxTheBrushList->FindOrCreateBrush(wxSystemSettings::GetColour(wxSYS_COLOUR_LISTBOX), wxBRUSHSTYLE_SOLID)));
 		dc->SetTextForeground(wxSystemSettings::GetColour(wxSYS_COLOUR_WINDOWTEXT));
 		dc->SetPen(*wxTRANSPARENT_PEN);
 	}
@@ -1132,7 +1132,7 @@ int CDownloadListCtrl::SortProc(wxUIntPt
 	int sortMod = (sortData & CMuleListCtrl::SORT_DES) ? -1 : 1;
 	sortData &= CMuleListCtrl::COLUMN_MASK;
 
-	// We modify the result so that it matches with ascending or decending
+	// We modify the result so that it matches with ascending or descending
 	return sortMod * Compare( item1->GetFile(), item2->GetFile(), sortData);
 }
 
@@ -1413,7 +1413,7 @@ void CDownloadListCtrl::DrawFileStatusBa
 		dc->DrawLine( rect.x, rect.y + 2, rect.x + width, rect.y + 2 );
 
 		// Draw the green line
-		dc->SetPen( *(wxThePenList->FindOrCreatePen( crProgress , 1, wxSOLID ) ));
+		dc->SetPen( *(wxThePenList->FindOrCreatePen( crProgress , 1, wxPENSTYLE_SOLID ) ));
 		dc->DrawLine( rect.x, rect.y + 1, rect.x + width, rect.y + 1 );
 	}
 }
--- a/src/DownloadListCtrl.h
+++ b/src/DownloadListCtrl.h
@@ -86,7 +86,7 @@ public:
 	 *
 	 * @param file A valid pointer of the file to be removed.
 	 *
-	 * This function also removes any sources assosiated with the file.
+	 * This function also removes any sources associated with the file.
 	 */
 	void RemoveFile( CPartFile* file );
 
--- a/src/DownloadQueue.h
+++ b/src/DownloadQueue.h
@@ -28,7 +28,7 @@
 
 #include "MD4Hash.h"		// Needed for CMD4Hash
 #include "ObservableQueue.h"	// Needed for CObservableQueue
-#include "GetTickCount.h"	// Needed fot GetTickCount
+#include "GetTickCount.h"	// Needed for GetTickCount
 
 
 #include <deque>
@@ -168,7 +168,7 @@ public:
 	/**
 	 * This function adds already known source to the specified file.
 	 *
-	 * @param sender The owner fo the new source.
+	 * @param sender The owner of the new source.
 	 * @param source The client in question.
 	 *
 	 * This function acts like CheckAndAddSource, with the exception that no
@@ -179,7 +179,7 @@ public:
 
 
 	/**
-	 * Removes the specified client completly.
+	 * Removes the specified client completely.
 	 *
 	 * @param toremove The client to be removed.
 	 * @param updatewindow NOT USED!
@@ -346,7 +346,7 @@ private:
 
 	void	AddToResolve(const CMD4Hash& fileid, const wxString& pszHostname, uint16 port, const wxString& hash, uint8 cryptoptions);
 
-	//! The mutex assosiated with this class, mutable to allow for const functions.
+	//! The mutex associated with this class, mutable to allow for const functions.
 	mutable wxMutex m_mutex;
 
 
--- a/src/EMSocket.cpp
+++ b/src/EMSocket.cpp
@@ -662,7 +662,7 @@ uint32 CEMSocket::GetNeededBytes()
 		}
 
 		if (!((sendbuffer && !m_currentPacket_is_controlpacket) || !m_standard_queue.empty())) {
-			// No standard packet to send. Even if data needs to be sent to prevent timout, there's nothing to send.
+			// No standard packet to send. Even if data needs to be sent to prevent timeout, there's nothing to send.
 			return 0;
 		}
 
--- a/src/EncryptedStreamSocket.cpp
+++ b/src/EncryptedStreamSocket.cpp
@@ -51,7 +51,7 @@
 			  would be used and RC4 would create the same output. Since the key is a MD5 hash it doesn't weaken the key if that part is known
 			- Why DH-KeyAgreement isn't used as basic obfuscation key: It doesn't offer substantial more protection against passive connection based protocol identification, it has about 200 bytes more overhead,
 			  needs more CPU time, we cannot say if the received data is junk, unencrypted or part of the keyagreement before the handshake is finished without losing the complete randomness,
-			  it doesn't offer substantial protection against eavesdropping without added authentification
+			  it doesn't offer substantial protection against eavesdropping without added authentication
 
 Basic Obfuscated Handshake Protocol Client <-> Server:
 	- RC4 Keycreation:
@@ -506,7 +506,7 @@ int CEncryptedStreamSocket::Negotiate(co
 						m_nReceiveBytesWanted = 3;
 					} else {
 						//printf("Wrong magic value: 0x%x != 0x%x on %s\n",dwValue, MAGICVALUE_SYNC, (const char*)unicode2char(GetPeer()));
-						//DebugLogError(_T("CEncryptedStreamSocket: Received wrong magic value from clientIP %s on a supposly encrytped stream / Wrong Header"), GetPeer());
+						//DebugLogError(_T("CEncryptedStreamSocket: Received wrong magic value from clientIP %s on a supposly encrypted stream / Wrong Header"), GetPeer());
 						OnError(ERR_ENCRYPTION);
 						return (-1);
 					}
@@ -522,7 +522,7 @@ int CEncryptedStreamSocket::Negotiate(co
 
 					if (m_dbgbyEncryptionRequested != ENM_OBFUSCATION) {
 						//printf("Unsupported encryption method!\n");
-//						AddDebugLogLine(DLP_LOW, false, _T("CEncryptedStreamSocket: Client %s preffered unsupported encryption method (%i)"), GetPeer(), m_dbgbyEncryptionRequested);
+//						AddDebugLogLine(DLP_LOW, false, _T("CEncryptedStreamSocket: Client %s preferred unsupported encryption method (%i)"), GetPeer(), m_dbgbyEncryptionRequested);
 					}
 
 					m_nReceiveBytesWanted = m_pfiReceiveBuffer.ReadUInt8();
@@ -632,7 +632,7 @@ int CEncryptedStreamSocket::Negotiate(co
 					m_dbgbyEncryptionSupported = m_pfiReceiveBuffer.ReadUInt8();
 					m_dbgbyEncryptionRequested = m_pfiReceiveBuffer.ReadUInt8();
 					if (m_dbgbyEncryptionRequested != ENM_OBFUSCATION) {
-	//					AddDebugLogLine(DLP_LOW, false, _T("CEncryptedStreamSocket: Server %s preffered unsupported encryption method (%i)"), GetPeer(), m_dbgbyEncryptionRequested);
+	//					AddDebugLogLine(DLP_LOW, false, _T("CEncryptedStreamSocket: Server %s preferred unsupported encryption method (%i)"), GetPeer(), m_dbgbyEncryptionRequested);
 					}
 					m_nReceiveBytesWanted = m_pfiReceiveBuffer.ReadUInt8();
 					m_NegotiatingState = ONS_BASIC_SERVER_PADDING;
--- a/src/extern/wxWidgets/listctrl.cpp
+++ b/src/extern/wxWidgets/listctrl.cpp
@@ -40,14 +40,6 @@
 #include <wx/renderer.h>
 #include <wx/dcbuffer.h>
 
-#if wxCHECK_VERSION(2, 9, 0)
-// wxWidgets 2.9+ does not include a mac/private anymore.
-#else
-	#if defined( __WXMAC__ ) && !defined(__WXUNIVERSAL__) && (wxOSX_USE_CARBON || TARGET_CARBON)
-		#include <wx/mac/private.h>
-	#endif
-#endif
-
 
 // NOTE: If using the wxListBox visual attributes works everywhere then this can
 // be removed, as well as the #else case below.
@@ -1453,7 +1445,7 @@ bool wxListLineData::SetAttributes(wxDC
         if ( highlighted )
             dc->SetBrush( m_owner->GetHighlightBrush() );
         else
-            dc->SetBrush(*(wxTheBrushList->FindOrCreateBrush(attr->GetBackgroundColour(), wxSOLID)));
+            dc->SetBrush(*(wxTheBrushList->FindOrCreateBrush(attr->GetBackgroundColour(), wxBRUSHSTYLE_SOLID)));
 
         dc->SetPen( *wxTRANSPARENT_PEN );
 
@@ -2325,7 +2317,7 @@ wxListMainWindow::wxListMainWindow( wxWi
                             (
                                 wxSYS_COLOUR_HIGHLIGHT
                             ),
-                            wxSOLID
+                            wxBRUSHSTYLE_SOLID
                          ));
 
     m_highlightUnfocusedBrush = *(wxTheBrushList->FindOrCreateBrush(
@@ -2333,7 +2325,7 @@ wxListMainWindow::wxListMainWindow( wxWi
                                  (
                                      wxSYS_COLOUR_BTNSHADOW
                                  ),
-                                 wxSOLID
+                                 wxBRUSHSTYLE_SOLID
                               ));
 
     SetScrollbars( 0, 0, 0, 0, 0, 0 );
@@ -2554,7 +2546,7 @@ void wxListMainWindow::HighlightLines( s
         if ( !m_selStore.SelectRange(lineFrom, lineTo, highlight,
                                      &linesChanged) )
         {
-            // meny items changed state, refresh everything
+            // many items changed state, refresh everything
             RefreshLines(lineFrom, lineTo);
         }
         else // only a few items changed state, refresh only them
@@ -2734,7 +2726,7 @@ void wxListMainWindow::OnPaint( wxPaintE
 
     // Ensure an uniform background color, as to avoid differences between
     // the automatically cleared parts and the rest of the canvas.
-    dc.SetBackground(*(wxTheBrushList->FindOrCreateBrush(wxSystemSettings::GetColour(wxSYS_COLOUR_LISTBOX), wxSOLID)));
+    dc.SetBackground(*(wxTheBrushList->FindOrCreateBrush(wxSystemSettings::GetColour(wxSYS_COLOUR_LISTBOX), wxBRUSHSTYLE_SOLID)));
 
     // We need to clear the DC manually, since we intercept BG-erase events.
     // Clearing must be done first thing because caching of the double-buffering causes artifacts otherwise.
@@ -2805,7 +2797,7 @@ void wxListMainWindow::OnPaint( wxPaintE
 
         if ( HasFlag(wxLC_HRULES) )
         {
-            wxPen pen = *(wxThePenList->FindOrCreatePen(GetRuleColour(), 1, wxSOLID));
+            wxPen pen = *(wxThePenList->FindOrCreatePen(GetRuleColour(), 1, wxPENSTYLE_SOLID));
             wxSize clientSize = GetClientSize();
 
             size_t i = visibleFrom;
@@ -2831,7 +2823,7 @@ void wxListMainWindow::OnPaint( wxPaintE
         // Draw vertical rules if required
         if ( HasFlag(wxLC_VRULES) && !IsEmpty() )
         {
-            wxPen pen = *(wxThePenList->FindOrCreatePen(GetRuleColour(), 1, wxSOLID));
+            wxPen pen = *(wxThePenList->FindOrCreatePen(GetRuleColour(), 1, wxPENSTYLE_SOLID));
             wxRect firstItemRect, lastItemRect;
 
             GetItemRect(visibleFrom, firstItemRect);
@@ -3930,8 +3922,8 @@ void wxListMainWindow::SetItemStateAll(l
 
     if ( HasCurrent() && (state == 0) && (stateMask & wxLIST_STATE_FOCUSED) )
     {
-        // unfocus all: only one item can be focussed, so clearing focus for
-        // all items is simply clearing focus of the focussed item.
+        // unfocus all: only one item can be focused, so clearing focus for
+        // all items is simply clearing focus of the focused item.
         SetItemState(m_current, state, stateMask);
     }
     //(setting focus to all items makes no sense, so it is not handled here.)
@@ -4093,7 +4085,7 @@ int wxListMainWindow::GetSelectedItemCou
     if ( IsSingleSel() )
         return HasCurrent() ? IsHighlighted(m_current) : false;
 
-    // virtual controls remmebers all its selections itself
+    // virtual controls remembers all its selections itself
     if ( IsVirtual() )
         return m_selStore.GetSelectedCount();
 
@@ -4859,12 +4851,15 @@ void wxListMainWindow::SortItems( MuleLi
 
 void wxListMainWindow::OnScroll(wxScrollWinEvent& event)
 {
+      // wxScrolledWindows::OnScroll is deprecated in wx 3.0.0 and it does not exist anymore in 3.1.0.
+    // Please also notice that call to
+    // - wxScrolledWindow::OnScroll
+    // - HandleOnScroll
+    // have been removed in code present in
+    // src/generic/listctrl.cpp, wxListMainWindow::OnScroll
+    // of wxWidgets 3.0
     // FIXME
-#if ( defined(__WXGTK__) || defined(__WXMAC__) ) && !defined(__WXUNIVERSAL__)
-    wxScrolledWindow::OnScroll(event);
-#else
     HandleOnScroll( event );
-#endif
 
     // update our idea of which lines are shown when we redraw the window the
     // next time
--- a/src/extern/wxWidgets/listctrl.h
+++ b/src/extern/wxWidgets/listctrl.h
@@ -16,7 +16,6 @@
 #include <wx/textctrl.h>
 
 #define wxLC_OWNERDRAW 0x10000
-#define WXWIN_COMPATIBILITY_2_8 1
 
 #include <wx/imaglist.h>
 
@@ -94,7 +93,7 @@ public:
 #endif // wxABI 2.8.4+
 
 // It is not certain that sizeof(long) == sizeof(void*), and since we
-// just about only use pointers as item-data, I've choosen to disable
+// just about only use pointers as item-data, I've chosen to disable
 // this function to prevent mistakes. Use SetItemPtrData instead.
 #if 0
     bool SetItemData(long item, long data);
--- a/src/ExternalConnector.cpp
+++ b/src/ExternalConnector.cpp
@@ -665,31 +665,6 @@ wxString CaMuleExternalConnector::SetLoc
 	return m_locale == NULL ? wxString() : m_locale->GetCanonicalName();
 }
 
-#if !wxUSE_GUI && defined(__WXMAC__) && !wxCHECK_VERSION(2, 9, 0)
-
-#include <wx/apptrait.h> // Do_not_auto_remove
-#include <wx/stdpaths.h> // Do_not_auto_remove
-
-class CaMuleExternalConnectorTraits : public wxConsoleAppTraits
-{
-public:
-	virtual wxStandardPathsBase& GetStandardPaths()
-	{
-		return s_stdPaths;
-	}
-
-private:
-	static wxStandardPathsCF s_stdPaths;
-};
-
-wxStandardPathsCF CaMuleExternalConnectorTraits::s_stdPaths;
-
-wxAppTraits* CaMuleExternalConnector::CreateTraits()
-{
-	return new CaMuleExternalConnectorTraits;
-}
-
-#endif
 
 #if wxUSE_ON_FATAL_EXCEPTION
 // Gracefully handle fatal exceptions and print backtrace if possible
--- a/src/ExternalConnector.h
+++ b/src/ExternalConnector.h
@@ -179,9 +179,6 @@ protected:
 	CCommandTree	m_commands;
 	const char *	m_appname;
 
-#if !wxUSE_GUI && defined(__WXMAC__) && !wxCHECK_VERSION(2, 9, 0)
-	virtual wxAppTraits* CreateTraits();
-#endif
 
 private:
 	wxString	m_configFileName;
--- a/src/FileArea.cpp
+++ b/src/FileArea.cpp
@@ -140,7 +140,7 @@ void CFileAreaSigHandler::Init()
 		return;
 
 	// Set our new signal handler.
-	// Note that we safe old handlers (propably wx ones) in order
+	// Note that we safe old handlers (probably wx ones) in order
 	// to be able to call them if signal not handled as desired.
 	// These handler will be removed by wx code when wx will restore
 	// old ones
--- a/src/FileArea.h
+++ b/src/FileArea.h
@@ -75,7 +75,7 @@ public:
 	bool FlushAt(CFileAutoClose& file, uint64 offset, size_t count);
 
 	/**
-	 * Get buffer that contains data readed or to write.
+	 * Get buffer that contains data read or to write.
 	 * @return allocated buffer or NULL if not initialized
 	 */
 	uint8_t *GetBuffer() const { return m_buffer; };
--- a/src/FileAutoClose.h
+++ b/src/FileAutoClose.h
@@ -70,7 +70,7 @@ public:
 	bool Open(const CPath& path, CFile::OpenMode mode = CFile::read);
 
 	/**
-	 * Calling Create is equivilant of calling open with OpenMode 'write'.
+	 * Calling Create is equivalent of calling open with OpenMode 'write'.
 	 *
 	 * @param overwrite Specifies if the target file should be overwritten,
 	 *                  in case that it already exists.
@@ -140,7 +140,7 @@ public:
 	bool Eof();
 
 	/**
-	 * Returns the file descriptior assosiated with the file.
+	 * Returns the file descriptor associated with the file.
 	 *
 	 * This breaks the purpose of this class of course.
 	 * Therefore the AutoClose mechanism is disabled when fd() is called.
--- a/src/FileDetailListCtrl.cpp
+++ b/src/FileDetailListCtrl.cpp
@@ -65,7 +65,7 @@ int CFileDetailListCtrl::SortProc(wxUInt
 
 void CFileDetailListCtrl::OnSelect(wxListEvent& event)
 {
-	// Damn wxLC_SINGLE_SEL does not work! So we have to care for single selection ourselfs:
+	// Damn wxLC_SINGLE_SEL does not work! So we have to care for single selection ourselves:
 	long realpos = event.m_itemIndex;
 	long pos = -1;
 	do {
--- a/src/FileLock.h
+++ b/src/FileLock.h
@@ -106,10 +106,10 @@ private:
 	}
 
 
-	//! Desriptor of the file being locked.
+	//! Descriptor of the file being locked.
 	HANDLE hd;
 
-	//! Specifies if the file-lock was aquired.
+	//! Specifies if the file-lock was acquired.
 	bool m_ok;
 #else
 		: m_fd(-1),
@@ -166,7 +166,7 @@ private:
 	//! Desribtor of the file being locked.
 	int m_fd;
 
-	//! Specifies if the file-lock was aquired.
+	//! Specifies if the file-lock was acquired.
 	bool m_ok;
 #endif
 };
--- a/src/GapList.cpp
+++ b/src/GapList.cpp
@@ -152,7 +152,7 @@ void CGapList::FillGap(uint64 partstart,
 
 		if (curGapStart >= partstart) {
 			if (curGapEnd <= partend) {
-				// our part fills this gap completly
+				// our part fills this gap completely
 				m_gaplist.erase(it2);
 			} else if (curGapStart <= partend) {
 				// lower part of this gap is in the part - shrink gap:
--- a/src/GenericClientListCtrl.cpp
+++ b/src/GenericClientListCtrl.cpp
@@ -457,7 +457,7 @@ void CGenericClientListCtrl::ShowSources
  * Helper-function: This function is used to gather selected items.
  *
  * @param list A pointer to the list to gather items from.
- * @return A list containing the selected items of the choosen types.
+ * @return A list containing the selected items of the chosen types.
  */
 static ItemList GetSelectedItems( CGenericClientListCtrl* list )
 {
@@ -660,7 +660,7 @@ void CGenericClientListCtrl::OnDrawItem(
 		dc->SetTextForeground(wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHTTEXT));
 		dc->SetPen( colour.Blend(65).GetPen() );
 	} else {
-		dc->SetBackground(*(wxTheBrushList->FindOrCreateBrush(wxSystemSettings::GetColour(wxSYS_COLOUR_LISTBOX), wxSOLID)));
+		dc->SetBackground(*(wxTheBrushList->FindOrCreateBrush(wxSystemSettings::GetColour(wxSYS_COLOUR_LISTBOX), wxBRUSHSTYLE_SOLID)));
 		dc->SetTextForeground(wxSystemSettings::GetColour(wxSYS_COLOUR_WINDOWTEXT));
 		dc->SetPen(*wxTRANSPARENT_PEN);
 	}
@@ -1113,8 +1113,8 @@ int CGenericClientListCtrl::SortProc(wxU
 	sortData &= CMuleListCtrl::COLUMN_MASK;
 	int comp = 0;
 
-	// Two sources, some different possibilites
-	// Avilable sources first, if we have both an
+	// Two sources, some different possibilities
+	// Available sources first, if we have both an
 	// available and an unavailable
 	comp = ( item2->GetType() - item1->GetType() );
 
@@ -1125,7 +1125,7 @@ int CGenericClientListCtrl::SortProc(wxU
 		comp = Compare(item1->GetSource(), item2->GetSource(), sortData);
 	}
 
-	// We modify the result so that it matches with ascending or decending
+	// We modify the result so that it matches with ascending or descending
 	return sortMod * comp;
 }
 
--- a/src/GenericClientListCtrl.h
+++ b/src/GenericClientListCtrl.h
@@ -158,7 +158,7 @@ protected:
 private:
 	/**
      *
-	 * Must be overriden by the derived class and return the dialog where this list is.
+	 * Must be overridden by the derived class and return the dialog where this list is.
      * @see CamuleDlg::DialogType
 	 *
      */
--- a/src/GuiEvents.h
+++ b/src/GuiEvents.h
@@ -50,7 +50,7 @@ DECLARE_LOCAL_EVENT_TYPE(MULE_EVT_NOTIFY
 
 /**
  * This namespaces contains a number of functions and classes
- * related to defered function calls, allowing a notification
+ * related to deferred function calls, allowing a notification
  * call to be delayed till it can be initiated from the main
  * thread.
  */
@@ -386,7 +386,7 @@ namespace MuleNotify
 	/**
 	 * This function will execute or queue a given notification functor.
 	 *
-	 * If the caller is the main thread, the functor is executed immediatly,
+	 * If the caller is the main thread, the functor is executed immediately,
 	 * thus acting like a regular function call. OTOH, if the caller is a
 	 * worker thread, the functor is cloned and sent via an event to
 	 * wxTheApp.
@@ -396,7 +396,7 @@ namespace MuleNotify
 	/**
 	 * These functions take a function pointer and a set of arguments,
 	 * matching those of the function-pointer. A functor is created
-	 * from these and either executed immediatly, or sent as an event
+	 * from these and either executed immediately, or sent as an event
 	 * in the case of non-main threads calling the functions.
 	 *
 	 * Note that the return-value of the function must be void.
--- a/src/HTTPDownload.cpp
+++ b/src/HTTPDownload.cpp
@@ -273,14 +273,14 @@ CMuleThread::ExitCode CHTTPDownloadThrea
 
 		if (current_read == 0) {
 			if (download_size == -1) {
-				// Download was probably succesful.
+				// Download was probably successful.
 				AddLogLineN(CFormat(_("Downloaded %d bytes")) % total_read);
 				m_result = HTTP_Success;
 			} else if (total_read != download_size) {
 				m_result = HTTP_Error;
 				throw wxString(CFormat(_("Expected %d bytes, but downloaded %d bytes")) % download_size % total_read);
 			} else {
-				// Download was succesful.
+				// Download was successful.
 				m_result = HTTP_Success;
 			}
 		}
@@ -346,7 +346,7 @@ wxInputStream* CHTTPDownloadThread::GetI
 	// Remove the "http://"
 	wxString host = location.Right(location.Len() - 7); // strlen("http://") -> 7
 
-	// I belive this is a bug...
+	// I believe this is a bug...
 	// Sometimes "Location" header looks like this:
 	// "http://www.whatever.com:8080http://www.whatever.com/downloads/something.zip"
 	// So let's clean it...
--- a/src/include/protocol/ed2k/Constants.h
+++ b/src/include/protocol/ed2k/Constants.h
@@ -31,7 +31,7 @@
 // MOD Note: Do not change this part - Merkur
 
 // Timeouts & Reask times
-#define	CONNECTION_TIMEOUT			40000	// set this lower if you want less connections at once, set  it higher if you have enough sockets (edonkey has its own timout too, so a very high value won't effect this)
+#define	CONNECTION_TIMEOUT			40000	// set this lower if you want less connections at once, set  it higher if you have enough sockets (edonkey has its own timeout too, so a very high value won't effect this)
 #define	FILEREASKTIME				1300000	// 1300000 <- original value ***
 #define	SERVERREASKTIME				800000  // don't set this too low, it wont speed up anything, but it could kill amule or your internetconnection
 #define	UDPSERVERREASKTIME			1300000	// 1300000 <- original value ***
@@ -67,7 +67,7 @@
 #define	MIN_REQUESTTIME				590000
 #define	MAX_PURGEQUEUETIME			HR2MS(1)
 #define	PURGESOURCESWAPSTOP			MIN2MS(15)	// How long forbid swapping a source to a certain file (NNP,...)
-#define	CONNECTION_LATENCY			22050	// latency for responces
+#define	CONNECTION_LATENCY			22050	// latency for responses
 #define	CLIENTBANTIME				HR2MS(2) // 2h
 #define	TRACKED_CLEANUP_TIME			HR2MS(1)
 #define	KEEPTRACK_TIME				HR2MS(2) // how long to keep track of clients which were once in the uploadqueue
--- a/src/IPFilter.cpp
+++ b/src/IPFilter.cpp
@@ -240,7 +240,7 @@ private:
 	 * @param IPstart The start of the IP-range.
 	 * @param IPend The end of the IP-range, must be less than or equal to IPstart.
 	 * @param AccessLevel The AccessLevel of this range.
-	 * @param Description The assosiated description of this range.
+	 * @param Description The associated description of this range.
 	 * @return true if the range was added, false if it was discarded.
 	 *
 	 * This function inserts the specified range into the IPMap. Invalid
@@ -388,7 +388,7 @@ CIPFilter::CIPFilter() :
 		<< wxT("# This file is used to store ipfilter-ranges that should\n")
 		<< wxT("# not be overwritten by aMule. If you wish to keep a custom\n")
 		<< wxT("# set of ipfilter-ranges that take precedence over ipfilter-\n")
-		<< wxT("# ranges aquired through the auto-update functionality, then\n")
+		<< wxT("# ranges acquired through the auto-update functionality, then\n")
 		<< wxT("# place them in this file. aMule will not change this file.");
 
 	CreateDummyFile(staticDat, staticMsg);
--- a/src/KadDlg.cpp
+++ b/src/KadDlg.cpp
@@ -153,7 +153,7 @@ void CKadDlg::UpdateNodeCount(unsigned n
 }
 
 
-// Enables or disables the node connect button depending on the conents of the text fields
+// Enables or disables the node connect button depending on the contents of the text fields
 void CKadDlg::OnFieldsChange(wxCommandEvent& WXUNUSED(evt))
 {
 	// These are the IDs of the search-fields
--- a/src/kademlia/kademlia/Defines.h
+++ b/src/kademlia/kademlia/Defines.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/kademlia/Entry.cpp
+++ b/src/kademlia/kademlia/Entry.cpp
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
@@ -121,9 +121,9 @@ void CEntry::SetFileName(const wxString&
 wxString CEntry::GetCommonFileName() const
 {
 	// return the filename on which most publishers seem to agree on
-	// due to the counting, this doesn't has to be excact, we just want to make sure to not use a filename which just
+	// due to the counting, this doesn't has to be exact, we just want to make sure to not use a filename which just
 	// a few bad publishers used and base or search matching and answering on this, instead of the most popular name
-	// Note: The Index values are not the acutal numbers of publishers, but just a relativ number to compare to other entries
+	// Note: The Index values are not the actual numbers of publishers, but just a relative number to compare to other entries
 	FileNameList::const_iterator result = m_filenames.end();
 	uint32_t highestPopularityIndex = 0;
 	for (FileNameList::const_iterator it = m_filenames.begin(); it != m_filenames.end(); ++it) {
@@ -363,7 +363,7 @@ void CKeyEntry::MergeIPsAndFilenames(CKe
 	bool refresh = false;
 	if (fromEntry == NULL || fromEntry->m_publishingIPs == NULL) {
 		wxASSERT(fromEntry == NULL);
-		// if called with NULL, this is a complete new entry and we need to initalize our lists
+		// if called with NULL, this is a complete new entry and we need to initialize our lists
 		if (m_publishingIPs == NULL) {
 			m_publishingIPs = new PublishingIPList();
 		}
@@ -446,7 +446,7 @@ void CKeyEntry::ReCalculateTrustValue()
 	// but mostly we say everything below 1 is bad, everything above 1 is good. It is calculated by looking at how many different
 	// IPs/24 have published this entry and how many entries each of those IPs have.
 	// Each IP/24 has x (say 3) points. This means if one IP publishes 3 different entries without any other IP publishing those entries,
-	// each of those entries will have 3 / 3 = 1 Trustvalue. Thats fine. If it publishes 6 alone, each entry has 3 / 6 = 0.5 trustvalue - not so good
+	// each of those entries will have 3 / 3 = 1 Trustvalue. That's fine. If it publishes 6 alone, each entry has 3 / 6 = 0.5 trustvalue - not so good
 	// However if there is another publisher for entry 5, which only publishes this entry then we have 3/6 + 3/1 = 3.5 trustvalue for this entry
 	//
 	// What's the point? With this rating we try to avoid getting spammed with entries for a given keyword by a small IP range, which blends out
@@ -479,7 +479,7 @@ void CKeyEntry::ReCalculateTrustValue()
 
 double CKeyEntry::GetTrustValue()
 {
-	// update if last calcualtion is too old, will assert if this entry is not supposed to have a trustvalue
+	// update if last calculation is too old, will assert if this entry is not supposed to have a trustvalue
 	if (::GetTickCount() - m_lastTrustValueCalc > MIN2MS(10)) {
 		ReCalculateTrustValue();
 	}
--- a/src/kademlia/kademlia/Entry.h
+++ b/src/kademlia/kademlia/Entry.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/kademlia/Error.h
+++ b/src/kademlia/kademlia/Error.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/kademlia/Indexed.cpp
+++ b/src/kademlia/kademlia/Indexed.cpp
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/kademlia/Indexed.h
+++ b/src/kademlia/kademlia/Indexed.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/kademlia/Kademlia.cpp
+++ b/src/kademlia/kademlia/Kademlia.cpp
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
@@ -450,7 +450,7 @@ uint32_t CKademlia::CalculateKadUsersNew
 	}
 	float newRatio = CKademlia::GetPrefs()->StatsGetKadV8Ratio();
 	float firewalledModifyTotal = 0.0;
-	if (newRatio > 0 && firewalledModifyNew > 0) { // weigth the old and the new modifier based on how many new contacts we have
+	if (newRatio > 0 && firewalledModifyNew > 0) { // weigh the old and the new modifier based on how many new contacts we have
 		firewalledModifyTotal = (newRatio * firewalledModifyNew) + ((1 - newRatio) * firewalledModifyOld);
 	} else {
 		firewalledModifyTotal = firewalledModifyOld;
--- a/src/kademlia/kademlia/Kademlia.h
+++ b/src/kademlia/kademlia/Kademlia.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/kademlia/Prefs.cpp
+++ b/src/kademlia/kademlia/Prefs.cpp
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
@@ -149,7 +149,7 @@ void CPrefs::SetIPAddress(uint32_t val)
 	}
 	//If the last check matches this one, reset our current IP.
 	//If the last check does not match, wait for our next incoming IP.
-	//This happens for two reasons.. We just changed our IP, or a client responsed with a bad IP.
+	//This happens for two reasons.. We just changed our IP, or a client responded with a bad IP.
 	if ( val == m_ipLast ) {
 		m_ip = val;
 	} else {
--- a/src/kademlia/kademlia/Prefs.h
+++ b/src/kademlia/kademlia/Prefs.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/kademlia/Search.cpp
+++ b/src/kademlia/kademlia/Search.cpp
@@ -31,7 +31,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
@@ -1031,12 +1031,12 @@ void CSearch::ProcessResultKeyword(const
 			codec = tag->GetStr();
 		} else if (tag->GetName() == TAG_SOURCES) {
 			availability = tag->GetInt();
-			// Some rouge client was setting a invalid availability, just set it to 0.
+			// Some rogue client was setting a invalid availability, just set it to 0.
 			if( availability > 65500 ) {
 				availability = 0;
 			}
 		} else if (tag->GetName() == TAG_PUBLISHINFO) {
-			// we don't keep this as tag, but as a member property of the searchfile, as we only need its informations
+			// we don't keep this as tag, but as a member property of the searchfile, as we only need its information
 			// in the search list and don't want to carry the tag over when downloading the file (and maybe even wrongly publishing it)
 			publishInfo = (uint32_t)tag->GetInt();
 #ifdef __DEBUG__
--- a/src/kademlia/kademlia/Search.h
+++ b/src/kademlia/kademlia/Search.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/kademlia/SearchManager.cpp
+++ b/src/kademlia/kademlia/SearchManager.cpp
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/kademlia/SearchManager.h
+++ b/src/kademlia/kademlia/SearchManager.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/kademlia/UDPFirewallTester.cpp
+++ b/src/kademlia/kademlia/UDPFirewallTester.cpp
@@ -60,7 +60,7 @@ bool CUDPFirewallTester::IsFirewalledUDP
 	}
 	if (!m_timedOut && IsFWCheckUDPRunning()) {
 		if (!m_firewalledUDP && CKademlia::IsFirewalled() && m_testStart != 0 && ::GetTickCount() - m_testStart > MIN2MS(6)
-			&& !m_isFWVerifiedUDP /*For now we don't allow to get firewalled by timeouts if we have succeded a test before, might be changed later*/)
+			&& !m_isFWVerifiedUDP /*For now we don't allow to get firewalled by timeouts if we have succeeded a test before, might be changed later*/)
 		{
 			AddDebugLogLineN(logKadUdpFwTester, wxT("Timeout: Setting UDP status to firewalled after being unable to get results for 6 minutes"));
 			m_timedOut = true;
@@ -95,7 +95,7 @@ void CUDPFirewallTester::SetUDPFWCheckRe
 			if (!IsFWCheckUDPRunning() && !m_firewalledUDP && m_isFWVerifiedUDP && m_lastSucceededTime + SEC2MS(10) > ::GetTickCount()
 			    && incomingPort == CKademlia::GetPrefs()->GetInternKadPort() && CKademlia::GetPrefs()->GetUseExternKadPort()) {
 				// our test finished already in the last 10 seconds with being open because we received a proper result packet before
-				// however we now receive another answer packet on our incoming port (which is not unusal as both resultpackets are sent
+				// however we now receive another answer packet on our incoming port (which is not unusual as both resultpackets are sent
 				// nearly at the same time and UDP doesn't cares if the order stays), while the one before was received on our extern port
 				// Because a proper forwarded intern port is more reliable to stay open than an extern port set by the NAT, we prefer
 				// intern ports and change the setting.
@@ -142,7 +142,7 @@ void CUDPFirewallTester::SetUDPFWCheckRe
 			m_fwChecksRunningUDP = 0; // all other tests are cancelled
 			m_possibleTestClients.clear(); // clear list, keep used clients list though
 			CSearchManager::CancelNodeFWCheckUDPSearch(); // cancel firewallnode searches if any are still active
-			// if this packet came to our internal port, explict set the interal port as used port from now on
+			// if this packet came to our internal port, explicitly set the internal port as used port from now on
 			if (incomingPort == CKademlia::GetPrefs()->GetInternKadPort()) {
 				CKademlia::GetPrefs()->SetUseExternKadPort(false);
 				AddDebugLogLineN(logKadUdpFwTester, wxT("New Kad Firewallstate (UDP): Open, using intern port"));
--- a/src/kademlia/net/KademliaUDPListener.cpp
+++ b/src/kademlia/net/KademliaUDPListener.cpp
@@ -26,7 +26,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
@@ -162,7 +162,7 @@ void CKademliaUDPListener::SendMyDetails
 void CKademliaUDPListener::FirewalledCheck(uint32_t ip, uint16_t port, const CKadUDPKey& senderKey, uint8_t kadVersion)
 {
 	if (kadVersion > 6) {
-		// new opcode since 0.49a with extended informations to support obfuscated connections properly
+		// new opcode since 0.49a with extended information to support obfuscated connections properly
 		CMemFile packetdata(19);
 		packetdata.WriteUInt16(thePrefs::GetPort());
 		packetdata.WriteUInt128(CKademlia::GetPrefs()->GetClientHash());
@@ -416,7 +416,7 @@ bool CKademliaUDPListener::AddContact2(c
 		--tags;
 	}
 
-	// check if we are waiting for informations (nodeid) about this client and if so inform the requester
+	// check if we are waiting for information (nodeid) about this client and if so inform the requester
 	for (FetchNodeIDList::iterator it = m_fetchNodeIDRequests.begin(); it != m_fetchNodeIDRequests.end(); ++it) {
 		if (it->ip == ip && it->tcpPort == tport) {
 			//AddDebugLogLineN(logKadMain, wxT("Result Addcontact: ") + id.ToHexString());
@@ -735,7 +735,7 @@ void CKademliaUDPListener::ProcessKademl
 						// UDP FirewallCheck searches are special. The point is we need an IP which we didn't sent a UDP message yet
 						// (or in the near future), so we do not try to add those contacts to our routingzone and we also don't
 						// deliver them back to the searchmanager (because he would UDP-ask them for further results), but only report
-						// them to FirewallChecker - this will of course cripple the search but thats not the point, since we only
+						// them to FirewallChecker - this will of course cripple the search but that's not the point, since we only
 						// care for IPs and not the random set target
 						CUDPFirewallTester::AddPossibleTestContact(id, contactIP, contactPort, tport, target, version, 0, false);
 					} else {
--- a/src/kademlia/net/KademliaUDPListener.h
+++ b/src/kademlia/net/KademliaUDPListener.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/routing/Contact.cpp
+++ b/src/kademlia/routing/Contact.cpp
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/routing/Contact.h
+++ b/src/kademlia/routing/Contact.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/routing/Maps.h
+++ b/src/kademlia/routing/Maps.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/routing/RoutingBin.cpp
+++ b/src/kademlia/routing/RoutingBin.cpp
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
@@ -270,7 +270,7 @@ bool CRoutingBin::ChangeContactIPAddress
 {
 	// Called if we want to update an indexed contact with a new IP. We have to check if we actually allow such a change
 	// and if adjust our tracking. Rejecting a change will in the worst case lead a node contact to become invalid and purged later,
-	// but it also protects against a flood of malicous update requests from one IP which would be able to "reroute" all
+	// but it also protects against a flood of malicious update requests from one IP which would be able to "reroute" all
 	// contacts to itself and by that making them useless
 	if (contact->GetIPAddress() == newIP) {
 		return true;
--- a/src/kademlia/routing/RoutingBin.h
+++ b/src/kademlia/routing/RoutingBin.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/routing/RoutingZone.cpp
+++ b/src/kademlia/routing/RoutingZone.cpp
@@ -31,7 +31,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
@@ -257,7 +257,7 @@ void CRoutingZone::ReadBootstrapNodesDat
 					CUInt128 distance = me;
 					distance ^= id;
 					validContacts++;
-					// don't bother if we already have 50 and the farest distance is smaller than this contact
+					// don't bother if we already have 50 and the farthest distance is smaller than this contact
 					if (CKademlia::s_bootstrapList.size() < 50 || CKademlia::s_bootstrapList.back()->GetDistance() > distance) {
 						// look where to put this contact into the proper position
 						bool inserted = false;
--- a/src/kademlia/routing/RoutingZone.h
+++ b/src/kademlia/routing/RoutingZone.h
@@ -30,7 +30,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/utils/UInt128.cpp
+++ b/src/kademlia/utils/UInt128.cpp
@@ -32,7 +32,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/kademlia/utils/UInt128.h
+++ b/src/kademlia/utils/UInt128.h
@@ -31,7 +31,7 @@ Please do not change anything here and r
 There is going to be a new forum created just for the Kademlia side of the client..
 If you feel there is an error or a way to improve something, please
 post it in the forum first and let us look at it.. If it is a real improvement,
-it will be added to the offical client.. Changing something without knowing
+it will be added to the official client.. Changing something without knowing
 what all it does can cause great harm to the network if released in mass form..
 Any mod that changes anything within the Kademlia side will not be allowed to advertise
 there client on the eMule forum..
--- a/src/KnownFile.cpp
+++ b/src/KnownFile.cpp
@@ -633,7 +633,7 @@ bool CKnownFile::LoadTagsFromFile(const
 				SetLastPublishTimeKadSrc( newtag.GetInt(), 0 );
 
 				if(GetLastPublishTimeKadSrc() > (uint32)time(NULL)+KADEMLIAREPUBLISHTIMES) {
-					//There may be a posibility of an older client that saved a random number here.. This will check for that..
+					//There may be a possibility of an older client that saved a random number here.. This will check for that..
 					SetLastPublishTimeKadSrc(0, 0);
 				}
 				break;
@@ -695,7 +695,7 @@ bool CKnownFile::WriteToFile(CFileDataIO
 		tagcount++;
 	}
 	// Float meta tags are currently not written. All older eMule versions < 0.28a have
-	// a bug in the meta tag reading+writing code. To achive maximum backward
+	// a bug in the meta tag reading+writing code. To achieve maximum backward
 	// compatibility for met files with older eMule versions we just don't write float
 	// tags. This is OK, because we (eMule) do not use float tags. The only float tags
 	// we may have to handle is the '# Sent' tag from the Hybrid, which is pretty
--- a/src/KnownFile.h
+++ b/src/KnownFile.h
@@ -234,7 +234,7 @@ public:
 	// KAD TODO: This must be used on KadSearchListCtrl too once imported
 	void	SetKadFileSearchID(uint32 id) { kadFileSearchID = id; } // John - Don't use this unless you know what your are DOING!! (Hopefully I do.. :)
 	const Kademlia::WordList& GetKadKeywords() const { return wordlist; }
-	// KAD TODO: If we add the proper column to SharedFilesCtrl, this is the funtion.
+	// KAD TODO: If we add the proper column to SharedFilesCtrl, this is the function.
 	uint32	GetLastPublishTimeKadSrc() const { return m_lastPublishTimeKadSrc; }
 	void	SetLastPublishTimeKadSrc(uint32 time, uint32 buddyip) { m_lastPublishTimeKadSrc = time; m_lastBuddyIP = buddyip;}
 	// Another unused function, useful for the shared files control column
@@ -276,9 +276,9 @@ public:
 	bool HasProperAICHHashSet() const;
 
 	/**
-	 * Updates the requency of uploading parts from with the data the client provides.
+	 * Updates the frequency of uploading parts from with the data the client provides.
 	 *
-	 * @param client The clients whoose uploading parts should be considered.
+	 * @param client The clients whose uploading parts should be considered.
 	 * @param increment If true, the counts are incremented, otherwise they are decremented.
 	 *
 	 * This functions updates the frequency list of file-upparts, using the clients
--- a/src/libs/CMakeLists.txt
+++ b/src/libs/CMakeLists.txt
@@ -1,7 +1,7 @@
-IF (NEED_LIB_EC)
-	ADD_SUBDIRECTORY (ec)
-ENDIF (NEED_LIB_EC)
+if (NEED_LIB_EC)
+	add_subdirectory (ec)
+endif()
 
-IF (NEED_LIB_MULECOMMON)
-	ADD_SUBDIRECTORY (common)
-ENDIF (NEED_LIB_MULECOMMON)
+if (NEED_LIB_MULECOMMON)
+	add_subdirectory (common)
+endif()
--- a/src/libs/common/CMakeLists.txt
+++ b/src/libs/common/CMakeLists.txt
@@ -14,11 +14,11 @@ target_include_directories (mulecommon
 )
 
 target_link_libraries (mulecommon
-	wxWidgets::BASE
+	PUBLIC wxWidgets::BASE
 )
 
 if (HAVE_BFD)
 	target_link_libraries (mulecommon
-		${BFD_LIBRARY}
+		PUBLIC ${BFD_LIBRARY}
 	)
 endif()
--- a/src/libs/common/FileFunctions.cpp
+++ b/src/libs/common/FileFunctions.cpp
@@ -136,28 +136,30 @@ static bool UnpackZipFile(const wxString
 {
 	wxTempFile target(file);
 	CSmartPtr<wxZipEntry> entry;
-	wxFFileInputStream fileInputStream(file);
-	wxZipInputStream zip(fileInputStream);
-	bool run = true;
-	while (run) {
-		entry.reset(zip.GetNextEntry());
-		if (entry.get() == NULL) {
-			break;
-		}
-		// access meta-data
-		wxString name = entry->GetName();
-		// We only care about the files specified in the array
-		// probably needed to weed out included nfos
-		for (int i = 0; run && files[i]; i++) {
-			if (name.CmpNoCase(files[i]) == 0) {
-				// we found the entry we want
-				// read 'zip' to access the entry's data
-				char buffer[10240];
-				while (!zip.Eof()) {
-					zip.Read(buffer, sizeof(buffer));
-					target.Write(buffer, zip.LastRead());
+	{
+		wxFFileInputStream fileInputStream(file);
+		wxZipInputStream zip(fileInputStream);
+		bool run = true;
+		while (run) {
+			entry.reset(zip.GetNextEntry());
+			if (entry.get() == NULL) {
+				break;
+			}
+			// access meta-data
+			wxString name = entry->GetName();
+			// We only care about the files specified in the array
+			// probably needed to weed out included nfos
+			for (int i = 0; run && files[i]; i++) {
+				if (name.CmpNoCase(files[i]) == 0) {
+					// we found the entry we want
+					// read 'zip' to access the entry's data
+					char buffer[10240];
+					while (!zip.Eof()) {
+						zip.Read(buffer, sizeof(buffer));
+						target.Write(buffer, zip.LastRead());
+					}
+					run = false;
 				}
-				run = false;
 			}
 		}
 	}
@@ -240,7 +242,7 @@ static bool UnpackGZipFile(const wxStrin
 
 	if (write) {
 		target.Commit();
-		// AddDebugLogLineN( logFileIO, wxT("Commited gzip stream") );
+		// AddDebugLogLineN( logFileIO, wxT("Committed gzip stream") );
 	}
 
 	return write;
--- a/src/libs/common/Format.h
+++ b/src/libs/common/Format.h
@@ -40,7 +40,7 @@
  *  - The @c "*" width-modifier, because only one argument is fed at a time.
  *  - The @c "n" type, just unsafe and won't be implemented.
  *  - The @c "C" and @c "S" types, which are considered obsolete.
- *  - The Long Double type, which is extremly slow and shouldn't be used.
+ *  - The Long Double type, which is extremely slow and shouldn't be used.
  *
  * Support for the C99 @c a, @c A conversions and the non-standard @c ', @c I
  * flags depend on the underlying C library. Do not use them.
@@ -194,11 +194,7 @@ template<> inline CFormat& CFormat::oper
 template<> inline CFormat& CFormat::operator%(const wxChar* value)	{ return this->operator%<const wxString&>(wxString(value)); }
 
 
-#if wxCHECK_VERSION(2, 9, 0)
 #define WXLONGLONGFMTSPEC wxT(wxLongLongFmtSpec)
-#else
-#define WXLONGLONGFMTSPEC wxLongLongFmtSpec
-#endif
 
 #endif
 // File_checked_for_headers
--- a/src/libs/common/MuleDebug.cpp
+++ b/src/libs/common/MuleDebug.cpp
@@ -55,11 +55,12 @@
 #endif
 
 #include <vector>
+#include <exception>
 
 
 /**
  * This functions displays a verbose description of
- * any unhandled exceptions that occour and then
+ * any unhandled exceptions that occur and then
  * terminate the program by raising SIGABRT.
  */
 void OnUnhandledException()
--- a/src/libs/common/Path.cpp
+++ b/src/libs/common/Path.cpp
@@ -201,8 +201,8 @@ static bool IsSameAs(const wxString& a,
 
 	// Let wxFileName handle the tricky stuff involved in actually
 	// comparing two paths ... Currently, a path ending with a path-
-	// seperator will be unequal to the same path without a path-
-	// seperator, which is probably for the best, but can could
+	// separator will be unequal to the same path without a path-
+	// separator, which is probably for the best, but can could
 	// lead to some unexpected behavior.
 	wxFileName fn1(a);
 	wxFileName fn2(b);
@@ -230,7 +230,7 @@ CPath::CPath(const wxString& filename)
 	}
 
 	wxCharBuffer fn = filename2char(filename);
-	if (fn.data()) {
+	if (fn.data() && fn.length()) {
 		// Filename is valid in the current locale. This means that
 		// it either originated from a (wx)system-call, or from a
 		// user with a properly setup system.
@@ -530,7 +530,7 @@ bool CPath::StartsWith(const CPath& othe
 		return false;
 	}
 
-	// Adding an seperator to avoid partial matches, such as
+	// Adding an separator to avoid partial matches, such as
 	// "/usr/bi" matching "/usr/bin". TODO: Paths should be
 	// normalized first (in the constructor).
 	const wxString a = StripSeparators(m_filesystem, wxString::trailing) + wxFileName::GetPathSeparator();
--- a/src/libs/common/Path.h
+++ b/src/libs/common/Path.h
@@ -53,7 +53,7 @@ public:
 	/** Default constructor. */
 	CPath();
 
-	/** Constuctor. */
+	/** Constructor. */
 	explicit CPath(const wxString& path);
 
 	/** Copy constructor. Creates a deep-copy of the passed object. */
@@ -116,7 +116,7 @@ public:
 	/** Returns the (raw) last extension, empty if none is found. */
 	wxString GetExt() const;
 
-	/** Returns the full path, exluding the filename. */
+	/** Returns the full path, excluding the filename. */
 	CPath GetPath() const;
 	/** Returns the full filename, excluding the path. */
 	CPath GetFullName() const;
@@ -126,7 +126,7 @@ public:
 
 	/**
 	 * Compares under the assumption that both objects are dirs, even if
-	 * one or the other lacks a terminal directory-seperator. However, an
+	 * one or the other lacks a terminal directory-separator. However, an
 	 * empty CPath object will not be considered equal to a path to the root.
 	 */
 	bool IsSameDir(const CPath& other) const;
--- a/src/libs/common/StringFunctions.cpp
+++ b/src/libs/common/StringFunctions.cpp
@@ -164,7 +164,7 @@ enum ECharType {
 
 inline wxString GetNextField(const wxString& str, size_t& cookie)
 {
-	// These are taken to seperate "fields"
+	// These are taken to separate "fields"
 	static const wxChar* s_delims = wxT("\t\n\x0b\x0c\r !\"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~");
 
 	wxString field;
--- a/src/libs/common/StringFunctions.h
+++ b/src/libs/common/StringFunctions.h
@@ -127,7 +127,7 @@ inline char* nstrdup(const char* src)
 inline long StrToLong(const wxString& str)
 {
 	long value = 0;
-	if (!str.ToLong(&value)) {	// value may be changed even if it failes according to wx docu
+	if (!str.ToLong(&value)) {	// value may be changed even if it fails according to wx docu
 		value = 0;
 	}
 	return value;
@@ -144,25 +144,11 @@ inline unsigned long StrToULong(const wx
 
 inline unsigned long long StrToULongLong(const wxString& str)
 {
-#if wxCHECK_VERSION(2, 9, 0)
 	unsigned long long value = 0;
 	if (!str.ToULongLong(&value)) {
 		value = 0;
 	}
 	return value;
-
-#else	// wx 2.8
-
-	Unicode2CharBuf buf = unicode2char(str);
-	if (!buf) {		// something went wrong
-		return 0;
-	}
-#ifdef _MSC_VER
-	return _atoi64(buf);
-#else
-	return atoll(buf);
-#endif
-#endif	// wx 2.8
 }
 
 inline size_t GetRawSize(const wxString& rstr, EUtf8Str eEncode)
@@ -238,7 +224,7 @@ wxString validateURI(const wxString& url
  * compared. This allows strings such as "a (2)" and "a (10)" to
  * be properly sorted for displaying.
  *
- * Currently does not handle floats (they are treated as to seperate
+ * Currently does not handle floats (they are treated as to separate
  * fields, nor negative numbers.
  */
 int FuzzyStrCmp(const wxString& a, const wxString& b);
--- a/src/libs/common/TextFile.h
+++ b/src/libs/common/TextFile.h
@@ -111,10 +111,10 @@ public:
 	bool		WriteLine(const wxString& line, const wxMBConv& conv = wxConvLibc);
 
 
-	/** Reads and returns the contents of a text-file, using the specifed criteria and converter. */
+	/** Reads and returns the contents of a text-file, using the specified criteria and converter. */
 	wxArrayString ReadLines(EReadTextFile flags = txtReadDefault, const wxMBConv& conv = wxConvLibc);
 
-	/** Writes the lines to the file, using the given converter, returning true if no errors occured. */
+	/** Writes the lines to the file, using the given converter, returning true if no errors occurred. */
 	bool WriteLines(const wxArrayString& lines, const wxMBConv& conv = wxConvLibc);
 
 private:
--- a/src/libs/ec/CMakeLists.txt
+++ b/src/libs/ec/CMakeLists.txt
@@ -1,3 +1,3 @@
-IF (NEED_LIB_EC)
-	ADD_SUBDIRECTORY (cpp)
-ENDIF (NEED_LIB_EC)
+if (NEED_LIB_EC)
+	add_subdirectory (cpp)
+endif()
--- a/src/libs/ec/cpp/ECSocket.cpp
+++ b/src/libs/ec/cpp/ECSocket.cpp
@@ -437,7 +437,7 @@ void CECSocket::OnOutput()
 				// Event driven logic: return, OnOutput() will be called again later
 				return;
 			}
-			// Syncronous call: wait (for max 10 secs)
+			// Synchronous call: wait (for max 10 secs)
 			if ( !WaitSocketWrite(10, 0) ) {
 				// Still not through ?
 				if (WouldBlock()) {
@@ -550,7 +550,7 @@ bool CECSocket::ReadHeader()
 	// b) way too large (free data again after receiving huge packets)
 		|| m_bytes_needed + EC_SOCKET_BUFFER_SIZE * 10 < currLength) {
 		// Client socket: IsAuthorized() is always true
-		// Server socket: do not allow growing of internal buffers before succesfull login.
+		// Server socket: do not allow growing of internal buffers before successful login.
 		// Otherwise sending a simple header with bogus length of 16MB-1 will crash an embedded
 		// client with memory exhaustion.
 		if (!IsAuthorized()) {
--- a/src/libs/ec/cpp/ECSocket.h
+++ b/src/libs/ec/cpp/ECSocket.h
@@ -112,7 +112,7 @@ public:
 	 * This is an asynchronous call, the function returns
 	 * immediately and the packet is sent on idle time.
 	 *
-	 * @note It's the caller's responsibilty to \c delete
+	 * @note It's the caller's responsibility to \c delete
 	 * the \e packet.
 	 */
 	void SendPacket(const CECPacket *packet);
@@ -131,7 +131,7 @@ public:
 	 * The returned packet will be allocated on the heap with \c new,
 	 * or \c NULL is returned in case of an error (timeout).
 	 *
-	 * @note It's the caller's responsibilty to \c delete both
+	 * @note It's the caller's responsibility to \c delete both
 	 * request and reply.
 	 *
 	 * @note OnPacketReceived() won't be called for packets
@@ -160,7 +160,7 @@ public:
 	 * Get a message describing the error.
 	 *
 	 * @param error The code of the error for which a message should be returned.
-	 * @return The text descibing the error.
+	 * @return The text describing the error.
 	 */
 	virtual std::string	GetLastErrorMsg();
 
@@ -250,7 +250,7 @@ public:
 	virtual bool InternalIsConnected() = 0;
 	virtual void InternalDestroy() = 0;
 
-	// Was login succesfull ?
+	// Was login successful ?
 	virtual bool IsAuthorized() { return true; }
 };
 
--- a/src/libs/ec/cpp/ECTag.cpp
+++ b/src/libs/ec/cpp/ECTag.cpp
@@ -1113,7 +1113,7 @@ void CECTag::DebugPrint(int level, bool
  * converted from UTF-8 to the internal application encoding.
  * Should be used with care (only on tags created with the
  * CECTag(ec_tagname_t, const wxString&) constructor),
- * becuse it does not perform any check to see if the tag really contains a
+ * because it does not perform any check to see if the tag really contains a
  * string object.
  *
  * \return The string data of the tag.
--- a/src/LibSocket.h
+++ b/src/LibSocket.h
@@ -305,7 +305,7 @@ public:
 			m_isDestroying = true;
 			SetNotify(0);
 			Notify(false);
-			Close(); // Destroy is suposed to call Close(), but.. it doesn't hurt.
+			Close(); // Destroy is supposed to call Close(), but.. it doesn't hurt.
 			wxSocketClient::Destroy();
 		}
 	}
--- a/src/ListenSocket.h
+++ b/src/ListenSocket.h
@@ -30,7 +30,7 @@
 #ifndef LISTENSOCKET_H
 #define LISTENSOCKET_H
 
-#include "Proxy.h"		// Needed fot CProxyData, CSocketServerProxy
+#include "Proxy.h"		// Needed for CProxyData, CSocketServerProxy
 
 #include <set>
 
--- a/src/Logger.cpp
+++ b/src/Logger.cpp
@@ -309,7 +309,6 @@ CLoggerTarget::CLoggerTarget()
 {
 }
 
-#if wxCHECK_VERSION(2, 9, 0)
 void CLoggerTarget::DoLogText(const wxString &msg)
 {
 	// prevent infinite recursion
@@ -328,31 +327,6 @@ void CLoggerTarget::DoLogText(const wxSt
 
 	recursion = false;
 }
-#else
-void CLoggerTarget::DoLogString(const wxChar* msg, time_t)
-{
-	// prevent infinite recursion
-	static bool recursion = false;
-	if (recursion) {
-		return;
-	}
-	recursion = true;
-
-	wxCHECK_RET(msg, wxT("Log message is NULL in DoLogString!"));
-
-	wxString str(msg);
-
-	// This is much simpler than manually handling all wx log-types.
-	// cppcheck-suppress duplicateBranch
-	if (str.StartsWith(_("ERROR: ")) || str.StartsWith(_("WARNING: "))) {
-		AddLogLineC(str);
-	} else {
-		AddLogLineN(str);
-	}
-
-	recursion = false;
-}
-#endif
 
 CLoggerAccess::CLoggerAccess()
 {
--- a/src/Logger.h
+++ b/src/Logger.h
@@ -322,13 +322,9 @@ public:
 	CLoggerTarget();
 
 	/**
-	 * @see wxLog::DoLogString
+	 * @see wxLog::DoLogText
 	 */
-#if wxCHECK_VERSION(2, 9, 0)
 	void DoLogText(const wxString &msg);
-#else
-	void DoLogString(const wxChar *msg, time_t);
-#endif
 };
 
 
--- a/src/MD4Hash.h
+++ b/src/MD4Hash.h
@@ -45,7 +45,7 @@ const size_t MD4HASH_LENGTH = 16;
  *
  * This is a safe representation of the MD4 hashes used in aMule. By transparently
  * wrapping the char array used to store the hash, we get the advantages of
- * assigment, equality and non-equality operators, plus other nifty features.
+ * assignment, equality and non-equality operators, plus other nifty features.
  *
  * Please remember that the hashes are arrays with length 16 WITHOUT a zero-terminator!
  */
@@ -126,7 +126,7 @@ public:
 	 *
 	 * This functions checks the contents of the hash and returns true
 	 * only if each field of the array contains the value zero.
-	 * To achive an empty hash, the function Clear() can be used.
+	 * To achieve an empty hash, the function Clear() can be used.
 	 */
 	bool IsEmpty() const {
 		return (
@@ -151,7 +151,7 @@ public:
 	 * Decodes a 32 char long hexadecimal representation of a MD4 hash.
 	 *
 	 * @param hash The hash representation to be converted. Length must be 32.
-	 * @return Return value specifies if the hash was succesfully decoded.
+	 * @return Return value specifies if the hash was successfully decoded.
 	 *
 	 * This function converts a hexadecimal representation of a MD4
 	 * hash and stores it in the m_hash data-member.
--- a/src/MemFile.h
+++ b/src/MemFile.h
@@ -39,7 +39,7 @@
  *    of the same packet.
  *  - Endian correction is handled transparently. When reading and
  *    writing values, CMemFile converts to and from little-endian,
- *    so that no explicit endian convertions are nescesarry.
+ *    so that no explicit endian conversions are necessary.
  *  - Strings of dynamic length can be read.
  *
  * Most of these advantages also hold for writing packets.
@@ -57,7 +57,7 @@ public:
 	 * The growth-rate specified by how much the buffer-size will
 	 * be increased when the memfile runs out of space. Normally
 	 * this means that the amount of re-allocations is cut down
-	 * at the expence of slightly higher mem-usage.
+	 * at the expense of slightly higher mem-usage.
 	 *
 	 * If the size of the entire file to be written is known
 	 * in advance, one can avoid needless re-allocations by
@@ -110,7 +110,7 @@ public:
 	 * If the current position is greater than the new length, it
 	 * will be set to the end of the file.
 	 *
-	 * Note that changing the lenght of a file with an attached buffer
+	 * Note that changing the length of a file with an attached buffer
 	 * to a value greater than the actual buffer size is an illegal
 	 * operation.
 	 */
--- a/src/MuleCollection.cpp
+++ b/src/MuleCollection.cpp
@@ -10,7 +10,7 @@
 //
 // Marcelo Malheiros <mgmalheiros@gmail.com>
 // * fixed error with FT_FILEHASH
-// * added inital 5 tag/file support
+// * added initial 5 tag/file support
 //
 // Any parts of this program derived from the xMule, lMule or eMule project,
 // or contributed by third-party developers are copyrighted by their
--- a/src/MuleColour.cpp
+++ b/src/MuleColour.cpp
@@ -35,7 +35,7 @@
 std::map<uint32_t, wxPen*> wxPenCache;
 std::map<uint32_t, wxBrush*> wxBrushCache;
 
-const wxPen& CMuleColour::GetPen(int width, int style) const
+const wxPen& CMuleColour::GetPen(int width, wxPenStyle style) const
 {
 #if USE_MULE_PEN_CACHE
 	wxPen* result = NULL;
@@ -61,7 +61,7 @@ const wxPen& CMuleColour::GetPen(int wid
 #endif
 }
 
-const wxBrush& CMuleColour::GetBrush(int style) const
+const wxBrush& CMuleColour::GetBrush(wxBrushStyle style) const
 {
 #if USE_MULE_BRUSH_CACHE
 	wxBrush* result = NULL;
--- a/src/MuleColour.h
+++ b/src/MuleColour.h
@@ -27,6 +27,9 @@
 
 #include <wx/colour.h>
 #include <wx/settings.h>
+#include <wx/pen.h>   // needed for wxPenStyle enum values
+#include <wx/brush.h> // needed for wxBrushStyle enum values
+#include <wx/font.h>  // needed for wxFontStyle enum values
 #include "Types.h"
 
 class wxPen;
@@ -95,8 +98,8 @@ public:
 		return wxColor(m_red, m_green, m_blue);
 	}
 
-	const wxPen& GetPen(int width = 1, int style = wxSOLID) const;
-	const wxBrush& GetBrush(int style = wxSOLID) const;
+	const wxPen& GetPen(int width = 1, wxPenStyle style = wxPENSTYLE_SOLID) const;
+	const wxBrush& GetBrush(wxBrushStyle style = wxBRUSHSTYLE_SOLID) const;
 
 private:
 	uint8_t m_red;
--- a/src/MuleGifCtrl.cpp
+++ b/src/MuleGifCtrl.cpp
@@ -116,11 +116,7 @@ void MuleGifCtrl::Start()
 	if (m_decoder && m_decoder->IsAnimation()) {
 		m_timer.Stop();
 		m_decoder->GoLastFrame();
-#if wxCHECK_VERSION(2, 9, 0)
 		wxTimerEvent evt(m_timer);
-#else
-		wxTimerEvent evt;
-#endif
 		OnTimer(evt);
 	}
 }
@@ -167,7 +163,7 @@ void MuleGifCtrl::OnPaint(wxPaintEvent&
 	int x = (clientsize.GetWidth()-gifsize.GetWidth())/2;
 	int y = (clientsize.GetHeight()-gifsize.GetHeight())/2;
 
-	dc.SetBackground(*(wxTheBrushList->FindOrCreateBrush(GetBackgroundColour(), wxSOLID)));
+	dc.SetBackground(*(wxTheBrushList->FindOrCreateBrush(GetBackgroundColour(), wxBRUSHSTYLE_SOLID)));
 	dc.Clear();
 	dc.DrawBitmap(m_frame, x, y, true);
 }
--- a/src/MuleGifCtrl.h
+++ b/src/MuleGifCtrl.h
@@ -64,7 +64,7 @@ private:
 
 public:
 	/**
-	 * Contructor. See wxWindow class documentation for more information.
+	 * Constructor. See wxWindow class documentation for more information.
 	 */
 	MuleGifCtrl(
 		wxWindow *parent, wxWindowID id,
@@ -107,9 +107,9 @@ public:
 	void Stop();
 
 	/**
-	 * Returns the prefered size of the widget.
+	 * Returns the preferred size of the widget.
 	 *
-	 * @return Prefered size, which is the size of the animation.
+	 * @return Preferred size, which is the size of the animation.
 	 */
 	virtual wxSize GetBestSize();
 
--- a/src/MuleListCtrl.cpp
+++ b/src/MuleListCtrl.cpp
@@ -222,7 +222,7 @@ void CMuleListCtrl::LoadSettings()
 	wxString sortOrders = cfg->Read(wxT("/eMule/TableOrdering") + m_name, wxEmptyString);
 	wxString columnWidths = cfg->Read(wxT("/eMule/TableWidths") + m_name, wxEmptyString);
 
-	// Prevent sorting from occuring when calling SetSorting
+	// Prevent sorting from occurring when calling SetSorting
 	MuleListCtrlCompare sortFunc = m_sort_func;
 	m_sort_func = NULL;
 
--- a/src/MuleListCtrl.h
+++ b/src/MuleListCtrl.h
@@ -247,7 +247,7 @@ protected:
 	 *
 	 * By default, this function simply returns the text in the first
 	 * column for the given item. However, when owner-drawing is
-	 * enabled, this function _must_ be overriden.
+	 * enabled, this function _must_ be overridden.
 	 */
 	virtual wxString GetTTSText(unsigned item) const;
 
@@ -446,7 +446,7 @@ private:
 	 * @param[in] oldindex Old column index which we want to turn into a
 	 * new index.
 	 *
-	 * @return The new index of the column, or -1 if an error occured.
+	 * @return The new index of the column, or -1 if an error occurred.
 	 */
 	int GetNewColumnIndex(int oldindex) const;
 
--- a/src/MuleNotebook.cpp
+++ b/src/MuleNotebook.cpp
@@ -33,10 +33,6 @@
 DEFINE_LOCAL_EVENT_TYPE(wxEVT_COMMAND_MULENOTEBOOK_PAGE_CLOSING)
 DEFINE_LOCAL_EVENT_TYPE(wxEVT_COMMAND_MULENOTEBOOK_ALL_PAGES_CLOSED)
 
-#if MULE_NEEDS_DELETEPAGE_WORKAROUND
-DEFINE_LOCAL_EVENT_TYPE(wxEVT_COMMAND_MULENOTEBOOK_DELETE_PAGE)
-#endif
-
 BEGIN_EVENT_TABLE(CMuleNotebook, wxNotebook)
 	EVT_RIGHT_DOWN(CMuleNotebook::OnRMButton)
 
@@ -50,9 +46,6 @@ BEGIN_EVENT_TABLE(CMuleNotebook, wxNoteb
 	EVT_MIDDLE_DOWN(CMuleNotebook::OnMouseButton)
 	EVT_MIDDLE_UP(CMuleNotebook::OnMouseButton)
 	EVT_MOTION(CMuleNotebook::OnMouseMotion)
-#if MULE_NEEDS_DELETEPAGE_WORKAROUND
-	EVT_MULENOTEBOOK_DELETE_PAGE(wxID_ANY, CMuleNotebook::OnDeletePage)
-#endif
 END_EVENT_TABLE()
 
 
@@ -71,15 +64,6 @@ CMuleNotebook::~CMuleNotebook()
 }
 
 
-#if MULE_NEEDS_DELETEPAGE_WORKAROUND
-void CMuleNotebook::OnDeletePage(wxBookCtrlEvent& evt)
-{
-	int page = evt.GetSelection();
-	DeletePage(page);
-}
-#endif // MULE_NEEDS_DELETEPAGE_WORKAROUND
-
-
 bool CMuleNotebook::DeletePage(int nPage)
 {
 	wxCHECK_MSG((nPage >= 0) && (nPage < (int)GetPageCount()), false,
@@ -249,17 +233,7 @@ void CMuleNotebook::OnMouseButton(wxMous
 		// User did click on a 'x' or middle click on the label
 		tab_down_icon = -1;
 		tab_down_label = -1;
-#if MULE_NEEDS_DELETEPAGE_WORKAROUND
-		/*	WORKAROUND: Instead of calling DeletePage, we need to wait for the
-		 *	mouse release signal to reach Gtk. Inconsistent with normal wxEvent
-		 *	behaviour the button release handler in wxWidgets don't evaluate
-		 *	the result of the signal handling. */
-		wxNotebookEvent evt( wxEVT_COMMAND_MULENOTEBOOK_DELETE_PAGE, GetId(), tab );
-		evt.SetEventObject(this);
-		AddPendingEvent( evt );
-#else
 		DeletePage(tab);
-#endif // MULE_NEEDS_DELETEPAGE_WORKAROUND
 	} else {
 		// Is not a 'x'. Send this event up.
 		event.Skip();
--- a/src/MuleNotebook.h
+++ b/src/MuleNotebook.h
@@ -28,24 +28,10 @@
 
 #include <wx/notebook.h>
 
-#define MULE_NEEDS_DELETEPAGE_WORKAROUND	wxCHECK_VERSION(3,0,2)
-
 
 DECLARE_LOCAL_EVENT_TYPE(wxEVT_COMMAND_MULENOTEBOOK_PAGE_CLOSING, -1)
 DECLARE_LOCAL_EVENT_TYPE(wxEVT_COMMAND_MULENOTEBOOK_ALL_PAGES_CLOSED, -1)
 
-#if MULE_NEEDS_DELETEPAGE_WORKAROUND
-DECLARE_LOCAL_EVENT_TYPE(wxEVT_COMMAND_MULENOTEBOOK_DELETE_PAGE, -1)
-
-#define EVT_MULENOTEBOOK_DELETE_PAGE(id, fn)						\
-	DECLARE_EVENT_TABLE_ENTRY(							\
-		wxEVT_COMMAND_MULENOTEBOOK_DELETE_PAGE,					\
-		id,									\
-		-1,									\
-		(wxObjectEventFunction)(wxEventFunction)(wxNotebookEventFunction) &fn,  \
-		NULL                                                                    \
-	),
-#endif // MULE_NEEDS_DELETEPAGE_WORKAROUND
 
 #define EVT_MULENOTEBOOK_PAGE_CLOSING(id, fn)						\
 	DECLARE_EVENT_TABLE_ENTRY(							\
@@ -113,7 +99,7 @@ public:
 	/**
 	 * Sets an external widget to handle the popup-event.
 	 *
-	 * @param widget The widget which would recieve the event or NULL to disable.
+	 * @param widget The widget which would receive the event or NULL to disable.
 	 *
 	 * Setting the handler to a non-NULL pointer means that upon right-clicks, a
 	 * right click event will be sent to that widget, so that it can create a
@@ -122,12 +108,6 @@ public:
 	 */
 	void SetPopupHandler( wxWindow* widget );
 
-#if MULE_NEEDS_DELETEPAGE_WORKAROUND
-private:
-	// Internal handler. Workaround for wxWidgets Tab-Crash bug.
-	void OnDeletePage(wxBookCtrlEvent& evt);
-#endif // MULE_NEEDS_DELETEPAGE_WORKAROUND
-
 protected:
 	/**
 	 * Event handler for left or middle mouse button to press or release (for closing pages)
@@ -145,24 +125,24 @@ protected:
 	void OnRMButton(wxMouseEvent& event);
 
 	/**
-	 * Event-handler fo the Close item on the popup-menu.
+	 * Event-handler of the Close item on the popup-menu.
 	 */
 	void OnPopupClose(wxCommandEvent& evt);
 
 	/**
-	 * Event-handler fo the CloseAll item on the popup-menu.
+	 * Event-handler of the CloseAll item on the popup-menu.
 	 */
 	void OnPopupCloseAll(wxCommandEvent& evt);
 
 	/**
-	 * Event-handler fo the CloseOthers item on the popup-menu.
+	 * Event-handler of the CloseOthers item on the popup-menu.
 	 */
 	void OnPopupCloseOthers(wxCommandEvent& evt);
 
 	//! Keeps track of the popup-menu being enabled or not.
 	bool		m_popup_enable;
 
-	//! The pointer to the widget which would recieve right-click events or NULL.
+	//! The pointer to the widget which would receive right-click events or NULL.
 	wxWindow*	m_popup_widget;
 
 	DECLARE_EVENT_TABLE()
--- a/src/MuleTextCtrl.cpp
+++ b/src/MuleTextCtrl.cpp
@@ -40,7 +40,7 @@ enum CMTC_Events
 {
 	//! Cut text, uses provided ID
 	CMTCE_Cut	= wxID_CUT,
-	//! Copy text, uses privided ID
+	//! Copy text, uses provided ID
 	CMTCE_Copy	= wxID_COPY,
 	//! Paste text, uses custom ID
 	CMTCE_Paste = wxID_HIGHEST + 666,	// Random satanic ID
--- a/src/MuleTextCtrl.h
+++ b/src/MuleTextCtrl.h
@@ -69,7 +69,7 @@ protected:
 	 *
 	 * Please note that by using the RIGHT_DOWN event, I'm disabling the second
 	 * type of selection that the wxTextCtrl supports. However, I frankly only
-	 * noticed that second selection type while implementing this, so I doubth
+	 * noticed that second selection type while implementing this, so I doubt
 	 * that anyone will be missing it ...
 	 */
 	void OnRightDown( wxMouseEvent& evt );
@@ -77,7 +77,7 @@ protected:
 	/**
 	 * This function takes care of pasting text.
 	 *
-	 * Pleaes note that it is only needed because wxMenu disallows enabling and
+	 * Please note that it is only needed because wxMenu disallows enabling and
 	 * disabling of items that use the predefined wxID_PASTE id. This is the
 	 * only one of the already provided commands we need to override, since the
 	 * others already work just fine.
--- a/src/MuleThread.h
+++ b/src/MuleThread.h
@@ -40,7 +40,7 @@ public:
 	 * Stops the thread.
 	 *
 	 * For detached threads, this function is equivalent
-	 * to Delete, but is also useable for joinable threads,
+	 * to Delete, but is also usable for joinable threads,
 	 * where Delete should not be used, due to crashes
 	 * experienced in that case. In the case of joinable
 	 * threads, Wait is called rather than Delete.
@@ -61,7 +61,7 @@ public:
 	virtual bool TestDestroy()
 	{
 		// m_stop is checked last, because some functionality is
-		// dependant upon wxThread::TestDestroy() being called,
+		// dependent upon wxThread::TestDestroy() being called,
 		// for instance Pause().
 		return wxThread::TestDestroy() || m_stop;
 	}
--- a/src/MuleTrayIcon.cpp
+++ b/src/MuleTrayIcon.cpp
@@ -235,7 +235,7 @@ void CMuleTrayIcon::SetTrayIcon(int Icon
 		IconWithSpeed.SelectObject(TempBMP);
 
 
-		// Speed bar is: centered, taking 80% of the icon heigh, and
+		// Speed bar is: centered, taking 80% of the icon height, and
 		// right-justified taking a 10% of the icon width.
 
 		// X
@@ -293,7 +293,7 @@ wxMenu* CMuleTrayIcon::CreatePopupMenu()
 	bool showMBpsUp = (MBpsUp >= 1);
 	bool showMBpsDown = (MBpsDown >= 1);
 
-	// Creates dinamically the menu to show the user.
+	// Dynamically creates the menu to show the user.
 	wxMenu *traymenu = new wxMenu();
 	traymenu->SetTitle(_("aMule Tray Menu"));
 
--- a/src/MuleTrayIcon.h
+++ b/src/MuleTrayIcon.h
@@ -63,7 +63,7 @@ class CMuleTrayIcon : public wxTaskBarIc
 {
 public:
 	/**
-	 * Contructor.
+	 * Constructor.
 	 */
 	CMuleTrayIcon();
 
--- a/src/MuleUDPSocket.cpp
+++ b/src/MuleUDPSocket.cpp
@@ -324,7 +324,7 @@ bool CMuleUDPSocket::SendTo(uint8_t *buf
 		// flag so it gets resent when socket is ready.
 		m_busy = true;
 	} else if (uint32 error = m_socket->LastError()) {
-		// An error which we can't handle happended, so we drop
+		// An error which we can't handle happened, so we drop
 		// the packet rather than risk entering an infinite loop.
 		AddLogLineN((wxT("WARNING! ") + m_name + wxT(": Packet to "))
 			<< Uint32_16toStringIP_Port(ip, port)
--- a/src/MuleUDPSocket.h
+++ b/src/MuleUDPSocket.h
@@ -60,7 +60,7 @@ public:
 	 * @param name Name used when logging events.
 	 * @param id The ID used for events.
 	 * @param address The address where the socket will listen.
-	 * @param ProxyData ProxyData assosiated with the socket.
+	 * @param ProxyData ProxyData associated with the socket.
 	 */
 	CMuleUDPSocket(const wxString& name, int id, const amuleIPV4Address& address, const CProxyData* ProxyData = NULL);
 
--- a/src/muuli_wdr.cpp
+++ b/src/muuli_wdr.cpp
@@ -77,7 +77,7 @@ wxSizer *muleDlg( wxWindow *parent, bool
 
     CMuleTextCtrl *item4 = new CMuleTextCtrl( parent, -1, wxT(""), wxDefaultPosition, wxSize(-1,20), wxTE_MULTILINE );
     item4->SetName( wxT("FastEd2kLinks") );
-    item2->Add( item4, 1, wxGROW|wxALIGN_CENTER_HORIZONTAL|wxALL, 0 );
+    item2->Add( item4, 1, wxALL|wxEXPAND, 5 );
 
     wxButton *item5 = new wxButton( parent, ID_BUTTON_FAST, _("Commit"), wxDefaultPosition, wxDefaultSize, 0 );
     item5->SetToolTip( _("Click here to add the eD2k link in the text control to your download queue.") );
@@ -474,7 +474,7 @@ wxSizer *transferBottomPane( wxWindow *p
     item0->Add( item1, 0, wxGROW|wxALIGN_CENTER_VERTICAL, 5 );
 
     CSourceListCtrl *item6 = new CSourceListCtrl( parent, ID_CLIENTLIST, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER );
-    item0->Add( item6, 1, wxGROW|wxALIGN_CENTER_VERTICAL, 5 );
+    item0->Add( item6, 1, wxGROW, 5 );
 
     if (set_sizer)
     {
@@ -1048,7 +1048,7 @@ wxSizer *statsDlg( wxWindow *parent, boo
     wxWindow *item3 = new COScopeCtrl(3,1,GRAPH_DOWN,parent);
 item3->SetName(wxT("dloadScope"));
     wxASSERT( item3 );
-    item1->Add( item3, 1, wxGROW|wxALIGN_CENTER_VERTICAL, 5 );
+    item1->Add( item3, 1, wxGROW|wxALL, 5 );
 
     wxFlexGridSizer *item4 = new wxFlexGridSizer( 2, 0, 0 );
     item4->AddGrowableCol( 0 );
@@ -1089,7 +1089,7 @@ item3->SetName(wxT("dloadScope"));
 
     item1->Add( item4, 0, wxALIGN_CENTER_VERTICAL|wxLEFT|wxRIGHT|wxTOP, 5 );
 
-    item0->Add( item1, 1, wxGROW|wxALIGN_CENTER_VERTICAL|wxBOTTOM, 5 );
+    item0->Add( item1, 1, wxGROW|wxBOTTOM, 5 );
 
     wxStaticBox *item15 = new wxStaticBox( parent, -1, _("Upload-Speed") );
     wxStaticBoxSizer *item14 = new wxStaticBoxSizer( item15, wxVERTICAL );
@@ -1097,7 +1097,7 @@ item3->SetName(wxT("dloadScope"));
     wxWindow *item16 = new COScopeCtrl(3,1,GRAPH_UP,parent);
 item16->SetName(wxT("uloadScope"));
     wxASSERT( item16 );
-    item14->Add( item16, 1, wxGROW|wxALIGN_CENTER_VERTICAL, 5 );
+    item14->Add( item16, 1, wxGROW|wxALL, 5 );
 
     wxFlexGridSizer *item17 = new wxFlexGridSizer( 2, 0, 0 );
     item17->AddGrowableCol( 0 );
@@ -1138,7 +1138,7 @@ item16->SetName(wxT("uloadScope"));
 
     item14->Add( item17, 0, wxALIGN_CENTER_VERTICAL|wxLEFT|wxRIGHT|wxTOP, 5 );
 
-    item0->Add( item14, 1, wxGROW|wxALIGN_CENTER_VERTICAL|wxBOTTOM, 5 );
+    item0->Add( item14, 1, wxGROW|wxBOTTOM, 5 );
 
     wxStaticBox *item28 = new wxStaticBox( parent, -1, _("Connections") );
     wxStaticBoxSizer *item27 = new wxStaticBoxSizer( item28, wxVERTICAL );
@@ -1146,7 +1146,7 @@ item16->SetName(wxT("uloadScope"));
     wxWindow *item29 = new COScopeCtrl(3,0,GRAPH_CONN,parent);
 item29->SetName(wxT("otherScope"));
     wxASSERT( item29 );
-    item27->Add( item29, 1, wxGROW|wxALIGN_CENTER_VERTICAL, 5 );
+    item27->Add( item29, 1, wxGROW|wxALL, 5 );
 
     wxFlexGridSizer *item30 = new wxFlexGridSizer( 2, 0, 0 );
     item30->AddGrowableCol( 0 );
@@ -1187,16 +1187,15 @@ item29->SetName(wxT("otherScope"));
 
     item27->Add( item30, 0, wxALIGN_CENTER_VERTICAL|wxLEFT|wxRIGHT|wxTOP, 5 );
 
-    item0->Add( item27, 1, wxGROW|wxALIGN_CENTER_VERTICAL, 5 );
+    item0->Add( item27, 1, wxGROW|wxALL, 5 );
 
     wxStaticBox *item41 = new wxStaticBox( parent, -1, _("Statistics Tree") );
     wxStaticBoxSizer *item40 = new wxStaticBoxSizer( item41, wxVERTICAL );
 
     wxTreeCtrl *item42 = new wxTreeCtrl( parent, -1, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxSUNKEN_BORDER );
     item42->SetName( wxT("statTree") );
-    item40->Add( item42, 1, wxGROW|wxALIGN_CENTER_VERTICAL, 5 );
-
-    item0->Add( item40, 1, wxGROW|wxALIGN_CENTER_VERTICAL, 5 );
+    item40->Add( item42, 1, wxGROW|wxALL, 5 );
+    item0->Add( item40, 1, wxGROW|wxALL, 5 );
 
     if (set_sizer)
     {
@@ -2075,7 +2074,7 @@ wxSizer *PreferencesaMuleTweaksTab( wxWi
 
     wxStaticText *item2 = new wxStaticText( parent, -1, _("!!! WARNING !!!"), wxDefaultPosition, wxDefaultSize, 0 );
     item2->SetForegroundColour( *wxRED );
-    item2->SetFont( wxFont( 24, wxROMAN, wxNORMAL, wxNORMAL ) );
+    item2->SetFont( wxFont( 24, wxFONTFAMILY_ROMAN, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL ) );
     item1->Add( item2, 0, wxALIGN_CENTER, 5 );
 
     wxStaticText *item3 = new wxStaticText( parent, IDC_AMULE_TWEAKS_WARNING, wxT(""), wxDefaultPosition, wxDefaultSize, wxALIGN_CENTRE );
@@ -2677,11 +2676,7 @@ wxSizer *serverListDlgDown( wxWindow *pa
     wxStaticBoxSizer *item0 = new wxStaticBoxSizer( item1, wxVERTICAL );
 
     wxNotebook *item3 = new wxNotebook( parent, ID_SRVLOG_NOTEBOOK, wxDefaultPosition, wxDefaultSize, 0 );
-#if !wxCHECK_VERSION(2,5,2)
-    wxNotebookSizer *item2 = new wxNotebookSizer( item3 );
-#else
     wxWindow *item2 = item3;
-#endif
 
     wxPanel *item4 = new wxPanel( item3, -1 );
     aMuleLog( item4, FALSE );
@@ -3359,11 +3354,7 @@ wxSizer *NetDialog( wxWindow *parent, bo
     m_networknotebooksizer = item0;
 
     wxNotebook *item2 = new wxNotebook( parent, ID_NETNOTEBOOK, wxDefaultPosition, wxDefaultSize, 0 );
-#if !wxCHECK_VERSION(2,5,2)
-    wxNotebookSizer *item1 = new wxNotebookSizer( item2 );
-#else
     wxWindow *item1 = item2;
-#endif
 
     wxPanel *item3 = new wxPanel( item2, -1 );
     serverListDlgUp( item3, FALSE );
--- a/src/muuli_wdr.h
+++ b/src/muuli_wdr.h
@@ -341,9 +341,6 @@ wxSizer *ServerInfoLog( wxWindow *parent
 #define ID_DLPINFO 22001
 #define ID_BTN_RESET_DLP 22002
 wxSizer *DLPInfoLog( wxWindow *parent, bool call_fit = TRUE, bool set_sizer = TRUE );
-
-#define ID_LOGVIEW 10241
-#define ID_BTN_RESET 10242
 wxSizer *aMuleLog( wxWindow *parent, bool call_fit = TRUE, bool set_sizer = TRUE );
 
 #define ID_UPDATELIST 10244
--- a/src/NetworkFunctions.h
+++ b/src/NetworkFunctions.h
@@ -65,12 +65,12 @@ inline wxString KadIPPortToString(uint32
  * ip-address is ignored and the resulting IP is saved in
  * anti-host order.
  *
- * The reason for the existance of this function is the fact that
+ * The reason for the existence of this function is the fact that
  * the standard inet_aton function treats numbers with 0 prefixed
  * as octals, which is desirable.
  *
  * Note: The reference value will not be changed unless the string
- *       contains a valid IP adress.
+ *       contains a valid IP address.
  */
 bool	StringIPtoUint32(const wxString &strIP, uint32& Ip);
 
--- a/src/Observable.h
+++ b/src/Observable.h
@@ -38,7 +38,7 @@ template <typename TEST> class CObservab
 /**
  * This class implements the observable part of an Observer/Observable pattern.
  *
- * The EventType paramter is used to specify a protocol for the event-type used
+ * The EventType parameter is used to specify a protocol for the event-type used
  * by a particular Observer/Observable set and allows for any level of
  * information passing to be used, depending on the context.
  *
@@ -108,9 +108,9 @@ public:
 	 * This function subscribes an observer to events from this observable.
 	 *
 	 * @param o The observer that wishes to observe this object.
-	 * @return True if it succesfully subscribed, false otherwise.
+	 * @return True if it successfully subscribed, false otherwise.
 	 *
-	 * If the subscription was succesful, ObserverAdded() will be called
+	 * If the subscription was successful, ObserverAdded() will be called
 	 * on "o", allowing the subclass to initialize the the observer's state.
 	 */
 	bool AddObserver( ObserverType* o );
--- a/src/ObservableQueue.h
+++ b/src/ObservableQueue.h
@@ -140,8 +140,8 @@ private:
  * object or position, instead just a "add/remove one of these" rule.
  *
  * The main purpose of this class is to allow another class to follow
- * a list or queue, regardles of changes in actual order of the items
- * and regardles of changes to the contents.
+ * a list or queue, regardless of changes in actual order of the items
+ * and regardless of changes to the contents.
  */
 template <typename ValueType>
 class CObservableQueue : public CObservable< CQueueEvent<ValueType> >
@@ -224,7 +224,7 @@ public:
 	 * Note: Objects will not be returned in the same order as
 	 * they were found in the original observable. Also, note
 	 * that calling GetNext() on an empty queue should only be
-	 * done if the default contructed value does not match a
+	 * done if the default constructed value does not match a
 	 * valid object and can be used to check for End of Queue.
 	 */
 	ValueType GetNext();
--- a/src/OScopeCtrl.cpp
+++ b/src/OScopeCtrl.cpp
@@ -74,7 +74,7 @@ COScopeCtrl::COScopeCtrl(int cntTrends,
 	PlotData_t* ppds = pdsTrends;
 	for(unsigned i=0; i<nTrends; ++i, ++ppds){
 		ppds->crPlot = (i<15 ? crPreset[i] : *wxWHITE);
-		ppds->penPlot=*(wxThePenList->FindOrCreatePen(ppds->crPlot, 1, wxSOLID));
+		ppds->penPlot=*(wxThePenList->FindOrCreatePen(ppds->crPlot, 1, wxPENSTYLE_SOLID));
 		ppds->fPrev = ppds->fLowerLimit = ppds->fUpperLimit = 0.0;
 	}
 
@@ -166,7 +166,7 @@ void COScopeCtrl::SetPlotColor(const wxC
 	if (ppds->crPlot == cr)
 		return;
 	ppds->crPlot = cr;
-	ppds->penPlot=*(wxThePenList->FindOrCreatePen(ppds->crPlot, 1, wxSOLID));
+	ppds->penPlot=*(wxThePenList->FindOrCreatePen(ppds->crPlot, 1, wxPENSTYLE_SOLID));
 	InvalidateGraph();
 }
 
@@ -179,7 +179,7 @@ void COScopeCtrl::SetBackgroundColor(con
 	}
 
 	m_bgColour = cr;
-	brushBack= *(wxTheBrushList->FindOrCreateBrush(cr, wxSOLID));
+	brushBack= *(wxTheBrushList->FindOrCreateBrush(cr, wxBRUSHSTYLE_SOLID));
 	InvalidateCtrl() ;
 }
 
@@ -196,7 +196,7 @@ void COScopeCtrl::RecreateGrid()
 
 	wxMemoryDC dcGrid(m_bmapGrid);
 
-	wxPen solidPen = *(wxThePenList->FindOrCreatePen(m_gridColour, 1, wxSOLID));
+	wxPen solidPen = *(wxThePenList->FindOrCreatePen(m_gridColour, 1, wxPENSTYLE_SOLID));
 	wxString strTemp;
 
 	// fill the grid background
@@ -213,7 +213,7 @@ void COScopeCtrl::RecreateGrid()
 	dcGrid.SetPen(wxNullPen);
 
 	// create some fonts (horizontal and vertical)
-	wxFont axisFont(10, wxSWISS, wxNORMAL, wxNORMAL, false);
+	wxFont axisFont(10, wxFONTFAMILY_SWISS, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL, false);
 	dcGrid.SetFont(axisFont);
 
 	// y max
@@ -316,11 +316,11 @@ void COScopeCtrl::OnPaint(wxPaintEvent&
 	dc.DrawBitmap(m_bmapPlot, m_rectPlot.x, m_rectPlot.y, false);
 
 	// draw the dotted lines.
-	// This is done last because wxMAC does't support the wxOR logical
+	// This is done last because wxMAC doesn't support the wxOR logical
 	// operation, preventing us from simply blitting the plot on top of
 	// the grid bitmap.
 
-	dc.SetPen(*(wxThePenList->FindOrCreatePen(m_gridColour, 1, wxLONG_DASH)));
+	dc.SetPen(*(wxThePenList->FindOrCreatePen(m_gridColour, 1, wxPENSTYLE_LONG_DASH)));
 	for (unsigned j = 1; j < (nYGrids + 1); ++j) {
 		unsigned GridPos = (m_rectPlot.GetHeight())*j/( nYGrids + 1 ) + m_rectPlot.GetTop();
 
@@ -404,7 +404,7 @@ void COScopeCtrl::DrawPoints(const std::
 	// this appends a new set of data points to a graph; all of the plotting is
 	// directed to the memory based bitmap associated with dcPlot
 	// the will subsequently be BitBlt'd to the client in OnPaint
-	// draw the next line segement
+	// draw the next line segment
 	unsigned y, yPrev;
 	unsigned cntPixelOffset = std::min((unsigned)(m_rectPlot.GetWidth()-1), (cntPoints-1)*nShiftPixels);
 	PlotData_t* ppds = pdsTrends;
--- a/src/OtherFunctions.cpp
+++ b/src/OtherFunctions.cpp
@@ -138,7 +138,7 @@ FileType GetFiletype(const CPath& filena
 }
 
 
-// Returns the (translated) description assosiated with a FileType
+// Returns the (translated) description associated with a FileType
 wxString GetFiletypeDesc(FileType type, bool translated)
 {
 	switch ( type ) {
@@ -201,7 +201,7 @@ wxString GetFiletypeDesc(FileType type,
 	}
 }
 
-// Returns the Typename, examining the extention of the given filename
+// Returns the Typename, examining the extension of the given filename
 
 wxString GetFiletypeByName(const CPath& filename, bool translated)
 {
@@ -285,7 +285,7 @@ static wxChar base16Lookup[BASE16_LOOKUP
 //
 // [In]
 //   buffer: Pointer to byte array
-//   bufLen: Lenght of buffer array
+//   bufLen: Length of buffer array
 //
 // [Return]
 //   wxString object with BASE16 encoded byte array
@@ -306,7 +306,7 @@ wxString EncodeBase16(const unsigned cha
 //
 // [In]
 //   base16Buffer: String containing BASE16
-//   base16BufLen: Lenght BASE16 coded string's length
+//   base16BufLen: Length BASE16 coded string's length
 //
 // [Out]
 //   buffer: byte array containing decoded string
@@ -335,7 +335,7 @@ unsigned int DecodeBase16(const wxString
 //
 // [In]
 //   buffer: Pointer to byte array
-//   bufLen: Lenght of buffer array
+//   bufLen: Length of buffer array
 //
 // [Return]
 //   wxString object with BASE32 encoded byte array
@@ -373,7 +373,7 @@ wxString EncodeBase32(const unsigned cha
 //
 // [In]
 //   base32Buffer: String containing BASE32
-//   base32BufLen: Lenght BASE32 coded string's length
+//   base32BufLen: Length BASE32 coded string's length
 //
 // [Out]
 //   buffer: byte array containing decoded string
@@ -619,7 +619,7 @@ unsigned int DecodeBase64(const wxString
 }
 
 
-// Returns the text assosiated with a category type
+// Returns the text associated with a category type
 wxString GetCatTitle(AllCategoryFilter cat)
 {
 	switch (cat) {
@@ -915,7 +915,7 @@ EED2KFileType GetED2KFileTypeID(const CP
 }
 
 
-// Retuns the ed2k file type term which is to be used in server searches
+// Returns the ed2k file type term which is to be used in server searches
 wxString GetED2KFileTypeSearchTerm(EED2KFileType iFileID)
 {
 	if (iFileID == ED2KFT_AUDIO)		return ED2KFTSTR_AUDIO;
@@ -931,7 +931,7 @@ wxString GetED2KFileTypeSearchTerm(EED2K
 }
 
 
-// Returns a file type which is used eMule internally only, examining the extention of the given filename
+// Returns a file type which is used eMule internally only, examining the extension of the given filename
 wxString GetFileTypeByName(const CPath& fileName)
 {
 	EED2KFileType iFileType = GetED2KFileTypeID(fileName);
@@ -948,7 +948,7 @@ wxString GetFileTypeByName(const CPath&
 }
 
 
-// Retuns the ed2k file type integer ID which is to be used for publishing+searching
+// Returns the ed2k file type integer ID which is to be used for publishing+searching
 EED2KFileType GetED2KFileTypeSearchID(EED2KFileType iFileID)
 {
 	switch (iFileID) {
@@ -1090,10 +1090,6 @@ wxString GetConfigDir(const wxString &co
 void InitCustomLanguages()
 {
 	wxLanguageInfo info;
-
-#if !wxCHECK_VERSION(2, 9, 0)
-	CUSTOMLANGUAGE(wxLANGUAGE_ASTURIAN,	"ast",	0,	0,	wxLayout_LeftToRight,	"Asturian");
-#endif
 }
 
 
@@ -1103,12 +1099,6 @@ void InitLocale(wxLocale& locale, int la
 
 #if defined(__WXMAC__) || defined(__WINDOWS__)
 	locale.AddCatalogLookupPathPrefix(JoinPaths(wxStandardPaths::Get().GetDataDir(), wxT("locale")));
-#else
-#if (wxCHECK_VERSION(2,9,5) && !wxCHECK_VERSION(3,0,3)) || (wxCHECK_VERSION(3,1,0) && !wxCHECK_VERSION(3,1,1))
-	// Add correct place to look for catalog files if we're using a wxWidgets version where it's broken
-	// See also http://trac.wxwidgets.org/ticket/17740
-	locale.AddCatalogLookupPathPrefix(JoinPaths(JoinPaths(wxStandardPaths::Get().GetInstallPrefix(), wxT("share")), wxT("locale")));
-#endif /* wxCHECK_VERSION(2,9,5)... */
 #endif /* (!)(defined(__WXMAC__) || defined(__WINDOWS__)) */
 
 	locale.AddCatalog(wxT(PACKAGE));
--- a/src/OtherFunctions.h
+++ b/src/OtherFunctions.h
@@ -155,7 +155,7 @@ template <typename STL_CONTAINER>
 void DeleteContents(STL_CONTAINER& container)
 {
 	// Ensure that the actual container wont contain dangling pointers during
-	// this operation, to ensure that the destructors cant access them.
+	// this operation, to ensure that the destructors can't access them.
 	STL_CONTAINER copy;
 
 	std::swap(copy, container);
@@ -226,7 +226,7 @@ unsigned int DecodeBase64(const wxString
 
 // Converts the number of bytes to human readable form.
 wxString CastItoXBytes(uint64 count);
-// Converts the number to human readable form, abbreviating when nessecary.
+// Converts the number to human readable form, abbreviating when necessary.
 wxString CastItoIShort(uint64 number);
 // Converts a number of bytes to a human readable speed value.
 wxString CastItoSpeed(uint32 bytes);
@@ -240,7 +240,7 @@ wxString GetRateString(uint16 rate);
 
 // The following functions are used to identify and/or name the type of a file
 enum FileType { ftAny, ftVideo, ftAudio, ftArchive, ftCDImage, ftPicture, ftText, ftProgram };
-// Examins a filename and returns the enumerated value assosiated with it, or ftAny if unknown extension
+// Examins a filename and returns the enumerated value associated with it, or ftAny if unknown extension
 FileType GetFiletype(const CPath& filename);
 // Returns the description of a filetype: Movies, Audio, Pictures and so on...
 wxString GetFiletypeDesc(FileType type, bool translated = true);
@@ -338,11 +338,6 @@ inline long int make_full_ed2k_version(i
 
 wxString GetConfigDir(const wxString &configFile);
 
-#if !wxCHECK_VERSION(2, 9, 0)
-enum {
-	wxLANGUAGE_ASTURIAN	= wxLANGUAGE_USER_DEFINED + 1
-};
-#endif
 
 /**
  * Adds aMule's custom languages to db.
--- a/src/Packet.cpp
+++ b/src/Packet.cpp
@@ -29,7 +29,7 @@
 
 #include <protocol/Protocols.h>
 
-#include "Logger.h"			// Neeed for AddDebugLogLineN
+#include "Logger.h"			// Needed for AddDebugLogLineN
 #include "MemFile.h"			// Needed for CMemFile
 #include "OtherStructs.h"		// Needed for Header_Struct
 #include "ArchSpecific.h"		// Needed for ENDIAN_*
@@ -275,7 +275,7 @@ void CPacket::PackPacket()
 bool CPacket::UnPackPacket(uint32 uMaxDecompressedSize) {
 	wxASSERT( prot == OP_PACKEDPROT || prot == OP_ED2KV2PACKEDPROT);
 	// OP_ED2KV2PACKEDPROT is experimental aMule test code,
-	// this should not happen yet. Leave a warining in the log.
+	// this should not happen yet. Leave a warning in the log.
 	if (prot == OP_ED2KV2PACKEDPROT) {
 		AddDebugLogLineN(logPacketErrors,
 			wxT("Received OP_ED2KV2PACKEDPROT."));
--- a/src/PartFileConvertDlg.cpp
+++ b/src/PartFileConvertDlg.cpp
@@ -203,7 +203,7 @@ void CPartFileConvertDlg::OnAddFolder(wx
 		wxStandardPaths::Get().GetDocumentsDir(), wxDD_DEFAULT_STYLE,
 		wxDefaultPosition, this);
 	if (!folder.IsEmpty()) {
-		int reply = wxMessageBox(_("Do you want the source files of succesfully imported downloads be deleted?"),
+		int reply = wxMessageBox(_("Do you want the source files of successfully imported downloads be deleted?"),
 					 _("Remove sources?"),
 					 wxYES_NO | wxCANCEL | wxICON_QUESTION, this);
 		if (reply != wxCANCEL) {
--- a/src/PartFile.cpp
+++ b/src/PartFile.cpp
@@ -36,11 +36,10 @@
 
 #include <wx/utils.h>
 #include <wx/tokenzr.h>		// Needed for wxStringTokenizer
-#if wxCHECK_VERSION(2,9,0)
+
 #ifndef AMULE_DAEMON
 #include <wx/notifmsg.h>	// Needed for wxNotificationMessage
 #endif
-#endif
 
 #include "KnownFileList.h"	// Needed for CKnownFileList
 #include "CanceledFileList.h"
@@ -471,7 +470,7 @@ uint8 CPartFile::LoadPartFile(const CPat
 					case FT_KADLASTPUBLISHSRC:{
 						SetLastPublishTimeKadSrc(newtag.GetInt(), 0);
 						if(GetLastPublishTimeKadSrc() > (uint32)time(NULL)+KADEMLIAREPUBLISHTIMES) {
-							//There may be a posibility of an older client that saved a random number here.. This will check for that..
+							//There may be a possibility of an older client that saved a random number here.. This will check for that..
 							SetLastPublishTimeKadSrc(0,0);
 						}
 						break;
@@ -803,7 +802,7 @@ bool CPartFile::SavePartFile(bool Initia
 
 		file.WriteUInt32(tagcount);
 
-		//#warning Kry - Where are lost by coruption and gained by compression?
+		//#warning Kry - Where are lost by corruption and gained by compression?
 
 		// 0 (unicoded part file name)
 		// We write it with BOM to keep eMule compatibility. Note that the 'printable' filename is saved,
@@ -839,7 +838,7 @@ bool CPartFile::SavePartFile(bool Initia
 		CTagInt32(FT_ATREQUESTED,    statistic.GetAllTimeRequests()).WriteTagToFile( &file );	// 13
 		CTagInt32(FT_ATACCEPTED,     statistic.GetAllTimeAccepts()).WriteTagToFile( &file );	// 14
 
-		// currupt part infos
+		// corrupt part infos
 		if (!m_corrupted_list.empty()) {
 			wxString strCorruptedParts;
 			std::list<uint16>::iterator it = m_corrupted_list.begin();
@@ -1868,7 +1867,7 @@ bool CPartFile::GetNextRequestedBlock(CU
 	// This algorithm usually selects first the rarest chunk(s). However, partially
 	// complete chunk(s) that is/are close to completion may overtake the priority
 	// (priority inversion).
-	// For the common chuncks, the algorithm tries to spread the dowload between
+	// For the common chunks, the algorithm tries to spread the download between
 	// the sources
 	//
 
@@ -1883,7 +1882,7 @@ bool CPartFile::GetNextRequestedBlock(CU
 	// Main loop
 	uint16 newBlockCount = 0;
 	while(newBlockCount != count) {
-		// Create a request block stucture if a chunk has been previously selected
+		// Create a request block structure if a chunk has been previously selected
 		if(sender->GetLastPartAsked() != 0xffff) {
 			Requested_Block_Struct* pBlock = new Requested_Block_Struct;
 			if(GetNextEmptyBlockInPart(sender->GetLastPartAsked(), pBlock) == true) {
@@ -1907,7 +1906,7 @@ bool CPartFile::GetNextRequestedBlock(CU
 			// Quantify all chunks (create list of chunks to download)
 			// This is done only one time and only if it is necessary (=> CPU load)
 			if(chunksList.empty()) {
-				// Indentify the locally missing part(s) that this source has
+				// Identify the locally missing part(s) that this source has
 				for(uint16 i=0; i < partCount; ++i) {
 					if(sender->IsPartAvailable(i) == true && GetNextEmptyBlockInPart(i, NULL) == true) {
 						// Create a new entry for this chunk and add it to the list
@@ -1918,7 +1917,7 @@ bool CPartFile::GetNextRequestedBlock(CU
 					}
 				}
 
-				// Check if any bloks(s) could be downloaded
+				// Check if any blocks(s) could be downloaded
 				if(chunksList.empty()) {
 					break; // Exit main loop while()
 				}
@@ -2019,7 +2018,7 @@ bool CPartFile::GetNextRequestedBlock(CU
 
 			// Select the next chunk to download
 			if(!chunksList.empty()) {
-				// Find and count the chunck(s) with the highest priority
+				// Find and count the chunk(s) with the highest priority
 				uint16 chunkCount = 0; // Number of found chunks with same priority
 				uint16 rank = 0xffff; // Highest priority found
 
@@ -2105,7 +2104,7 @@ void CPartFile::CompleteFile(bool bIsHas
 		StopFile();
 		m_is_A4AF_auto=false;
 		SetStatus(PS_COMPLETING);
-		// guess I was wrong about not need to spaw a thread ...
+		// guess I was wrong about not need to spawn a thread ...
 		// It is if the temp and incoming dirs are on different
 		// partitions/drives and the file is large...[oz]
 		//
@@ -2164,7 +2163,6 @@ void CPartFile::CompleteFileEnded(bool e
 		m_CorruptionBlackBox->Free();
 
 		AddLogLineC(CFormat( _("Finished downloading: %s") ) % GetFileName() );
-#if wxCHECK_VERSION(2,9,0)
 #ifndef AMULE_DAEMON
 		if (thePrefs::ShowNotifications()) {
 			wxNotificationMessage *notification = new wxNotificationMessage ();
@@ -2175,7 +2173,6 @@ void CPartFile::CompleteFileEnded(bool e
 			delete notification;
 		}
 #endif
-#endif
 	}
 
 	theApp->downloadqueue->StartNextFile(this);
@@ -2501,7 +2498,7 @@ bool CPartFile::CheckFreeDiskSpace( uint
 	if ( thePrefs::IsCheckDiskspaceEnabled() ) {
 		neededSpace += thePrefs::GetMinFreeDiskSpace();
 
-		// Due to the the existance of sparse files, we cannot assume that
+		// Due to the the existence of sparse files, we cannot assume that
 		// writes within the file doesn't cause new blocks to be allocated.
 		// Therefore, we have to simply stop writing the moment the limit has
 		// been exceeded.
@@ -2731,7 +2728,7 @@ void CPartFile::AddClientSources(CMemFil
 	} else {
 		// for SX2:
 		// We only check if the version is known by us and do a quick sanitize check on known version
-		// other then SX1, the packet will be ignored if any error appears, sicne it can't be a "misunderstanding" anymore
+		// other then SX1, the packet will be ignored if any error appears, since it can't be a "misunderstanding" anymore
 		if (uClientSXVersion > SOURCEEXCHANGE2_VERSION || uClientSXVersion == 0 ){
 			AddDebugLogLineN(logPartFile, CFormat(wxT("Invalid source exchange type version: %i")) % uClientSXVersion);
 			return;
--- a/src/PartFile.h
+++ b/src/PartFile.h
@@ -232,9 +232,9 @@ public:
 	bool	DelSource( CUpDownClient* client );
 
 	/**
-	 * Updates the requency of avilable parts from with the data the client provides.
+	 * Updates the frequency of available parts from with the data the client provides.
 	 *
-	 * @param client The clients whoose available parts should be considered.
+	 * @param client The clients whose available parts should be considered.
 	 * @param increment If true, the counts are incremented, otherwise they are decremented.
 	 *
 	 * This functions updates the frequency list of file-parts, using the clients
--- a/src/PlatformSpecific.h
+++ b/src/PlatformSpecific.h
@@ -63,7 +63,7 @@ enum EFSType {
 	fsFAT,		//! File Allocation Table
 	fsNTFS,		//! New Technology File System
 	fsHFS,		//! Hierarchical File System
-	fsHPFS,		//! High Performace File System
+	fsHPFS,		//! High Performance File System
 	fsMINIX,	//! Minix file system
 	fsOther		//! Unknown, other
 };
--- a/src/PrefsUnifiedDlg.cpp
+++ b/src/PrefsUnifiedDlg.cpp
@@ -524,11 +524,6 @@ bool PrefsUnifiedDlg::TransferToWindow()
 	FindWindow(IDC_WEBUPNPTCPPORTTEXT)->Enable(thePrefs::GetUPnPWebServerEnabled());
 #endif
 
-#if !wxCHECK_VERSION(2,9,0)
-	CastChild(IDC_NOTIF, wxCheckBox)->SetValue(false);
-	FindWindow(IDC_NOTIF)->Enable(false);
-#endif
-
 #ifdef __DEBUG__
 	// Set debugging toggles
 	int count = theLogger.GetDebugCategoryCount();
--- a/src/Proxy.cpp
+++ b/src/Proxy.cpp
@@ -188,7 +188,7 @@ bool CProxyStateMachine::Start(const amu
 	//	const wxIPV4address &peer = dynamic_cast<const wxIPV4address &>(peerAddress);
 	//	m_peerAddress = new amuleIPV4Address(peer);
 	//} catch (const std::bad_cast& WXUNUSED(e)) {
-	//	// Should process other types of wxIPAddres before quitting
+	//	// Should process other types of wxIPAddress before quitting
 	//	AddDebugLogLineN(logProxy, wxT("(1)bad_cast exception!"));
 	//	wxFAIL;
 	//	return false;
@@ -265,7 +265,7 @@ void CProxyStateMachine::AddDummyEvent()
 
 void CProxyStateMachine::ReactivateSocket()
 {
-	/*    If proxy is beeing used, then the TCP socket handlers
+	/*    If proxy is being used, then the TCP socket handlers
 	 * (CServerSocketHandler and CClientTCPSocketHandler) will not
 	 * receive a wxSOCKET_CONNECTION event, because the connection has
 	 * already started with the proxy. So we must add a wxSOCKET_CONNECTION
--- a/src/RangeMap.h
+++ b/src/RangeMap.h
@@ -33,7 +33,7 @@
 
 
 /**
- * Default helper structure for normal CRangeMap instantations.
+ * Default helper structure for normal CRangeMap instantiations.
  *
  * Specializations should must have the following properties.
  *  - The four value typedefs (see comments for details).
@@ -107,7 +107,7 @@ struct CRangeMapHelper<void, KEYTYPE>
  * than by erasing and then re-inserting them.
  *
  * A specialization of this class exists (typedef'd as CRangeSet), which does
- * not assosiate a value with each range.
+ * not associate a value with each range.
  *
  * NOTE: KEYTYPE is assumed to be an unsigned integer type!
  */
@@ -352,7 +352,7 @@ public:
 	 * @param key A value that may or may not be covered by a range.
 	 * @return end() or the iterator of the range covering key.
 	 *
-	 * A range is considered to cover a value if the value is greather than or
+	 * A range is considered to cover a value if the value is greater than or
 	 * equal to the start-key and less than or equal to the end-key.
 	 */
 	// Find the range which contains key (it->first <= key <= it->second->first)
@@ -395,7 +395,7 @@ public:
 	 *
 	 * @param startPos The start position of the range, also considered part of the range.
 	 * @param endPos The end position of the range, also considered part of the range.
-	 * @param object The user-data to be assosiated with the range.
+	 * @param object The user-data to be associated with the range.
 	 * @return An iterator pointing to the resulting range, covering at least the specified range.
 	 *
 	 * This function inserts the specified range into the map, while overwriting
@@ -531,7 +531,7 @@ protected:
 	 * Finds the optimal location to start looking for insertion points.
 	 *
 	 * This is the first range whose start comes after the new start. We check
-	 * the last element first, since sequential insertions are commen.
+	 * the last element first, since sequential insertions are common.
 	 */
 	RangeIterator get_insert_it(KEYTYPE start)
 	{
--- a/src/RC4Encrypt.cpp
+++ b/src/RC4Encrypt.cpp
@@ -47,7 +47,7 @@ void CRC4EncryptableBuffer::Append(const
 	} else {
 		throw std::runtime_error(
 			"(CRC4EncryptableBuffer::Append): "
-			"Tryed to append data to an encrypted buffer.");
+			"Tried to append data to an encrypted buffer.");
 	}
 }
 
--- a/src/RLE.cpp
+++ b/src/RLE.cpp
@@ -235,7 +235,7 @@ const uint8 * RLE_Data::Encode(const Arr
 {
 	// uint64 is copied to a uint8 buffer
 	// first all low bytes, then all second low bytes and so on
-	// so inital RLE will benefit from high bytes being equal (zero)
+	// so initial RLE will benefit from high bytes being equal (zero)
 	// 0x000003045A6A7A8A, 0x000003045B6B7B8B
 	// 8A8B7A7B6A6B5A5B0404030300000000
 	int size = (int) data.size();
--- a/src/RLE.h
+++ b/src/RLE.h
@@ -68,7 +68,7 @@ private:
 	// data:	block to encode
 	// inlen:	number of bytes to encode. May be zero, then data can also be 0.
 	// outlen:	here the number of encoded bytes gets stored (0 if inlen is 0)
-	// changed:	becomes true if the size has changed or a change in the data occured,
+	// changed:	becomes true if the size has changed or a change in the data occurred,
 	//          so the differential data (before encoding) is not all zero
 	//
 	// return:	new buffer with encoded data, must be deleted after use!
--- a/src/SafeFile.cpp
+++ b/src/SafeFile.cpp
@@ -407,7 +407,7 @@ CTag *CFileDataIO::ReadTag(bool bOptACP)
 			// NOTE: This tag data type is accepted and stored only to give us the possibility to upgrade
 			// the net in some months.
 			//
-			// And still.. it doesnt't work this way without breaking backward compatibility. To properly
+			// And still.. it doesn't work this way without breaking backward compatibility. To properly
 			// do this without messing up the network the following would have to be done:
 			//	 -	those tag types have to be ignored by any client, otherwise those tags would also be sent (and
 			//		that's really the problem)
@@ -456,7 +456,7 @@ CTag *CFileDataIO::ReadTag(bool bOptACP)
 			// NOTE: This tag data type is accepted and stored only to give us the possibility to upgrade
 			// the net in some months.
 			//
-			// And still.. it doesnt't work this way without breaking backward compatibility
+			// And still.. it doesn't work this way without breaking backward compatibility
 			case TAGTYPE_BSOB:
 			{
 				uint8 size = 0;
--- a/src/SafeFile.h
+++ b/src/SafeFile.h
@@ -103,7 +103,7 @@ public:
 	 * the position and target buffer is left unchanged.
 	 *
 	 * However, it is also possible that the read will
-	 * fail due to IO errors (bad hardware, ect), in which
+	 * fail due to IO errors (bad hardware, etc), in which
 	 * case an CIOFailureException will be thrown.
 	 */
 	virtual void Read(void* buffer, size_t count) const;
@@ -147,7 +147,7 @@ public:
 	 * @return The resulting text-string.
 	 *
 	 * Note that when SafeRead is set to true, CSafeFileIO will crop the length
-	 * read from the lenght-field (see lenBytes), so that at most GetLength() -
+	 * read from the length-field (see lenBytes), so that at most GetLength() -
 	 * GetPosition() bytes are read.
 	 *
 	 * @see CSafeFileIO::Read
@@ -226,7 +226,7 @@ protected:
 	 * Note that the return value must be the actual number of bytes
 	 * read or written, with the exception that in case of errors, -1
 	 * may be returned. This is because the return value is used to
-	 * detect if the operation succeded.
+	 * detect if the operation succeeded.
 	 *
 	 * This function should not throw Either of the CSafeIOExceptions,
 	 * this is done by the CSafeFileIO::Read and the CSafeFileIO::Write
--- a/src/SearchFile.h
+++ b/src/SearchFile.h
@@ -92,7 +92,7 @@ public:
 	 * Merges the two results into one.
 	 *
 	 * Merges the other result into this one, updating
-	 * various informations.
+	 * various information.
 	 *
 	 * @param other The file to be merged into this.
 	 */
--- a/src/SearchList.cpp
+++ b/src/SearchList.cpp
@@ -290,7 +290,7 @@ CSearchList::~CSearchList()
 
 void CSearchList::RemoveResults(long searchID)
 {
-	// A non-existant search id will just be ignored
+	// A non-existent search id will just be ignored
 	Kademlia::CSearchManager::StopSearch(searchID, true);
 
 	ResultMap::iterator it = m_results.find(searchID);
@@ -584,7 +584,7 @@ bool CSearchList::AddToList(CSearchFile*
 	}
 
 
-	// Get, or implictly create, the map of results for this search
+	// Get, or implicitly create, the map of results for this search
 	CSearchResultList& results = m_results[toadd->GetSearchID()];
 
 	for (size_t i = 0; i < results.size(); ++i) {
@@ -725,7 +725,7 @@ CSearchList::CMemFilePtr CSearchList::Cr
 
 	unsigned int iParameterCount = 0;
 	if (_SearchExpr.m_aExpr.GetCount() <= 1) {
-		// lugdunummaster requested that searchs without OR or NOT operators,
+		// lugdunummaster requested that searches without OR or NOT operators,
 		// and hence with no more expressions than the string itself, be sent
 		// using a series of ANDed terms, intersecting the ANDs on the terms
 		// (but prepending them) instead of putting the boolean tree at the start
--- a/src/SearchListCtrl.cpp
+++ b/src/SearchListCtrl.cpp
@@ -90,7 +90,7 @@ m_filterEnabled(false)
 	InsertColumn( ID_SEARCH_COL_TYPE,    _("Type"),      wxLIST_FORMAT_LEFT,  65, wxT("Y") );
 	InsertColumn( ID_SEARCH_COL_FILEID,  _("FileID"),    wxLIST_FORMAT_LEFT, 280, wxT("I") );
 	InsertColumn( ID_SEARCH_COL_STATUS,  _("Status"),    wxLIST_FORMAT_LEFT, 100, wxT("S") );
-	InsertColumn( ID_SEARCH_COL_DIRECTORY,  _("Directories"),    wxLIST_FORMAT_LEFT, 280, wxT("D") );  // I would have prefered "Directory" but this is already translated
+	InsertColumn( ID_SEARCH_COL_DIRECTORY,  _("Directories"),    wxLIST_FORMAT_LEFT, 280, wxT("D") );  // I would have preferred "Directory" but this is already translated
 
 	m_nResultsID = 0;
 
@@ -471,7 +471,7 @@ int CSearchListCtrl::SortProc(wxUIntPtr
 	CSearchFile* file1 = reinterpret_cast<CSearchFile*>(item1);
 	CSearchFile* file2 = reinterpret_cast<CSearchFile*>(item2);
 
-	// Modifies the result, 1 for ascending, -1 for decending
+	// Modifies the result, 1 for ascending, -1 for descending
 	int modifier = (sortData & CMuleListCtrl::SORT_DES) ? -1 : 1;
 	bool alternate = (sortData & CMuleListCtrl::SORT_ALT) != 0;
 
@@ -516,7 +516,7 @@ int CSearchListCtrl::SortProc(wxUIntPtr
 			int cmp2 = CmpAny( file1->GetCompleteSourceCount(), file2->GetCompleteSourceCount() );
 
 			if ( alternate ) {
-				// Swap criterias
+				// Swap criteria
 				int temp = cmp2;
 				cmp2 = cmp;
 				cmp = temp;
@@ -826,7 +826,7 @@ void CSearchListCtrl::OnDrawItem(
 
 	// Define the border of the drawn area
 	if (highlighted) {
-		dc->SetPen(*(wxThePenList->FindOrCreatePen(CMuleColour(dc->GetBackground().GetColour()).Blend(65), 1, wxSOLID)));
+		dc->SetPen(*(wxThePenList->FindOrCreatePen(CMuleColour(dc->GetBackground().GetColour()).Blend(65), 1, wxPENSTYLE_SOLID)));
 	} else {
 		dc->SetPen(*wxTRANSPARENT_PEN);
 		dc->SetTextForeground(GetItemTextColour(item));
@@ -912,7 +912,7 @@ void CSearchListCtrl::OnDrawItem(
 		const int middle = cur_rec.y + ( cur_rec.height + 1 ) / 2;
 
 		// Set up a new pen for drawing the tree
-		dc->SetPen( *(wxThePenList->FindOrCreatePen(dc->GetTextForeground(), 1, wxSOLID)) );
+		dc->SetPen( *(wxThePenList->FindOrCreatePen(dc->GetTextForeground(), 1, wxPENSTYLE_SOLID)) );
 
 		if (file->GetParent()) {
 			// Draw the line to the filename
--- a/src/SearchListCtrl.h
+++ b/src/SearchListCtrl.h
@@ -72,7 +72,7 @@ public:
 	virtual ~CSearchListCtrl();
 
 	/**
-	 * Adds ths specified file to the list.
+	 * Adds the specified file to the list.
 	 *
 	 * @param The new result to be shown.
 	 *
@@ -213,7 +213,7 @@ protected:
 	 * @param src The source list.
 	 * @param dst The list to be synced with the source list.
 	 *
-	 * This function syncronises the following settings of two lists:
+	 * This function synchronises the following settings of two lists:
 	 *  - Sort column
 	 *  - Sort direction
 	 *  - Column widths
--- a/src/SearchList.h
+++ b/src/SearchList.h
@@ -59,7 +59,7 @@ public:
 	//! Structure used to pass search-parameters.
 	struct CSearchParams
 	{
-		/** Prevents accidential use of uninitialized variables. */
+		/** Prevents accidental use of uninitialized variables. */
 		CSearchParams() { minSize = maxSize = availability = 0; }
 
 		//! The actual string to search for.
@@ -74,7 +74,7 @@ public:
 		uint64_t minSize;
 		//! The largest filesize in bytes to accept, zero for any.
 		uint64_t maxSize;
-		//! The minumum available (source-count), zero for any.
+		//! The minimum available (source-count), zero for any.
 		uint32_t availability;
 	};
 
--- a/src/ServerConnect.cpp
+++ b/src/ServerConnect.cpp
@@ -175,7 +175,7 @@ void CServerConnect::StopConnectionTry()
 	  m_idRetryTimer.Stop();
 	}
 
-	// close all currenty opened sockets except the one which is connected to our current server
+	// close all currently opened sockets except the one which is connected to our current server
 	for(SocketsList::iterator it = m_lstOpenSockets.begin(); it != m_lstOpenSockets.end(); ) {
 		CServerSocket *pSck = *it++;
 		if (pSck == connectedsocket)		// don't destroy socket which is connected to server
@@ -209,7 +209,7 @@ void CServerConnect::ConnectionEstablish
 
 		CMemFile data(256);
 		data.WriteHash(thePrefs::GetUserHash());
-		// Why pass an ID, if we are loggin in?
+		// Why pass an ID, if we are logging in?
 		data.WriteUInt32(GetClientID());
 		data.WriteUInt16(thePrefs::GetPort());
 		data.WriteUInt32(4); // tagcount
@@ -522,7 +522,7 @@ CServerConnect::CServerConnect(CServerLi
 	m_recurseTryAnotherConnectionrequest = false;
 	m_bTryObfuscated = thePrefs::IsServerCryptLayerTCPRequested();
 
-	// initalize socket for udp packets
+	// initialize socket for udp packets
 	if (thePrefs::GetNetworkED2K()) {
 		serverudpsocket = new CServerUDPSocket(address, thePrefs::GetProxyData());
 	} else {
@@ -600,11 +600,11 @@ void CServerConnect::KeepConnectionAlive
 		AddLogLineC(wxT("Client: OP_OFFERFILES"));
 		#endif
 		// compress packet
-		//   - this kind of data is highly compressable (N * (1 MD4 and at least 3 string meta data tags and 1 integer meta data tag))
+		//   - this kind of data is highly compressible (N * (1 MD4 and at least 3 string meta data tags and 1 integer meta data tag))
 		//   - the min. amount of data needed for one published file is ~100 bytes
 		//   - this function is called once when connecting to a server and when a file becomes shareable - so, it's called rarely.
 		//   - if the compressed size is still >= the original size, we send the uncompressed packet
-		// therefor we always try to compress the packet
+		// therefore we always try to compress the packet
 		theStats::AddUpOverheadServer(packet->GetPacketSize());
 		connectedsocket->SendPacket(packet,true);
 
--- a/src/ServerList.cpp
+++ b/src/ServerList.cpp
@@ -46,7 +46,7 @@
 #include "Preferences.h"		// Needed for thePrefs
 #include "amule.h"			// Needed for theApp
 #include "Statistics.h"			// Needed for theStats
-#include "Packet.h"			// Neeed for CPacket
+#include "Packet.h"			// Needed for CPacket
 #include "Logger.h"
 #include "ScopedPtr.h"
 #include <common/Format.h>
@@ -284,10 +284,10 @@ void CServerList::ServerStats()
 		}
 
 		srand((unsigned)time(NULL));
-		ping_server->SetRealLastPingedTime(tNow); // this is not used to calcualte the next ping, but only to ensure a minimum delay for premature pings
+		ping_server->SetRealLastPingedTime(tNow); // this is not used to calculate the next ping, but only to ensure a minimum delay for premature pings
 		if (!ping_server->GetCryptPingReplyPending() && (!ping_server->GetLastPingedTime() || (tNow - ping_server->GetLastPingedTime()) >= UDPSERVSTATREASKTIME) && theApp->GetPublicIP() && thePrefs::IsServerCryptLayerUDPEnabled()) {
 			// We try a obfsucation ping first and wait 20 seconds for an answer
-			// if it doesn't get responsed, we don't count it as error but continue with a normal ping
+			// if it doesn't get responded to, we don't count it as error but continue with a normal ping
 			ping_server->SetCryptPingReplyPending(true);
 			uint32 nPacketLen = 4 + (uint8)(rand() % 16); // max padding 16 bytes
 			CScopedArray<uint8_t> pRawPacket(nPacketLen);
--- a/src/ServerListCtrl.cpp
+++ b/src/ServerListCtrl.cpp
@@ -172,7 +172,7 @@ void CServerListCtrl::RemoveAllServers(i
 
 void CServerListCtrl::RefreshServer( CServer* server )
 {
-	// Cant really refresh a NULL server
+	// Can't really refresh a NULL server
 	if (!server) {
 		return;
 	}
@@ -300,7 +300,7 @@ void CServerListCtrl::RefreshServer( CSe
 
 	#endif
 
-	// Deletions of items causes rather large ammount of flicker, so to
+	// Deletions of items causes rather large amount of flicker, so to
 	// avoid this, we resort the list to ensure correct ordering.
 	if (!IsItemSorted(itemnr)) {
 		SortList();
@@ -327,7 +327,7 @@ void CServerListCtrl::HighlightServer( c
 			wxFont font = GetFont();
 
 			if ( highlight ) {
-				font.SetWeight( wxBOLD );
+				font.SetWeight( wxFONTWEIGHT_BOLD );
 
 				m_connected = server;
 			}
--- a/src/ServerSocket.cpp
+++ b/src/ServerSocket.cpp
@@ -335,7 +335,7 @@ bool CServerSocket::ProcessPacket(const
 					if (size >= 4+4 /* uint32 (ID) + uint32 (TCP flags)*/) {
 						cur_server->SetTCPFlags(data.ReadUInt32());
 						if (size >= 4+4+4 /* uint32 (ID) + uint32 (TCP flags) + uint32 (aux port) */) {
-							// aux port login : we should use the 'standard' port of this server to advertize to other clients
+							// aux port login : we should use the 'standard' port of this server to advertise to other clients
 							ConnPort = data.ReadUInt32();
 							cur_server->SetPort(ConnPort);
 							if (cur_server->GetAuxPortsList().IsEmpty()) {
@@ -464,7 +464,7 @@ bool CServerSocket::ProcessPacket(const
 			}
 			case OP_SERVERSTATUS: {
 				AddDebugLogLineN(logServer, wxT("Server: OP_SERVERSTATUS"));
-				// FIXME some statuspackets have a different size -> why? structur?
+				// FIXME some statuspackets have a different size -> why? structure?
 				if (size < 8) {
 					throw wxString(wxT("Invalid server status packet"));
 				}
--- a/src/ServerUDPSocket.cpp
+++ b/src/ServerUDPSocket.cpp
@@ -115,7 +115,7 @@ void CServerUDPSocket::ProcessPacket(CMe
 
 	try {
 		// Imported: OP_GLOBSEARCHRES, OP_GLOBFOUNDSOURCES & OP_GLOBSERVSTATRES
-		// This makes Server UDP Flags to be set correctly so we use less bandwith on asking servers for sources
+		// This makes Server UDP Flags to be set correctly so we use less bandwidth on asking servers for sources
 		// Also we process Search results and Found sources correctly now on 16.40 behaviour.
 		switch(opcode){
 			case OP_GLOBSEARCHRES: {
@@ -262,7 +262,7 @@ void CServerUDPSocket::ProcessPacket(CMe
 				// old packet: <name_len 2><name name_len><desc_len 2 desc_en>
 				// new packet: <challenge 4><taglist>
 				//
-				// NOTE: To properly distinguish between the two packets which are both useing the same opcode...
+				// NOTE: To properly distinguish between the two packets which are both using the same opcode...
 				// the first two bytes of <challenge> (in network byte order) have to be an invalid <name_len> at least.
 
 				uint16 Len = packet.ReadUInt16();
@@ -359,7 +359,7 @@ void CServerUDPSocket::SendPacket(CPacke
 	}
 
 	// 4 (default) for standard sending, 12 for obfuscated ping, that's all for now.
-	// Might be changed if encrypted bellow, so don't move it.
+	// Might be changed if encrypted below, so don't move it.
 	item.port = host->GetPort() + port_offset;
 
 	// We might need to encrypt the packet for this server.
--- a/src/SHA.cpp
+++ b/src/SHA.cpp
@@ -74,7 +74,7 @@ CSHA::CSHA()
     To obtain the highest speed on processors with 32-bit words, this code
     needs to determine the order in which bytes are packed into such words.
     The following block of code is an attempt to capture the most obvious
-    ways in which various environemnts specify their endian definitions.
+    ways in which various environments specify their endian definitions.
     It may well fail, in which case the definitions will need to be set by
     editing at the points marked **** EDIT HERE IF NECESSARY **** below.
 */
@@ -184,7 +184,7 @@ void CSHA::Add(const void* pData, uint32
     if((m_nCount[0] += nLength) < nLength)
         ++(m_nCount[1]);
 
-    while(nLength >= space)     /* tranfer whole blocks while possible  */
+    while(nLength >= space)     /* transfer whole blocks while possible  */
     {
         memcpy(((unsigned char*)m_nBuffer) + pos, sp, space);
         sp += space; nLength -= space; space = SHA1_BLOCK_SIZE; pos = 0;
--- a/src/SHAHashSet.cpp
+++ b/src/SHAHashSet.cpp
@@ -106,7 +106,7 @@ CAICHHashTree* CAICHHashTree::FindHash(u
 		// this is the searched hash
 		return this;
 	} else if (m_nDataSize <= m_nBaseSize) { // sanity
-		// this is already the last level, cant go deeper
+		// this is already the last level, can't go deeper
 		wxFAIL;
 		return NULL;
 	} else {
@@ -276,10 +276,10 @@ bool CAICHHashTree::CreatePartRecoveryDa
 
 	if (nStartPos == 0 && nSize == m_nDataSize) {
 		// this is the searched part, now write all blocks of this part
-		// hashident for this level will be adjsuted by WriteLowestLevelHash
+		// hashident for this level will be adjusted by WriteLowestLevelHash
 		return WriteLowestLevelHashs(fileDataOut, wHashIdent, false, b32BitIdent);
 	} else if (m_nDataSize <= m_nBaseSize) { // sanity
-		// this is already the last level, cant go deeper
+		// this is already the last level, can't go deeper
 		wxFAIL;
 		return false;
 	} else {
@@ -415,7 +415,7 @@ bool CAICHHashTree::SetHash(CFileDataIO*
 		m_bHashValid = true;
 		return true;
 	} else if (m_nDataSize <= m_nBaseSize) { // sanity
-		// this is already the last level, cant go deeper
+		// this is already the last level, can't go deeper
 		wxFAIL;
 		return false;
 	} else {
@@ -551,7 +551,7 @@ bool CAICHHashSet::ReadRecoveryData(uint
 	// read hashs with 16 bit identifier
 	uint16 nHashsAvailable = fileDataIn->ReadUInt16();
 	if (fileDataIn->GetLength()-fileDataIn->GetPosition() < nHashsToRead*(HASHSIZE+2u) || (nHashsToRead != nHashsAvailable && nHashsAvailable != 0)) {
-		// this check is redunant, CSafememfile would catch such an error too
+		// this check is redundant, CSafememfile would catch such an error too
 		AddDebugLogLineN(logSHAHashSet,
 			CFormat(wxT("Failed to read RecoveryData for '%s' - Received datasize/amounts of hashs was invalid"))
 				% m_pOwner->GetFileName());
@@ -575,7 +575,7 @@ bool CAICHHashSet::ReadRecoveryData(uint
 	if (nHashsAvailable == 0 && fileDataIn->GetLength() - fileDataIn->GetPosition() >= 2) {
 		nHashsAvailable = fileDataIn->ReadUInt16();
 		if (fileDataIn->GetLength()-fileDataIn->GetPosition() < nHashsToRead*(HASHSIZE+4u) || (nHashsToRead != nHashsAvailable && nHashsAvailable != 0)) {
-			// this check is redunant, CSafememfile would catch such an error too
+			// this check is redundant, CSafememfile would catch such an error too
 // TODO:			theApp->QueueDebugLogLine(/*DLP_VERYHIGH,*/ false, _T("Failed to read RecoveryData for %s - Received datasize/amounts of hashs was invalid (2)"), m_pOwner->GetFileName() );
 			return false;
 		}
@@ -684,13 +684,13 @@ bool CAICHHashSet::SaveHashSet()
 		}
 		file.WriteUInt32(nHashCount);
 		if (!m_pHashTree.WriteLowestLevelHashs(&file, 0, true, true)) {
-			// thats bad... really
+			// that's bad... really
 			file.SetLength(nExistingSize);
 			AddDebugLogLineC(logSHAHashSet, wxT("Failed to save HashSet: WriteLowestLevelHashs() failed!"));
 			return false;
 		}
 		if (file.GetLength() != nExistingSize + (nHashCount+1)*HASHSIZE + 4) {
-			// thats even worse
+			// that's even worse
 			file.SetLength(nExistingSize);
 			AddDebugLogLineC(logSHAHashSet, wxT("Failed to save HashSet: Calculated and real size of hashset differ!"));
 			return false;
@@ -778,7 +778,7 @@ bool CAICHHashSet::LoadHashSet()
 	return false;
 }
 
-// delete the hashset except the masterhash (we dont keep aich hashsets in memory to save ressources)
+// delete the hashset except the masterhash (we dont keep aich hashsets in memory to save resources)
 void CAICHHashSet::FreeHashSet()
 {
 	if (m_pHashTree.m_pLeftTree) {
--- a/src/SharedFileList.cpp
+++ b/src/SharedFileList.cpp
@@ -740,11 +740,11 @@ void CSharedFileList::SendListToServer()
 
 	CPacket* packet = new CPacket(files, OP_EDONKEYPROT, OP_OFFERFILES);
 	// compress packet
-	//   - this kind of data is highly compressable (N * (1 MD4 and at least 3 string meta data tags and 1 integer meta data tag))
+	//   - this kind of data is highly compressible (N * (1 MD4 and at least 3 string meta data tags and 1 integer meta data tag))
 	//   - the min. amount of data needed for one published file is ~100 bytes
 	//   - this function is called once when connecting to a server and when a file becomes shareable - so, it's called rarely.
 	//   - if the compressed size is still >= the original size, we send the uncompressed packet
-	// therefor we always try to compress the packet
+	// therefore we always try to compress the packet
 	if (server->GetTCPFlags() & SRV_TCPFLG_COMPRESSION){
 		packet->PackPacket();
 	}
@@ -1008,7 +1008,7 @@ wxString CSharedFileList::GetPublicShare
 		wxASSERT( strPublicName.GetChar(0) == cPathSepa );
 		strPublicName = strPublicName.Right(strPublicName.Length() - 1);
 	} else {
-		// must be a rootdirectory on Windos
+		// must be a rootdirectory on Windows
 		wxASSERT( strDirectoryTmp.Length() == 2 );
 		strPublicName = strDirectoryTmp;
 	}
--- a/src/SharedFilesWnd.cpp
+++ b/src/SharedFilesWnd.cpp
@@ -150,7 +150,7 @@ void CSharedFilesWnd::SelectionUpdated()
 			m_bar_requests->SetValue( 0 );
 			CastChild(IDC_SREQUESTED, wxStaticText)->SetLabel( wxT("- / -") );
 
-			// Accepted requets
+			// Accepted requests
 			m_bar_accepted->SetValue( 0 );
 			CastChild(IDC_SACCEPTED, wxStaticText)->SetLabel( wxT("- / -") );
 
@@ -169,7 +169,7 @@ void CSharedFilesWnd::SelectionUpdated()
 			wxString labelReq = CFormat(wxT("%d / %d")) % session_requests % all_requests;
 			CastChild(IDC_SREQUESTED, wxStaticText)->SetLabel(labelReq);
 
-			// Accepted requets
+			// Accepted requests
 			session_accepted = session_accepted > lAccepted ? lAccepted : session_accepted;
 			m_bar_accepted->SetValue( session_accepted );
 			wxString labelAcc = CFormat(wxT("%d / %d")) % session_accepted % all_accepted;
--- a/src/StateMachine.cpp
+++ b/src/StateMachine.cpp
@@ -54,7 +54,7 @@ void CStateMachine::Clock()
 
 	old_state = m_state;
 
-	/* Process state change acording to event */
+	/* Process state change according to event */
 	if (!m_queue.empty()) {
 		event = m_queue.front();
 		m_queue.pop();
--- a/src/Statistics.h
+++ b/src/Statistics.h
@@ -105,7 +105,7 @@ class CPreciseRateCounter {
 	/**
 	 * Gets ever seen maximal rate.
 	 *
-	 * @return The maximal rate which occured.
+	 * @return The maximal rate which occurred.
 	 */
 	double	GetMaxRate()			{ wxMutexLocker lock(m_mutex); return m_max_rate; }
 
--- a/src/StatTree.h
+++ b/src/StatTree.h
@@ -329,7 +329,7 @@ private:
 	//! Children of this node.
 	std::list<CStatTreeItemBase*>	m_children;
 
-	//! Lock to protect list from simultanous access.
+	//! Lock to protect list from simultaneous access.
 	wxMutex m_lock;
 };
 
--- a/src/Tag.cpp
+++ b/src/Tag.cpp
@@ -131,7 +131,7 @@ CTag::CTag(const CFileDataIO& data, bool
 				break;
 
 			case TAGTYPE_FLOAT32:
-				//#warning Endianess problem?
+				//#warning Endianness problem?
 				data.Read(&m_fVal, 4);
 				break;
 
@@ -176,7 +176,7 @@ CTag::CTag(const CFileDataIO& data, bool
 				} else {
 					// Since we cannot determine the length of this tag, we
 					// simply have to abort reading the file.
-					throw CInvalidPacket(CFormat(wxT("Unknown tag type encounted %x, cannot proceed!")) % m_uType);
+					throw CInvalidPacket(CFormat(wxT("Unknown tag type encountered %x, cannot proceed!")) % m_uType);
 				}
 		}
 	} catch (...) {
@@ -364,7 +364,7 @@ bool CTag::WriteNewEd2kTag(CFileDataIO*
 			data->WriteUInt8(m_uVal);
 			break;
 		case TAGTYPE_FLOAT32:
-			//#warning Endianess problem?
+			//#warning Endianness problem?
 			data->Write(&m_fVal, 4);
 			break;
 		case TAGTYPE_HASH16:
--- a/src/ThreadScheduler.cpp
+++ b/src/ThreadScheduler.cpp
@@ -35,7 +35,7 @@ static wxMutex s_lock;
 static CThreadScheduler* s_scheduler = NULL;
 //! Specifies if the scheduler is running.
 static bool	s_running = false;
-//! Specifies if the gobal scheduler has been terminated.
+//! Specifies if the global scheduler has been terminated.
 static bool s_terminated = false;
 
 /**
@@ -43,7 +43,7 @@ static bool s_terminated = false;
  *
  * The reason for not using wxThreadHelper are as follows:
  *  - wxThreadHelper makes use of wxThread:Kill, which is warned against
- *    serveral times in the docs, and even calls it in its destructor.
+ *    several times in the docs, and even calls it in its destructor.
  *  - Managing the thread-object is difficult, since the only way to
  *    destroy it is to create a new thread.
  */
@@ -299,7 +299,7 @@ void* CThreadScheduler::Entry()
 
 			// If the task has been aborted, the entry now refers to
 			// a different task, so dont remove it. That also means
-			// that it cant be the last task of this type.
+			// that it can't be the last task of this type.
 			if (!task->m_abort) {
 				AddDebugLogLineN(logThreads,
 					CFormat(wxT("Completed task '%s%s', %u tasks remaining."))
--- a/src/ThreadScheduler.h
+++ b/src/ThreadScheduler.h
@@ -188,7 +188,7 @@ private:
 
 	//! The owner (scheduler), used when calling TestDestroy.
 	CMuleThread* m_owner;
-	//! Specifies if the specifc task should be aborted.
+	//! Specifies if the specific task should be aborted.
 	bool m_abort;
 
 	friend class CThreadScheduler;
--- a/src/ThreadTasks.cpp
+++ b/src/ThreadTasks.cpp
@@ -254,7 +254,7 @@ void CHashingTask::OnLastTask()
 {
 	if (GetType() == wxT("Hashing")) {
 		// To prevent rehashing in case of crashes, we
-		// explicity save the list of hashed files here.
+		// explicitly save the list of hashed files here.
 		theApp->knownfiles->Save();
 
 		// Make sure the AICH-hashes are up to date.
@@ -267,7 +267,7 @@ void CHashingTask::OnLastTask()
 // CAICHSyncTask
 
 CAICHSyncTask::CAICHSyncTask()
-	: CThreadTask(wxT("AICH Syncronizing"), wxEmptyString, ETP_Low)
+	: CThreadTask(wxT("AICH Synchronizing"), wxEmptyString, ETP_Low)
 {
 }
 
@@ -276,7 +276,7 @@ void CAICHSyncTask::Entry()
 {
 	ConvertToKnown2ToKnown264();
 
-	AddDebugLogLineN( logAICHThread, wxT("Syncronization thread started.") );
+	AddDebugLogLineN( logAICHThread, wxT("Synchronization thread started.") );
 
 	// We collect all masterhashs which we find in the known2.met and store them in a list
 	std::list<CAICHHash> hashlist;
@@ -429,7 +429,7 @@ void CCompletionTask::Entry()
 
 	{
 #ifndef AMULE_DAEMON
-		// Prevent the preference values from changing underneeth us.
+		// Prevent the preference values from changing underneath us.
 		wxMutexGuiLocker guiLock;
 #else
 		//#warning Thread-safety needed
--- a/src/ThreadTasks.h
+++ b/src/ThreadTasks.h
@@ -165,7 +165,7 @@ protected:
 	uint8		m_category;
 	//! Owner of the file, used when sending completion-event.
 	const CPartFile*	m_owner;
-	//! Specifies if an error occured during completion.
+	//! Specifies if an error occurred during completion.
 	bool		m_error;
 	//! The resulting full path. File may be be renamed.
 	CPath		m_newName;
--- a/src/Timer.h
+++ b/src/Timer.h
@@ -57,7 +57,7 @@ public:
 	 * Stops the timer.
 	 *
 	 * Note that this does not delete the actual thread
-	 * immediatly, but no new events will be queued after
+	 * immediately, but no new events will be queued after
 	 * calling this function.
 	 */
 	void Stop();
--- a/src/UploadBandwidthThrottler.cpp
+++ b/src/UploadBandwidthThrottler.cpp
@@ -57,7 +57,7 @@ UploadBandwidthThrottler::UploadBandwidt
 
 
 /**
- * The destructor stops the thread. If the thread has already stoppped, destructor does nothing.
+ * The destructor stops the thread. If the thread has already stopped, destructor does nothing.
  */
 UploadBandwidthThrottler::~UploadBandwidthThrottler()
 {
@@ -100,11 +100,11 @@ uint64 UploadBandwidthThrottler::GetNumb
 
 /**
  * Add a socket to the list of sockets that have upload slots. The main thread will
- * continously call send on these sockets, to give them chance to work off their queues.
+ * continuously call send on these sockets, to give them chance to work off their queues.
  * The sockets are called in the order they exist in the list, so the top socket (index 0)
  * will be given a chance first to use bandwidth, and then the next socket (index 1) etc.
  *
- * It is possible to add a socket several times to the list without removing it inbetween,
+ * It is possible to add a socket several times to the list without removing it in between,
  * but that should be avoided.
  *
  * @param index insert the socket at this place in the list. An index that is higher than the
--- a/src/UploadClient.cpp
+++ b/src/UploadClient.cpp
@@ -248,7 +248,7 @@ void CUpDownClient::CreateNextBlockPacka
 
 			SetUploadFileID(srcfile);
 
-			// check extention to decide whether to compress or not
+			// check extension to decide whether to compress or not
 			if (m_byDataCompVer == 1 && GetFiletype(srcfile->GetFileName()) != ftArchive) {
 				CreatePackedPackets(area.GetBuffer(), togo, currentblock);
 			} else {
@@ -277,7 +277,7 @@ void CUpDownClient::CreateNextBlockPacka
 		AddDebugLogLineN(logClient, GetClientFullInfo() + wxT(" requested file-data at an invalid position - disconnecting"));
 	}
 
-	// Error occured.
+	// Error occurred.
 	theApp->uploadqueue->RemoveFromUploadQueue(this);
 }
 
@@ -651,7 +651,7 @@ void CUpDownClient::SendOutOfPartReqsAnd
 	//the downloader didn't send any request blocks. Then the connection times out..
 	//I did some tests with eDonkey also and it seems to work well with them also..
 
-	// Send this inmediately, don't queue.
+	// Send this immediately, don't queue.
 	CPacket* pPacket = new CPacket(OP_OUTOFPARTREQS, 0, OP_EDONKEYPROT);
 	theStats::AddUpOverheadFileRequest(pPacket->GetPacketSize());
 	AddDebugLogLineN( logLocalClient, wxT("Local Client: OP_OUTOFPARTREQS to ") + GetFullIP() );
@@ -796,7 +796,7 @@ void CUpDownClient::CheckForAggressive()
 {
 	uint32 cur_time = ::GetTickCount();
 
-	// First call, initalize
+	// First call, initialize
 	if ( !m_LastFileRequest ) {
 		m_LastFileRequest = cur_time;
 		return;
--- a/src/UPnPBase.cpp
+++ b/src/UPnPBase.cpp
@@ -1643,7 +1643,7 @@ void CUPnPControlPoint::Subscribe(CUPnPS
 		msg.str("");
 
 		// Now try to subscribe to this service. If the subscription
-		// is not successfull, we will not be notified about events,
+		// is not successful, we will not be notified about events,
 		// but it may be possible to use the service anyway.
 		errcode = UpnpSubscribe(m_UPnPClientHandle,
 			service.GetAbsEventSubURL().c_str(),
--- a/src/UserEvents.h
+++ b/src/UserEvents.h
@@ -139,7 +139,7 @@ class CUserEvents {
 	static unsigned int	GetCount() ATTR(__const__);
 
 	/**
-	 * Returs the human-readable name of the event.
+	 * Returns the human-readable name of the event.
 	 */
 	static const wxString&	GetDisplayName(enum EventType event) ATTR(__pure__);
 
--- a/src/utils/aLinkCreator/CMakeLists.txt
+++ b/src/utils/aLinkCreator/CMakeLists.txt
@@ -1,12 +1,12 @@
-ADD_SUBDIRECTORY (docs)
-ADD_SUBDIRECTORY (src)
+add_subdirectory (docs)
+add_subdirectory (src)
 
-IF (BUILD_ALC)
-	INSTALL (FILES alc.xpm
+if (BUILD_ALC)
+	install (FILES alc.xpm
 		DESTINATION "${CMAKE_INSTALL_DATADIR}/pixmaps"
 	)
 
-	INSTALL (FILES alc.desktop
+	install (FILES alc.desktop
 		DESTINATION "${CMAKE_INSTALL_DATADIR}/applications"
 	)
-ENDIF (BUILD_ALC)
+endif()
--- a/src/utils/aLinkCreator/docs/alcc.tr.1
+++ b/src/utils/aLinkCreator/docs/alcc.tr.1
@@ -18,7 +18,7 @@ alcc \- aMule iin metin temelli eD2k b
 .RB_untranslated [ \-h ]
 .SH AIKLAMA
 \fI<girdidosya_listesi>\fPnde girilen tm dosyalarn eD2k
-balantlarn hesaplar (bir ya da birden fazla dosya olabilir)
+balantlarn hesaplar (bir ya da birden fazla dosya olabilir).
 .TP 
 .B_untranslated [ \-p\fR, \fB\-\-parthashes ]\fR
 Blmler iin hash deerlerini hesaplar ve eD2k balantlarna ekler.
--- a/src/utils/aLinkCreator/docs/alc.ro.1
+++ b/src/utils/aLinkCreator/docs/alc.ro.1
@@ -13,7 +13,7 @@ aLinkCreator \- creatorul aMule eD2k de
 \fBalc\fP este un utilitar grafic care creaz o legtur eD2k la orice fiier
 de pe computerul dumneavoastr.
 
-Aceast aplicaie nu ia nici un argument
+Aceast aplicaie nu ia nici un argument.
 .SH "RAPORTAREA ERORILOR"
 V rugm s raportai erorile fie pe forumul
 nostru(\fIhttp://forum.amule.org/\fP), sau n bugtracker\-ul nostru
--- a/src/utils/aLinkCreator/docs/CMakeLists.txt
+++ b/src/utils/aLinkCreator/docs/CMakeLists.txt
@@ -1,7 +1,7 @@
-IF (BUILD_ALC)
-	CHECK_MANPAGE ("alc")
-ENDIF (BUILD_ALC)
+if (BUILD_ALC)
+	check_manpage ("alc")
+endif()
 
-IF (BUILD_ALCC)
-	CHECK_MANPAGE ("alcc")
-ENDIF (BUILD_ALCC)
\ No newline at end of file
+if (BUILD_ALCC)
+	check_manpage ("alcc")
+endif()
--- a/src/utils/aLinkCreator/src/alcc.cpp
+++ b/src/utils/aLinkCreator/src/alcc.cpp
@@ -46,11 +46,7 @@ int alcc::OnRun ()
   wxLogStderr * stderrLog = new wxLogStderr;
   wxLogStderr * stdoutLog = new wxLogStderr(stdout);
   delete wxLog::SetActiveTarget(stderrLog); // Log on Stderr
-#if wxCHECK_VERSION(2, 9, 0)
   wxLog::SetTimestamp("");   // Disable timestamp on messages
-#else
-  wxLog::SetTimestamp(NULL); // Disable timestamp on messages
-#endif
 
   Ed2kHash hash;
   size_t i;
@@ -81,7 +77,7 @@ int alcc::OnRun ()
         {
             if (m_flagVerbose)
                 {
-                    wxLogMessage(_("%s ---> Non existant file !\n"),m_filesToHash[i].c_str());
+                    wxLogMessage(_("%s ---> Non existent file !\n"),m_filesToHash[i].c_str());
                 }
         }
     }
--- a/src/utils/aLinkCreator/src/alcc.h
+++ b/src/utils/aLinkCreator/src/alcc.h
@@ -31,7 +31,7 @@
 #include <wx/cmdline.h>
 
 //-----------------------------------------------------------------------------
-// This can be put in a separete include file
+// This can be put in a separate include file
 #include <wx/strconv.h>
 static wxCSConv aMuleConv(wxT("iso8859-1"));
 #ifdef wxUSE_UNICODE
--- a/src/utils/aLinkCreator/src/alcframe.cpp
+++ b/src/utils/aLinkCreator/src/alcframe.cpp
@@ -53,11 +53,7 @@
 	#include <shlobj.h>
 #elif defined(__WXMAC__)
 	#include <CoreServices/CoreServices.h>
-	#if wxCHECK_VERSION(2, 9, 0)
-		#include <wx/osx/core/cfstring.h>  // Do_not_auto_remove
-	#else
-		#include <wx/mac/corefoundation/cfstring.h>
-	#endif
+	#include <wx/osx/core/cfstring.h>  // Do_not_auto_remove
 	#include <wx/intl.h>
 #endif
 
@@ -353,11 +349,7 @@ AlcFrame::SetFileToHash()
 		CFURLRef	urlRef		= CFURLCreateFromFSRef(NULL, &fsRef);
 		CFStringRef	cfString	= CFURLCopyFileSystemPath(urlRef, kCFURLPOSIXPathStyle);
 		CFRelease(urlRef) ;
-		#if wxCHECK_VERSION(2, 9, 0)
-			browseroot = wxCFStringRef(cfString).AsString(wxLocale::GetSystemEncoding());
-		#else
-			browseroot = wxMacCFStringHolder(cfString).AsString(wxLocale::GetSystemEncoding());
-		#endif
+		browseroot = wxCFStringRef(cfString).AsString(wxLocale::GetSystemEncoding());
 	} else {
 		browseroot = wxFileName::GetHomeDir();
 	}
@@ -603,7 +595,7 @@ AlcFrame::OnAddUrlButton (wxCommandEvent
             }
         }
 
-      // Add only a not already existant URL
+      // Add only a not already existent URL
       if (UrlNotExists)
         {
 	  m_inputUrlListBox->Append(wxURI(url).BuildURI());
--- a/src/utils/aLinkCreator/src/ed2khash.cpp
+++ b/src/utils/aLinkCreator/src/ed2khash.cpp
@@ -125,7 +125,7 @@ bool Ed2kHash::SetED2KHashFromFile(const
           partcount++;
 
 #ifdef WANT_STRING_IMPLEMENTATION
-          // MD4_HASHLEN_BYTE is ABSOLUTLY needed as we dont want NULL
+          // MD4_HASHLEN_BYTE is ABSOLUTELY needed as we dont want NULL
           // character to be interpreted as the end of the parthash string
 #if wxUSE_UNICODE
 
@@ -195,11 +195,7 @@ bool Ed2kHash::SetED2KHashFromFile(const
   return SetED2KHashFromFile(wxFileName(filename), hook);
 }
 
-#if wxCHECK_VERSION(2, 9, 0)
 #define WXLONGLONGFMTSPEC wxT(wxLongLongFmtSpec)
-#else
-#define WXLONGLONGFMTSPEC wxLongLongFmtSpec
-#endif
 
 /// Get Ed2k link
 wxString Ed2kHash::GetED2KLink(const bool addPartHashes, const wxArrayString* arrayOfUrls)
--- a/src/utils/amps/README
+++ b/src/utils/amps/README
@@ -28,7 +28,7 @@ distribution!
 
 Sometime in the near future I will complete the theme support I have stubbed
 into the script. If you have a colour scheme that you think looks good, modify
-'style.css' and be sure to send me a copy of your new syle so I can include it
+'style.css' and be sure to send me a copy of your new style so I can include it
 in future versions!
 
 Please send any bugs, translations, or verbal abuse to <uberpenguin@hotpop.com>
--- a/src/utils/cas/cas.c
+++ b/src/utils/cas/cas.c
@@ -222,7 +222,7 @@ int main(int argc, char *argv[])
 		fprintf(stderr, "Unable to open file %s\nCheck if you have amule online signature enabled.\n", path);
 		exit(2);
 	}
-	/* i believe this shouldnt be here.
+	/* i believe this shouldn't be here.
 	The freq of update could be higher than 60 seconds.
 	And it doesn't mean that the amule is not running.
 	*/
--- a/src/utils/cas/CMakeLists.txt
+++ b/src/utils/cas/CMakeLists.txt
@@ -15,25 +15,18 @@ if (WIN32)
 	)
 endif()
 
-target_compile_definitions (cas
-		PRIVATE ${gdlib_CFLAGS}
-)
-
 target_include_directories (cas
 	PRIVATE ${CMAKE_BINARY_DIR}
 )
 
 target_link_libraries (cas
-	${gdlib_LIBRARIES}
-	${gdlib_LD_FLAGS}
+	PkgConfig::gdlib
 )
 
 install (TARGETS cas
 	RUNTIME DESTINATION bin
 )
 
-
 install (FILES tmp.html stat.png
 	DESTINATION "${CMAKE_INSTALL_DATADIR}/cas"
 )
-
--- a/src/utils/cas/configfile.c
+++ b/src/utils/cas/configfile.c
@@ -1,7 +1,7 @@
 /*
  *  Name:         Config file functions
  *
- *  Purpose:      Read info from casrc ou create one if it doesnt exist
+ *  Purpose:      Read info from casrc ou create one if it doesn't exist
  *
  *  Author:       Pedro de Oliveira <falso@rdk.homeip.net>
  *
@@ -120,7 +120,7 @@ int readconfig(CONF *config)
 		// Jacobo221 - [ToDo] Only first char per line is comment...
 		if (fgets (buffer,120,conf)) {
 			if (buffer[0] != '#') {
-				/* Only two fileds per line */
+				/* Only two fields per line */
 				sscanf(buffer, "%" MAX_CONF_KEY_LEN_STR "s %*" MAX_CONF_ARG_LEN_STR "s", option);
 				fflush (stdout);
 		// Jacobo221 - [ToDo] So lines can't be swapped...
--- a/src/utils/cas/configfile.h
+++ b/src/utils/cas/configfile.h
@@ -1,7 +1,7 @@
 /*
  *  Name:         Config file functions
  *
- *  Purpose:      Read info from casrc ou create one if it doesnt exist
+ *  Purpose:      Read info from casrc ou create one if it doesn't exist
  *
  *  Author:       Pedro de Oliveira <falso@rdk.homeip.net>
  *
--- a/src/utils/cas/docs/CMakeLists.txt
+++ b/src/utils/cas/docs/CMakeLists.txt
@@ -1 +1 @@
-CHECK_MANPAGE ("cas")
\ No newline at end of file
+check_manpage ("cas")
--- a/src/utils/cas/graphics.c
+++ b/src/utils/cas/graphics.c
@@ -37,7 +37,7 @@
 #include "graphics.h"
 
 /*
- * this is the funcion that writes the text to the image.
+ * this is the function that writes the text to the image.
  * almost everything is taken from libgd examples
  */
 int createimage(CONF *config, char *lines[IMG_TEXTLINES], char *path_for_picture)
--- a/src/utils/cas/README
+++ b/src/utils/cas/README
@@ -2,7 +2,7 @@ C AMULE STATS
 
 
 
-This is a little app that i've been doing cause i really didnt liked aStats.
+This is a little app that i've been using because I really didn't like aStats.
 I was too slow, so i tried to do a little remake of it in c just to learn a 
 bit more of c and do a nice app too.
 
--- a/src/utils/cas/tmp.html
+++ b/src/utils/cas/tmp.html
@@ -146,7 +146,7 @@
             </td>
           </tr>
           <tr>
-            <td style="vertical-align: top; background-color: rgb(255, 255, 255); width: 21%;">Server Addres<br>
+            <td style="vertical-align: top; background-color: rgb(255, 255, 255); width: 21%;">Server Address<br>
             </td>
             <td style="vertical-align: top; background-color: rgb(255, 255, 255); width: 79%;">#IP#:#PORT#<br>
             </td>
--- a/src/utils/fileview/CMakeLists.txt
+++ b/src/utils/fileview/CMakeLists.txt
@@ -27,8 +27,8 @@ target_include_directories (fileview
 )
 
 target_link_libraries (fileview
-	mulecommon
-	CRYPTOPP::CRYPTOPP
+	PRIVATE mulecommon
+	PRIVATE CRYPTOPP::CRYPTOPP
 )
 
 install (TARGETS fileview
--- a/src/utils/fileview/Print.h
+++ b/src/utils/fileview/Print.h
@@ -64,9 +64,6 @@ inline SDMODE GetStringsMode()	{ return
 
 wxString MakePrintableString(const wxString& str);
 
-#if !wxCHECK_VERSION(2, 9, 0)
-inline __attribute_always_inline__ std::ostream& operator<<(std::ostream& x, const wxString& y)		{ return x << (const char *)unicode2char(y); }
-#endif
 inline std::ostream& operator<<(std::ostream& x, const Kademlia::CUInt128& y)	{ return x << y.ToHexString(); }
 inline std::ostream& operator<<(std::ostream& x, const CMD4Hash& y)		{ return x << y.Encode(); }
 
--- a/src/utils/plasmamule/plasma-engine-plasmamule.cpp
+++ b/src/utils/plasmamule/plasma-engine-plasmamule.cpp
@@ -105,7 +105,7 @@ void PlasmaMuleEngine::regDbus ()
 	new EngineAdaptor(this);
 	QDBusConnection dbus = QDBusConnection::sessionBus();
 	dbus.registerObject("/Link", this);
-	kDebug(m_debugChannel) << "Registerred dbus: " << dbus.registerService("org.amule.engine");
+	kDebug(m_debugChannel) << "Registered dbus: " << dbus.registerService("org.amule.engine");
 }
 
 void PlasmaMuleEngine::downloadFinished (KIO::Job* job,const QByteArray& data)
--- a/src/utils/scripts/denoiser.rules
+++ b/src/utils/scripts/denoiser.rules
@@ -107,7 +107,7 @@ s/-DHAVE_CONFIG_H//
 	/^[^=]*CXXFLAGS/ b 8
 	b 9
 	:8
-	# save -Wl, -Wa, and -Wp, flags, they're for linker, assember and preprocessor respectively
+	# save -Wl, -Wa, and -Wp, flags, they're for linker, assembler and preprocessor respectively
 	s/ -Wl,/ -%l,/g
 	s/ -Wa,/ -%a,/g
 	s/ -Wp,/ -%p,/g
@@ -255,7 +255,7 @@ s/-DHAVE_CONFIG_H//
 	:5
 
 	# If --enable-maintainer-mode, Makefiles may be automatically regenerated.
-	# Denoise new Makefile aswell.
+	# Denoise new Makefile as well.
 	/Makefile$/ {
 		x
 		/echo/! {
--- a/src/utils/scripts/sanity
+++ b/src/utils/scripts/sanity
@@ -1022,7 +1022,7 @@ end
 
 
 
-#TODO Improved parameter-handling, add =<file> for the outputing to a file
+#TODO Improved parameter-handling, add =<file> for the outputting to a file
 ARGV.each do |param|
 	case param
 		when "--text" then
--- a/src/utils/scripts/wikify_latest_changelog
+++ b/src/utils/scripts/wikify_latest_changelog
@@ -18,7 +18,7 @@
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA
 
-# Wikifies lastest changelog entry. No sanity checking. Must be run from sources root folder.
+# Wikifies latest changelog entry. No sanity checking. Must be run from sources root folder.
 if test x"`ls docs/Changelog`" = x""; then
   echo "This script must be run on aMule base directory."
 else
--- a/src/utils/wxCas/docs/CMakeLists.txt
+++ b/src/utils/wxCas/docs/CMakeLists.txt
@@ -1 +1 @@
-CHECK_MANPAGE ("wxcas")
\ No newline at end of file
+check_manpage ("wxcas")
--- a/src/utils/wxCas/docs/wxcas.ro.1
+++ b/src/utils/wxCas/docs/wxcas.ro.1
@@ -18,7 +18,7 @@ aMule.
 Bazat pe \fBcas\fP(1) a lui Pedro de Oliveira. \fBwxcas\fP a fost scris de
 ThePolish <thepolish@vipmail.ru>
 
-Aceast aplicaie nu ia nici un argument
+Aceast aplicaie nu ia nici un argument.
 .SH "RAPORTAREA ERORILOR"
 V rugm s raportai erorile fie pe forumul
 nostru(\fIhttp://forum.amule.org/\fP), sau n bugtracker\-ul nostru
--- a/src/utils/wxCas/src/linuxmon.h
+++ b/src/utils/wxCas/src/linuxmon.h
@@ -53,7 +53,7 @@ public:
 	/// Destructor
 	~LinuxMon ();
 
-	/// Refresh stored informations
+	/// Refresh stored information
 	void Refresh ();
 
 	/// Get system uptime
--- a/src/utils/wxCas/src/onlinesig.h
+++ b/src/utils/wxCas/src/onlinesig.h
@@ -83,7 +83,7 @@ public:
 	/// Set amulesig.dat file name and path
 	void SetAmuleSig ( const wxFileName& file );
 
-	/// Refresh stored informations
+	/// Refresh stored information
 	void Refresh ();
 
 	/// Return TRUE if aMule is running
--- a/src/utils/wxCas/src/wxcascte.cpp
+++ b/src/utils/wxCas/src/wxcascte.cpp
@@ -32,11 +32,7 @@
 
 #ifdef __WXMAC__
 	#include <CoreServices/CoreServices.h> // Do_not_auto_remove
-	#if wxCHECK_VERSION(2, 9, 0)
-		#include <wx/osx/core/cfstring.h>  // Do_not_auto_remove
-	#else
-		#include <wx/mac/corefoundation/cfstring.h>  // Do_not_auto_remove
-	#endif
+	#include <wx/osx/core/cfstring.h>  // Do_not_auto_remove
 	#include <wx/intl.h> // Do_not_auto_remove
 #elif defined(__WINDOWS__)
 	#include <winerror.h> // Do_not_auto_remove
@@ -133,13 +129,8 @@ wxString GetDefaultAmulesigPath()
 		CFURLRef	urlRef		= CFURLCreateFromFSRef(NULL, &fsRef);
 		CFStringRef	cfString	= CFURLCopyFileSystemPath(urlRef, kCFURLPOSIXPathStyle);
 		CFRelease(urlRef) ;
-		#if wxCHECK_VERSION(2, 9, 0)
-			strDir = wxCFStringRef(cfString).AsString(wxLocale::GetSystemEncoding())
-			+ wxFileName::GetPathSeparator() + wxT("aMule");
-		#else
-			strDir = wxMacCFStringHolder(cfString).AsString(wxLocale::GetSystemEncoding())
-			+ wxFileName::GetPathSeparator() + wxT("aMule");
-		#endif
+		strDir = wxCFStringRef(cfString).AsString(wxLocale::GetSystemEncoding())
+		+ wxFileName::GetPathSeparator() + wxT("aMule");
 	}
 
 #elif defined(__WINDOWS__)
--- a/src/utils/wxCas/src/wxcasframe.cpp
+++ b/src/utils/wxCas/src/wxcasframe.cpp
@@ -280,11 +280,11 @@ WxCasFrame::GetStatImage () const
 #ifdef __WINDOWS__
 
 	memdc.
-	SetFont ( wxFont ( 6, wxSWISS, wxNORMAL, wxBOLD ) );
+	SetFont ( wxFont ( 6, wxFONTFAMILY_SWISS, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_BOLD ) );
 #else
 
 	memdc.
-	SetFont ( wxFont ( 8, wxSWISS, wxNORMAL, wxBOLD ) );
+	SetFont ( wxFont ( 8, wxFONTFAMILY_SWISS, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_BOLD ) );
 #endif
 
 	memdc.
@@ -536,7 +536,7 @@ WxCasFrame::UpdateAll ( bool forceFittin
 	bool needFit = UpdateStatsPanel ();
 
 	if ( needFit || forceFitting ) {
-		// Fit stats pannel
+		// Fit stats panel
 		m_mainPanel->Fit();
 
 		// Fit main frame
--- a/src/utils/wxCas/src/wxcasprefs.cpp
+++ b/src/utils/wxCas/src/wxcasprefs.cpp
@@ -154,7 +154,7 @@ WxCasPrefs::WxCasPrefs ( wxWindow * pare
 	m_ftpUpdateCheck =
 	    new wxCheckBox ( this, ID_FTP_UPDATE_CHECK,
 	                     _
-	                     ( "Upload periodicaly your stat image to FTP server" ) );
+	                     ( "Upload periodically your stat image to FTP server" ) );
 	m_ftpUpdateSBoxSizer->Add ( m_ftpUpdateCheck, 0,
 	                            wxGROW | wxALIGN_CENTER_VERTICAL | wxALL, 5 );
 
--- a/src/utils/xas/CMakeLists.txt
+++ b/src/utils/xas/CMakeLists.txt
@@ -1,12 +1,14 @@
-CONFIGURE_FILE (
+add_subdirectory (docs)
+
+configure_file (
 	autostart-xas.cm
 	autostart-xas
 )
 
-INSTALL (FILES xas.pl
+install (FILES xas.pl
 	DESTINATION "${CMAKE_INSTALL_LIBDIR}/xchat/plugins/"
 )
 
-INSTALL (FILES ${CMAKE_CURRENT_BINARY_DIR}/autostart-xas
+install (PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/autostart-xas
 	DESTINATION "${CMAKE_INSTALL_BINDIR}/"
 )
--- /dev/null
+++ b/src/utils/xas/docs/CMakeLists.txt
@@ -0,0 +1 @@
+check_manpage ("xas")
--- a/unittests/muleunit/test.h
+++ b/unittests/muleunit/test.h
@@ -27,10 +27,8 @@
 #include <wx/string.h>
 #include <list>
 #include <string>
-
-#if wxCHECK_VERSION(2, 9, 0)
 #include <wx/wxcrt.h>
-#endif
+
 
 /**
  * MuleUnit namespace.
@@ -107,7 +105,7 @@ public:
 	/** Adds a context with the specified information and description. */
 	CContext(const wxChar* file, int line, const wxString& desc);
 
-	/** Removes the context addded by the constructor. */
+	/** Removes the context added by the constructor. */
 	~CContext();
 };
 
@@ -170,7 +168,7 @@ public:
 	Test(const wxString& testCaseName, const wxString& testName);
 
 	/**
-	 * Main Test desctructor
+	 * Main Test destructor
 	 * Delete the testPartResult linked list. This is why the user should
 	 * only use the macro provided by muleunit to report a test result.
 	 */
@@ -219,11 +217,8 @@ public:
 		if (!(a == b)) {
 			wxString message = wxT("Expected '") + StringFrom(a) +
 								wxT("' but got '") + StringFrom(b) + wxT("'");
-            #if wxCHECK_VERSION(3, 1, 0)
-                throw CTestFailureException(message, file.c_str(), line);
-            #else
-                throw CTestFailureException(message, file, line);
-            #endif
+
+			throw CTestFailureException(message, file.c_str(), line);
 		}
 	}
 
@@ -241,7 +236,7 @@ protected:
 /**
  * Asserts that a condition is true.
  * If the condition is not true, a failure is generated.
- * @param condition Condition to fullfill for the assertion to pass
+ * @param condition Condition to fulfill for the assertion to pass
  * @param message Message that will be displayed if this assertion fails
  */
 #define ASSERT_TRUE_M(condition, message) \
@@ -361,7 +356,7 @@ protected:
 #define TEST(testCaseName, testName)	TEST_M(testCaseName, testName, wxT(#testName))
 
 /**
- * Location to declare variables and objets.
+ * Location to declare variables and objects.
  * This is where user should declare members accessible by TESTF,
  * SETUP and TEARDOWN.
  *
--- a/unittests/README
+++ b/unittests/README
@@ -11,7 +11,7 @@ How to use:
  This section describes the step-by-step of creating a new testcase.
 
  It is recommended that each test-case (a collection of tests) is
- placed in a seperate .cpp file, in general, one test-case per class.
+ placed in a separate .cpp file, in general, one test-case per class.
 
  In the following examples, I will test a non-existing stack template
  class which has the member-functions push (back) and pop (front).
@@ -21,7 +21,7 @@ How to use:
     Test-cases exist in two flavors: With a fixture and without.
     A fixture is a way to ease the preparation before and after
     each test and consists of (optionally) a setUp function which
-    is run before each unittest, a tearDown function wich is run
+    is run before each unittest, a tearDown function which is run
     after each unittest and any number of member-variables and
     helper-functions.
 
@@ -80,7 +80,7 @@ How to use:
       }
 
 
-    A test-case can have any number of unittests assosiated with it,
+    A test-case can have any number of unittests associated with it,
     but each test in a test-case must be uniquely named.
 
 
--- a/unittests/tests/CTagTest.cpp
+++ b/unittests/tests/CTagTest.cpp
@@ -576,11 +576,7 @@ TEST_M(CTag, KadTagNames, wxT("Kad: Test
 		buf.WriteUInt8(0x01); // single char string
 		buf.WriteUInt8(0x00); //
 
-        #if wxCHECK_VERSION(3, 1, 0)
-            wxCharBuffer b = wxConvISO8859_1.cWC2MB(it_name->first.c_str());
-        #else
-            wxCharBuffer b = wxConvISO8859_1.cWC2MB(it_name->first);
-        #endif
+		wxCharBuffer b = wxConvISO8859_1.cWC2MB(it_name->first.c_str());
 
 		buf.WriteUInt8(((const char *)b)[0]); // Write string first char
 		buf.WriteUInt8(counter++); // write tag value
--- a/unittests/tests/FileDataIOTest.cpp
+++ b/unittests/tests/FileDataIOTest.cpp
@@ -51,7 +51,7 @@ void writePredefData(CFileDataIO* file)
 
 
 /////////////////////////////////////////////////////////////////////
-// Specialize this template for each implemention
+// Specialize this template for each implementation
 // of the CFileDataIO interface you wish to test.
 //
 // This struct must be a subclass of Test.
@@ -762,7 +762,6 @@ TEST(CFile, Constructor)
 		ASSERT_TRUE(file.fd() == CFile::fd_invalid);
 		ASSERT_RAISES(CRunTimeException, file.WriteUInt8(0));
 		ASSERT_RAISES(CRunTimeException, file.ReadUInt8());
-		ASSERT_RAISES(CRunTimeException, file.Seek(0, wxFromStart));
 		ASSERT_RAISES(CRunTimeException, file.GetLength());
 		ASSERT_RAISES(CRunTimeException, file.GetPosition());
 		ASSERT_RAISES(CRunTimeException, file.SetLength(13));
@@ -874,7 +873,7 @@ TEST(CFile, Create)
 		file.WriteUInt32(1);
 	}
 
-	// Check that owerwrite = false works as expected
+	// Check that overwrite = false works as expected
 	{
 		CFile file;
 		ASSERT_FALSE(file.Create(testFile, false, testMode));
@@ -893,7 +892,7 @@ TEST(CFile, Create)
 		ASSERT_TRUE(!file.IsOpened());
 	}
 
-	// Check that owerwrite = true works as expected
+	// Check that overwrite = true works as expected
 	{
 		CFile file;
 		ASSERT_TRUE(file.Create(testFile, true, testMode));
--- a/unittests/tests/FormatTest.cpp
+++ b/unittests/tests/FormatTest.cpp
@@ -100,7 +100,7 @@ TEST(Format, SetStringAndGetString)
 
 
 
-//! Test the two boundaries and a middle value of the specificed format
+//! Test the two boundaries and a middle value of the specified format
 #define STANDARD_TYPE_TESTS(cformat, wxformat, type) \
 	STANDARD_TEST(cformat, wxformat, MIN(type)); \
 	STANDARD_TEST(cformat, wxformat, (type)(MAX(type) / 2)); \
--- a/unittests/tests/Makefile.am
+++ b/unittests/tests/Makefile.am
@@ -1,5 +1,5 @@
 # If any tests uses more than a cpp/h fileset, then
-# make a seperate subfolder for it to reduce clutter.
+# make a separate subfolder for it to reduce clutter.
 #SUBDIRS =
 EXTRA_DIST =
 
--- a/unittests/tests/NetworkFunctionsTest.cpp
+++ b/unittests/tests/NetworkFunctionsTest.cpp
@@ -126,7 +126,7 @@ TEST(NetworkFunctions, StringIPtoUint32)
 	ASSERT_FALSE(StringIPtoUint32(wxT("1.2.2147483648.4"), dummyIP));
 	ASSERT_FALSE(StringIPtoUint32(wxT("1.2.3.2147483648"), dummyIP));
 
-	// Values greater than 2 ** 32 - 1 (triggered overflow and becames x - (2 ** 32 - 1))
+	// Values greater than 2 ** 32 - 1 (triggered overflow and becomes x - (2 ** 32 - 1))
 	ASSERT_FALSE(StringIPtoUint32(wxT("4294967296.2.3.4"), dummyIP));
 	ASSERT_FALSE(StringIPtoUint32(wxT("1.4294967296.3.4"), dummyIP));
 	ASSERT_FALSE(StringIPtoUint32(wxT("1.2.4294967296.4"), dummyIP));
--- a/unittests/tests/RangeMapTest.cpp
+++ b/unittests/tests/RangeMapTest.cpp
@@ -73,11 +73,11 @@ DECLARE(RangeMap);
 	TestRangeMap m_map;
 	TestRangeMap m_mmaps[3];
 
-	// Identifers for the multirange maps
+	// Identifiers for the multirange maps
 	enum Maps {
 		CONT  = 0, // Continues ranges, IE no gap
-		SSAME = 1, // Seperated but equal
-		SDIFF = 2  // Seperated and not equal
+		SSAME = 1, // Separated but equal
+		SDIFF = 2  // Separated and not equal
 	};
 
 	// Sets up a few maps with predefined ranges.
--- a/unittests/tests/StringFunctionsTest.cpp
+++ b/unittests/tests/StringFunctionsTest.cpp
@@ -67,7 +67,7 @@ TEST(SimpleParser, Constructor)
 		ASSERT_EQUALS(wxEmptyString, tkz1.next());
 	}
 
-	// String with no tokens should be return immediatly
+	// String with no tokens should be return immediately
 	{
 		CSimpleTokenizer tkz2(wxT(" abc "), wxT('-'));
 		ASSERT_EQUALS(wxT(" abc "), tkz2.remaining());
