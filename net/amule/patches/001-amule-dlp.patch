--- a/configure.ac	2021-02-08 06:25:11.000000000 +0800
+++ b/configure.ac	2021-02-11 23:10:03.000000000 +0800
@@ -91,6 +91,14 @@
 KDE_CONFIG_OPTIONS
 QT_CONFIG_OPTIONS
 
+#Dynamic Leecher Protection - Bill Lee
+AC_ARG_ENABLE(
+	[dlp],
+	[AS_HELP_STRING(
+		[--disable-dlp],
+		[Do not compile DLP.])],
+	[ENABLE_DLP=$enableval], [ENABLE_DLP=yes])
+
 # Default is yes, because they're most likely compatible.
 # However, this is only used when cross-compiling.
 AC_ARG_WITH(
@@ -451,6 +459,8 @@
 AM_CONDITIONAL(COMPILE_NLS, test x$USE_NLS = xyes)
 AM_CONDITIONAL(INSTALL_SKINS, test MULE_IS_ENABLED_ANY([monolithic, amule-gui]))
 AM_CONDITIONAL(PLASMAMULE, test MULE_IS_ENABLED([plasmamule]))
+#Dynamic Leech Protection - Bill Lee
+AM_CONDITIONAL(ENABLE_DLP, test x$ENABLE_DLP = xyes)
 
 AM_CONDITIONAL([COMPILE_LIB_COMMON],	[test MULE_IS_ENABLED_ANY([monolithic, amule-daemon, amulecmd, webserver, amule-gui, fileview])])
 AM_CONDITIONAL([COMPILE_LIB_EC],	[test MULE_IS_ENABLED_ANY([monolithic, amule-daemon, amulecmd, webserver, amule-gui])])
--- a/po/zh_CN.po	2021-02-08 06:25:11.000000000 +0800
+++ b/po/zh_CN.po	2021-02-11 23:15:14.000000000 +0800
@@ -7,6 +7,7 @@
 # xiaoqiao <29551030@qq.com>, 2007, 2008.
 # JimHu <jimhuyiwei@gmail.com>, 2009.
 # Xiaoqiao <wo@xiaoqiao.me>, 2010.
+# Bill Lee <bill.lee.y@gmail.com>, 2010, 2011.
 # Yi Qi <u4781098@anu.edu.au>, 2011.
 #
 msgid ""
@@ -471,6 +472,12 @@
 msgid "http://kademlia.scs.cs.nyu.edu\n"
 msgstr "http://kademlia.scs.cs.nyu.edu\n"
 
+msgid "\nDynamic Leech Protection\n"
+msgstr "\n动态吸血保护\n"
+
+msgid " Homepage: http://amule-dlp.googlecode.com \n"
+msgstr " 主页：http://amule-dlp.googlecode.com \n"
+
 #: src/amuleDlg.cpp:509 src/KadDlg.cpp:193 src/PartFile.cpp:919
 #: src/PartFile.cpp:927 src/PrefsUnifiedDlg.cpp:637 src/PrefsUnifiedDlg.cpp:742
 #: src/PrefsUnifiedDlg.cpp:862
@@ -2145,7 +2152,7 @@
 #: src/HTTPDownload.cpp:341
 #, c-format
 msgid "Protocol not supported for HTTP download: %s"
-msgstr ""
+msgstr "HTTP下载不支持该协议: %s"
 
 #: src/HTTPDownload.cpp:384
 msgid "Unable to connect to HTTP download server"
@@ -3253,13 +3260,13 @@
 
 #: src/muuli_wdr.cpp:1494
 msgid "Show notifications when finished downloading"
-msgstr ""
+msgstr "下载完成后显示通知"
 
 #: src/muuli_wdr.cpp:1495
 msgid ""
 "Enabling this will make aMule to show notifications when finished "
 "downloading."
-msgstr ""
+msgstr "启用此选项将使aMule在下载完成时显示通知。"
 
 #: src/muuli_wdr.cpp:1500
 msgid "Tooltip delay time: "
@@ -3878,6 +3885,9 @@
 msgid "Click on this button to update the nodes list from URL ..."
 msgstr "按此更新节点列表自网址..."
 
+msgid "DLP Info"
+msgstr "动态反吸血信息"
+
 #: src/muuli_wdr.cpp:2652
 msgid "Nodes (0)"
 msgstr "节点（0）"
@@ -4804,7 +4814,7 @@
 
 #: src/Preferences.cpp:770
 msgid "There are no translations installed for aMule"
-msgstr ""
+msgstr "aMule的翻译文件未被安装"
 
 #: src/Preferences.cpp:770
 #, fuzzy
@@ -5145,7 +5155,7 @@
 
 #: src/SearchDlg.cpp:274
 msgid "It's impossible to search when both eD2k and Kademlia are disabled."
-msgstr ""
+msgstr "如果同时禁用了eD2k和Kademlia，则无法进行搜索。"
 
 #: src/SearchDlg.cpp:275
 #, fuzzy
@@ -6992,7 +7002,7 @@
 
 #: src/utils/aLinkCreator/src/ed2khash.cpp:146
 msgid "Out of memory while calculating ed2k hash!"
-msgstr ""
+msgstr "当计算ed2k散列值时内存耗尽！"
 
 #: src/utils/wxCas/src/linuxmon.cpp:77
 #, c-format
@@ -7449,6 +7459,42 @@
 msgstr "正在处理请求 [已重定向]："
 
 #~ msgid ""
+msgid "Dynamic Leecher Protection Options"
+msgstr "动态反吸血保护选项"
+
+msgid "Reload antiLeech"
+msgstr "重新装载 antiLeech"
+
+msgid "Check bad modstring"
+msgstr "根据 Mod 名字检测吸血驴"
+
+msgid "Check bad username"
+msgstr "根据用户名字检测吸血驴"
+
+msgid "Check bad userhash"
+msgstr "检测错误的用户哈希值"
+
+msgid "Check bad hello tag"
+msgstr "根据握手标签(HelloTag)检测吸血驴"
+
+msgid "Check bad info tag"
+msgstr "根据 InfoTag 检测吸血驴"
+
+msgid "Check ghost mod"
+msgstr "检测幽灵客户端(Ghost Mod)"
+
+msgid "Ban eMule VeryCD mod(Please consider carefully whether to use)"
+msgstr "屏蔽 VeryCD eMule（请慎重考虑是否使用）"
+
+msgid "Trying to load antiLeech..."
+msgstr "尝试加载 antiLeech..."
+
+msgid "No antiLeech available!"
+msgstr "未找到 antiLeech!"
+
+msgid "Succeed loading antiLeech! Version: %d"
+msgstr "成功加载 antiLeech! 版本： %d"
+
 #~ "Invalid URL for HTTP download or HTTP redirection (did you forget "
 #~ "'http://' ?)"
 #~ msgstr "非法的HTTP下载或重定向地址（您是否忘记了加“http://”？）"
--- a/src/amuleAppCommon.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/amuleAppCommon.cpp	2021-02-11 23:10:49.000000000 +0800
@@ -64,7 +64,8 @@
 	} else {
 		m_configFile	= wxT("amule.conf");
 		m_logFile		= wxT("logfile");
-
+		//Dynamic Leech Protect - persmule
+		m_dlplogFile = wxT("antileech.log");
 		if (IsDaemon()) {
 			m_appName	= wxT("aMuleD");
 		} else {
@@ -443,6 +444,21 @@
 		return false;
 	}
 
+	// Open the dlp log file - Dynamic Leech Protect - persmule
+	if (!IsRemoteGui()){
+	  CPath dlplogfileName = CPath(thePrefs::GetConfigDir() + m_dlplogFile);
+	  if (dlplogfileName.FileExists()) {
+	    CPath::BackupFile(dlplogfileName, wxT(".bak"));
+	  }
+
+	  if (!dlpLogger.OpenLogfile(dlplogfileName.GetRaw())) {
+	    // use std err as last resolt to indicate problem
+	    fputs("ERROR: unable to open dlp log file\n", stderr);
+	    // failure to open log is serious problem
+	    return false;
+	  }
+	}
+
 	// Load Preferences
 	CPreferences::BuildItemList(thePrefs::GetConfigDir());
 	CPreferences::LoadAllItems( wxConfigBase::Get() );
--- a/src/amule.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/amule.cpp	2021-02-11 23:11:03.000000000 +0800
@@ -87,6 +87,11 @@
 #include <wx/sysopt.h>			// Do_not_auto_remove
 #endif
 
+//Dynamic Leecher Protection - Bill Lee
+#ifdef AMULE_DLP
+#include "DLP.h"
+#endif
+
 #ifndef AMULE_DAEMON
 	#ifdef __WXMAC__
 		#include <CoreFoundation/CFBundle.h>  // Do_not_auto_remove
@@ -517,6 +522,11 @@
 	uploadqueue	= new CUploadQueue();
 	ipfilter	= new CIPFilter();
 
+	//DLP initialization - Bill Lee
+	#ifdef AMULE_DLP
+	theDLP = new DLP();
+	#endif
+
 	// Creates all needed listening sockets
 	wxString msg;
 	if (!ReinitializeNetwork(&msg)) {
@@ -2063,3 +2073,8 @@
 DEFINE_LOCAL_EVENT_TYPE(wxEVT_CORE_UDP_DNS_DONE)
 DEFINE_LOCAL_EVENT_TYPE(wxEVT_CORE_SERVER_DNS_DONE)
 // File_checked_for_headers
+
+//Dynamic Leech Protect - Bill Lee
+#ifdef AMULE_DLP
+DLP* theDLP;
+#endif
--- a/src/amuled.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/amuled.cpp	2021-02-11 23:11:09.000000000 +0800
@@ -783,4 +783,10 @@
 	return 0;	// That's neither yes nor no, ok, cancel
 }
 
+void CamuleDaemonApp::AddDLPMessageLine(const wxString &msg)
+{
+  //Dynamic Leech Protect - persmule
+  DlpAddLogLine(msg);
+}
+
 // File_checked_for_headers
--- a/src/amuleDlg.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/amuleDlg.cpp	2021-02-11 23:11:25.000000000 +0800
@@ -311,7 +311,7 @@
 	wxNotebook* logs_notebook = CastChild( ID_SRVLOG_NOTEBOOK, wxNotebook);
 	wxNotebook* networks_notebook = CastChild( ID_NETNOTEBOOK, wxNotebook);
 
-	wxASSERT(logs_notebook->GetPageCount() == 4);
+	wxASSERT(logs_notebook->GetPageCount() == 5);
 	wxASSERT(networks_notebook->GetPageCount() == 2);
 
 	for (uint32 i = 0; i < logs_notebook->GetPageCount(); ++i) {
@@ -494,7 +494,8 @@
 #ifdef SVNDATE
 	msg << _("Snapshot:") << wxT("\n ") << wxT(SVNDATE);
 #endif
-	msg << wxT("\n\n") << _("'All-Platform' p2p client based on eMule \n\n") <<
+	msg << wxT("\n\n") << _("'All-Platform' p2p client based on eMule, \n") <<
+		_("with Dynamic Leecher Protection. \n\n") <<
 		_("Website: http://www.amule.org \n") <<
 		_("Forum: http://forum.amule.org \n") <<
 		_("FAQ: http://wiki.amule.org \n\n") <<
@@ -502,8 +503,14 @@
 		_("Copyright (c) 2003-2019 aMule Team \n\n") <<
 		_("Part of aMule is based on \n") <<
 		_("Kademlia: Peer-to-peer routing based on the XOR metric.\n") <<
-                _(" Copyright (c) 2002-2011 Petar Maymounkov ( petar@post.harvard.edu )\n") <<
-		_("http://kademlia.scs.cs.nyu.edu\n");
+		_(" Copyright (c) 2002-2011 Petar Maymounkov ( petar@post.harvard.edu )\n") <<
+		_("http://kademlia.scs.cs.nyu.edu\n") <<
+		_("\nDynamic Leech Protection\n") <<
+		_(" Homepage: https://github.com/persmule/amule-dlp \n") <<
+		_(" Copyright (C) 2002-2007 Xtreme-Mod \n") <<
+		_(" Copyright (C) 2009 greensea \n") <<
+		_(" Copyright (C) 2009-2011 Bill Lee \n") <<
+		_(" Copyright (C) 2014 Persmule \n");
 
 	if (m_is_safe_state) {
 		wxMessageBox(msg, _("Message"), wxOK | wxICON_INFORMATION, this);
@@ -657,6 +664,22 @@
 	}
 }
 
+#ifdef AMULE_DLP
+void CamuleDlg::AddDLPMessageLine(const wxString& msg) /* modified by Bill Lee */
+{
+	wxTextCtrl* cv = CastByID( ID_DLPINFO, m_serverwnd, wxTextCtrl );
+	if(cv) {
+		if (msg.Length() > 500) {
+			cv->AppendText(msg.Left(500) + wxT("\n"));
+		} else {
+			cv->AppendText(msg + wxT("\n"));
+		}
+		cv->ShowPosition(cv->GetLastPosition()-1);
+	}
+	//Dynamic Leech Protect - persmule
+	DlpAddLogLine(msg);
+}
+#endif
 
 void CamuleDlg::ShowConnectionState(bool skinChanged)
 {
@@ -1436,6 +1459,8 @@
 		logs_notebook->AddPage(m_logpages[3].page, m_logpages[3].name);
 	}
 
+	logs_notebook->AddPage(m_logpages[4].page, m_logpages[4].name);
+
 	// Set the main window.
 	// If we have both networks active, activate a notebook to select between them.
 	// If only one is active, show the window directly without a surrounding one tab notebook.
--- a/src/amuleDlg.h	2021-02-08 06:25:11.000000000 +0800
+++ b/src/amuleDlg.h	2021-02-11 23:11:33.000000000 +0800
@@ -114,6 +114,9 @@
 
 	void AddLogLine(const wxString& line);
 	void AddServerMessageLine(wxString& message);
+	#ifdef AMULE_DLP
+	void AddDLPMessageLine(const wxString& msg); /* Modified by Bill Lee */
+	#endif
 	void ResetLog(int id);
 
 	void ShowUserCount(const wxString& info = wxEmptyString);
@@ -222,7 +225,7 @@
 	WX_DECLARE_STRING_HASH_MAP(wxZipEntry*, ZipCatalog);
 	ZipCatalog cat;
 
-	PageType m_logpages[4];
+	PageType m_logpages[5];
 	PageType m_networkpages[2];
 
 	bool LoadGUIPrefs(bool override_pos, bool override_size);
--- a/src/amule-gui.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/amule-gui.cpp	2021-02-11 23:11:40.000000000 +0800
@@ -333,6 +333,21 @@
 	return CamuleApp::GetLog(reset);
 }
 
+#ifdef AMULE_DLP
+void CamuleGuiApp::AddDLPMessageLine(const wxString &msg)
+{
+	wxString message;
+	time_t rawtime;
+	struct tm *timeinfo;
+	char tbuf[101];
+	time(&rawtime);
+	timeinfo = localtime(&rawtime);
+	strftime(tbuf, 100, "%Y-%m-%d %X: ", timeinfo);
+
+	message = wxString(tbuf, wxConvUTF8) + msg;
+	amuledlg->AddDLPMessageLine(message);
+}
+#endif
 
 wxString CamuleGuiApp::GetServerLog(bool reset)
 {
--- a/src/amule.h	2021-02-08 06:25:11.000000000 +0800
+++ b/src/amule.h	2021-02-11 23:11:54.000000000 +0800
@@ -134,6 +134,8 @@
 	bool		m_geometryEnabled;
 	wxString	m_geometryString;
 	wxString	m_logFile;
+	//Dynamic Leech Protect - persmule
+	wxString	m_dlplogFile;
 	wxString	m_appName;
 	wxString	m_PidFile;
 
@@ -409,6 +411,7 @@
 	wxString GetLog(bool reset = false);
 	wxString GetServerLog(bool reset = false);
 	void AddServerMessageLine(wxString &msg);
+	void AddDLPMessageLine(const wxString &msg);
 	DECLARE_EVENT_TABLE()
 };
 
@@ -573,6 +576,8 @@
 
 	virtual int ShowAlert(wxString msg, wxString title, int flags);
 
+	void AddDLPMessageLine(const wxString &msg);
+
 	DECLARE_EVENT_TABLE()
 };
 
@@ -583,3 +588,8 @@
 
 #endif // AMULE_H
 // File_checked_for_headers
+
+#ifdef AMULE_DLP
+class DLP;	//forward declaretion
+extern DLP* theDLP;
+#endif
--- a/src/antiLeech.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/antiLeech.h	2020-05-31 20:19:13.000000000 +0800
@@ -0,0 +1,48 @@
+#ifndef ANTILEECH_H
+#define ANTILEECH_H
+
+
+#pragma once
+
+#include "antiLeech_wx.h"
+#include "CString_wx.h"
+
+class IantiLeech 
+{
+public:
+	virtual ~IantiLeech(){};                /* Bill Lee: Not be used currently */
+	//BOOL WINAPI DllMain(HINSTANCE hinstDLL,DWORD,LPVOID);
+	virtual DWORD GetDLPVersion() = 0;
+	//old versions to keep compatible
+	/* //drop old version support
+	virtual LPCTSTR DLPCheckModstring(LPCTSTR modversion, LPCTSTR clientversion);
+	virtual LPCTSTR DLPCheckUsername(LPCTSTR username);
+	virtual LPCTSTR DLPCheckNameAndHash(CString username, CString& userhash);
+	*/
+	//new versions
+	virtual LPCTSTR DLPCheckModstring_Hard(LPCTSTR modversion, LPCTSTR clientversion) = 0;
+	virtual LPCTSTR DLPCheckModstring_Soft(LPCTSTR modversion, LPCTSTR clientversion) = 0;
+	virtual LPCTSTR DLPCheckUsername_Hard(LPCTSTR username) = 0;
+	virtual LPCTSTR DLPCheckUsername_Soft(LPCTSTR username) = 0;
+	virtual LPCTSTR DLPCheckNameAndHashAndMod(const CString& username, const CString& userhash, const CString& modversion) = 0;
+	virtual LPCTSTR DLPCheckMessageSpam(LPCTSTR messagetext) = 0;
+
+
+	virtual LPCTSTR DLPCheckUserhash(const PBYTE userhash) = 0;
+
+
+	virtual LPCTSTR DLPCheckHelloTag(UINT tagnumber) = 0;
+	virtual LPCTSTR DLPCheckInfoTag(UINT tagnumber) = 0;
+
+	//void  TestFunc();
+
+//Bill Lee: no need in interface abstract class
+//private:
+//	static bool IsTypicalHex (const CString& addon);
+};
+
+//Bill Lee: never call delete on IantiLeech, use destoryAntiLeechInstat instead.
+extern "C" IantiLeech* createAntiLeechInstant();
+extern "C" int destoryAntiLeechInstant(IantiLeech*);
+
+#endif
--- a/src/antiLeech_wx.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/antiLeech_wx.h	2020-05-31 20:19:13.000000000 +0800
@@ -0,0 +1,49 @@
+#ifndef ANTILEECH_WX_H
+#define ANTILEECH_WX_H
+
+#include <wx/defs.h>
+#include <string.h>
+
+#define LPCTSTR		const wxChar* 
+#define BOOL		bool
+//#define _T(var)		wxT(var)	//defined in wxWidgets
+#define DWORD		wxUint32
+#define UINT		wxUint16
+#define WINAPI
+#define HINSTANCE
+#define LPVOID		void*
+#define PBYTE		unsigned char*
+#define TCHAR		wxChar
+#define _TINT		wxInt32
+
+#define StrCmpI _tcsicmp
+
+#define _istdigit(var)		iswdigit(var)
+#define _istcntrl(var)		iswcntrl(var)
+#define _istpunct(var)		iswpunct(var)
+#define _istspace(var)		iswspace(var)
+#define _istxdigit(var)		iswxdigit(var)
+inline float _tstof(const wchar_t* str){
+	wchar_t** ptail = NULL;
+	return wcstof(str, ptail);
+}
+//This function is not used. by Orzogc Lee
+//But I think there is no need to removing, linker will remove it.
+/*
+inline void tolowers(wxChar* str){
+	int i = 0;
+	do{
+		str[i] = towlower(str[i]);
+	}while(str[++i]);
+}
+*/
+#define _tcsstr(haystack, needle)	wcsstr(haystack, needle)
+#define _tcslen(var)		wcslen(var)
+#define StrStr(a, b)		wcsstr(a, b)
+
+LPCTSTR StrStrI(LPCTSTR haystack, LPCTSTR needle);
+//Bill Lee: I think inlining this function make no senses, because it is a very large operation.
+
+#define _tcsicmp(a, b)		wcscasecmp(a, b)
+
+#endif
--- a/src/BaseClient.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/BaseClient.cpp	2021-02-11 23:12:21.000000000 +0800
@@ -23,6 +23,11 @@
 // Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA
 //
 
+//Dynamic Leech Protect - Bill Lee
+#ifdef AMULE_DLP
+#include "DLP.h"
+#endif
+
 #include <wx/wx.h>
 #include <wx/mstream.h>
 #include <wx/tokenzr.h>
@@ -290,6 +295,10 @@
 	m_cMessagesReceived = 0;
 	m_cMessagesSent = 0;
 
+	#ifdef AMULE_DLP
+	dlp_nonofficialopcodes = false; //Dynamic Leecher Protect
+	#endif
+
 }
 
 
@@ -635,6 +644,15 @@
 				m_fSharedDirectories = 1;
 				dwEmuleTags |= 4;
 				break;
+			//Bill Lee start
+			//Dynamic Leecher Protection
+			#ifdef AMULE_DLP
+			default:	//if tag isn't those above, it may be used by leecher.
+				theDLP->CheckHelloTag(this, temptag.GetNameID());
+				dlp_nonofficialopcodes = true; //to detect Ghost Mod
+					break;
+			//Bill Lee end
+			#endif
 		}
 	}
 
@@ -717,6 +735,12 @@
 		Kademlia::CKademlia::Bootstrap(wxUINT32_SWAP_ALWAYS(GetIP()), GetKadPort());
 	}
 
+	//Dynamic Leecher Protection - Bill Lee
+	#ifdef AMULE_DLP
+	if(theDLP->IsValid())
+	  theDLP->DLPCheck(this);
+	#endif
+
 	return bIsMule;
 }
 
@@ -966,6 +990,14 @@
 							% GetClientFullInfo()
 					);
 
+					//Bill Lee start
+					//Dynamic Leecher Protection
+					#ifdef AMULE_DLP
+					theDLP->CheckInfoTag(this, temptag.GetNameID());
+					dlp_nonofficialopcodes = true;
+					#endif
+					//Bill Lee end
+
 					break;
 			}
 		}
@@ -1003,6 +1035,12 @@
 		m_byInfopacketsReceived |= IP_EMULEPROTPACK;
 	}
 
+	//Dynamic Leecher Protection - Added by Bill Lee
+	#ifdef AMULE_DLP
+	if(theDLP->IsValid())
+	  theDLP->DLPCheck(this);
+	#endif
+
 	return (protocol_version == 0xFF); // This was a OS_Info?
 }
 
@@ -1033,7 +1071,8 @@
 	}
 	tagcount ++; // eMule misc flags 2 (kad version)
 
-	#ifdef __SVN__
+	#if (defined __SVN__ || defined AMULE_DLP)
+
 	// Kry - This is the tagcount!!! Be sure to update it!!
 	// Last update: CT_EMULECOMPAT_OPTIONS included
 	data->WriteUInt32(tagcount + 1);
@@ -1156,7 +1195,7 @@
 
 	tagMisCompatOptions.WriteTagToFile(data);
 
-#ifdef __SVN__
+#if (defined __SVN__ || defined AMULE_DLP)
 	wxString mod_name(MOD_VERSION_LONG);
 	CTagString tagModName(ET_MOD_VERSION, mod_name);
 	tagModName.WriteTagToFile(data);
@@ -2303,7 +2342,12 @@
 }
 
 
-#ifdef __DEBUG__
+#if defined (__DEBUG__) || defined (AMULE_DLP)
+/* 
+ * This function is essential for dlp to produce ban log.
+ * So I decide to retain it when dlp is enabled.
+ * by Persmule.
+ */
 wxString CUpDownClient::GetClientFullInfo()
 {
 	if (m_clientVerString.IsEmpty()) {
--- a/src/CString_wx.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/CString_wx.h	2020-05-31 20:19:13.000000000 +0800
@@ -0,0 +1,63 @@
+/**
+ * Author:	Bill Lee<bill.lee.y@gmail.com>
+ * License:	GNU GPL
+ */
+//---------------------
+#ifndef CSTRING_WX_H
+#define CSTRING_WX_H
+
+//#include <wx/wx.h>
+#include <wx/string.h>
+
+class CString : public wxString{
+	public:
+		CString(){}
+		CString(wxChar c, size_t n=1): wxString(c, n){}
+		CString(const wxChar* str): wxString(str){}
+		CString(const wxString& str): wxString(str){}
+		CString(const CString& str): wxString(str){}
+		//---------------------
+		CString& operator=(const wxChar* str){
+			wxString::operator=(str);
+			return *this;
+		}
+		//operator*() from wxString;
+		size_t GetLength()const{	return Length();	}
+		wxChar GetAt(size_t nIndex)const{	return GetChar(nIndex);	}
+		//IsEmpty() from wxString;
+		CString& TrimLeft(wxChar c){
+			size_t pos = find_first_not_of(c);
+			if(pos == 0)
+				return *this;
+			erase(0, pos);
+			return *this;
+		}
+		CString& TrimRight(wxChar c){
+			size_t pos = find_last_not_of(c) + 1;
+			if(pos == Length())
+				return *this;
+			erase(pos, Length() - pos);
+			return *this;
+		}
+		CString Trim(){
+			CString ret(*this);
+			ret.wxString::Trim(false);        /* wxString::Trim(bool fromright = true) */
+			ret.wxString::Trim(true);
+			return ret;
+		}
+		//Find(wxChar) and Find(wxChar*) from wxString;
+		int Find(const CString& str)const{	return wxString::Find(str.c_str());	}
+		int ReverseFind(const wxChar c)const{	return wxString::Find(c, true);	}
+		int ReverseFind(const wxChar* str)const{	return rfind(str);	}
+		int ReverseFind(const CString& str)const{	return rfind(str);	}
+		CString Right(size_t len)const{	return wxString::Right(len);	}
+		CString Left(size_t len)const{	return wxString::Left(len);	}
+#if wxCHECK_VERSION(2, 9, 0)
+		CString Mid(size_t first, size_t count = wxString::npos)const{
+#else
+		CString Mid(size_t first, size_t count = wxSTRING_MAXLEN)const{
+#endif
+			return wxString::Mid(first, count);
+		}
+};
+#endif
--- a/src/DLP.cpp	1970-01-01 08:00:00.000000000 +0800
+++ b/src/DLP.cpp	2020-05-31 20:19:13.000000000 +0800
@@ -0,0 +1,186 @@
+// Copyright (C) 2011 Bill Lee <bill.lee.y@gmail.com>, 2014 Persmule <persmule@gmail.com>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA
+//
+#include "Logger.h"
+
+#include "DLP.h"
+#include "antiLeech.h"
+#include <wx/dynlib.h>                          /* Needed for wxDynamicLibrary */
+
+#include "DLPPref.h"
+#include "Preferences.h"	// Needed for CPreferences
+#include "amule.h"		// Needed for theApp
+
+#include <wx/stdpaths.h>                        /* Needed for wxStandardPaths */
+
+#define PRE_CHECK(tag)	if( (!c->IsBanned()) && antiLeech && (thePrefs::GetDLPCheckMask() & tagn) )
+
+void DLP::CheckHelloTag(CUpDownClient* c, UINT tagn){
+	PRE_CHECK(PF_HELLOTAG){
+		const wxChar* dlp_result = antiLeech->DLPCheckHelloTag(tagn);
+		if(dlp_result != NULL) {
+			wxString ret;
+			ret.Printf(_("[HelloTag %s] %s"), dlp_result, c->GetClientFullInfo().c_str());
+			c->Ban();
+			theApp->AddDLPMessageLine(ret);
+		}
+	}
+}
+
+void DLP::CheckInfoTag(CUpDownClient* c, UINT tagn){
+	PRE_CHECK(PF_INFOTAG){
+		const wxChar* dlp_result = antiLeech->DLPCheckInfoTag(tagn);
+		if(dlp_result != NULL) {
+			wxString ret;
+			ret.Printf(_("[InfoTag %s] %s"), dlp_result, c->GetClientFullInfo().c_str());
+			c->Ban();
+			theApp->AddDLPMessageLine(ret);
+		}
+	}
+}
+
+bool DLP::DLPCheck(CUpDownClient* c){
+	const wxChar* tmp = NULL;
+	wxString ret;
+	
+	unsigned int prefs = thePrefs::GetDLPCheckMask();
+
+	CString modver(c->GetClientModString());
+	CString clientver(c->GetClientVerString());
+	CString uname(c->GetUserName());
+	CString uhash(wxString(c->GetUserHash().EncodeSTL().c_str(), wxConvUTF8));
+	
+	//CheckGhostMod
+	if(prefs & PF_GHOSTMOD) {
+		if(c->HasNonOfficialOpCodes() && (modver.IsEmpty())) {
+			ret = _("GhostMod");
+			tmp = ret.c_str(); //char pointer
+		}
+	}
+
+	// Check bad modstring
+	if ((prefs & PF_MODSTRING) && (tmp == NULL)) {
+		if((tmp = antiLeech->DLPCheckModstring_Soft(modver.c_str(), clientver.c_str())) == NULL)
+			tmp = antiLeech->DLPCheckModstring_Hard(modver.c_str(), clientver.c_str());
+	}
+	/*
+	if ((prefs & PF_USERHASH) && (tmp == NULL)) {
+		// not finished
+	}
+	*/
+	// Check bad username
+	if ((prefs & PF_USERNAME) && (tmp == NULL)) {
+		if ((tmp = antiLeech->DLPCheckNameAndHashAndMod(uname, uhash, modver)) == NULL){
+			if( (tmp = antiLeech->DLPCheckUsername_Hard(uname.c_str())) == NULL )
+				tmp = antiLeech->DLPCheckUsername_Soft(uname.c_str());
+		}
+	}
+	
+
+	// Check VeryCD eMule
+	if ((prefs & PF_VERYCDEMULE) && (tmp == NULL)) {
+		if(modver.Find(wxT("VeryCD")) != wxNOT_FOUND){
+			ret = _("VeryCD Mod");
+			tmp = ret.c_str();
+		}
+	}
+	
+	if (tmp != NULL) {
+		ret = tmp;
+		wxString wxInfo;
+		wxInfo.Printf(wxT("[%s] %s"), ret.c_str(), c->GetClientFullInfo().c_str());
+		c->Ban();
+		theApp->AddDLPMessageLine(wxInfo);
+		return true;
+	}
+
+	return false;
+
+}
+
+int DLP::ReloadAntiLeech(){
+	//Unloading
+	AddLogLineN(  _("Checking if there is a antiLeech working..."));
+	if(antiLeechLib.IsLoaded()){
+		Destoryer fn = (Destoryer)(antiLeechLib.GetSymbol( wxT("destoryAntiLeechInstant")));
+		wxASSERT(fn);
+		AddLogLineN(  _("Unload previous antiLeech..."));
+		fn(antiLeech);
+		antiLeech = NULL;
+		antiLeechLib.Unload();
+	}
+	else
+		AddLogLineN(  _("No working antiLeech exists."));
+	//Get lib's location
+	wxStandardPathsBase &spb(wxStandardPaths::Get());
+#ifdef __WXMSW__
+	wxString dataDir(spb.GetPluginsDir());
+#elif defined(__WXMAC__)
+	wxString dataDir(spb.GetDataDir());
+#else
+	wxString dataDir(spb.GetDataDir().BeforeLast(wxT('/')) + wxT("/amule"));
+#endif
+	wxString localName = wxDynamicLibrary::CanonicalizeName(wxT("antiLeech"));
+	wxString systemwideFile(JoinPaths(dataDir, localName));
+	wxString userFile(thePrefs::GetConfigDir() + localName);
+	wxString fallbackFile(wxT("antiLeech"));
+	//Try to load lib;
+	AddLogLineN(  _("Trying to load antiLeech..."));
+	if( !LoadFrom(userFile) ){
+		if( !LoadFrom(systemwideFile) ){
+			if( !LoadFrom(fallbackFile) ){
+				AddLogLineC(  _("No antiLeech available!"));
+				return 1;	//Not found
+			}
+		}
+	}
+	//Searching symbol "createAntiLeechInstant"
+	Creator fn = (Creator)(antiLeechLib.GetSymbol( wxT("createAntiLeechInstant") ));
+	if(!fn){
+		antiLeechLib.Unload();
+		AddLogLineC(  _("antiLeech found, but it seems not to be a valid antiLeech!"));
+		return 2;	//Found, but isn't antiLeech
+	}
+	//Try to create antiLeech
+	antiLeech = fn();
+	if(antiLeech){
+		wxString logline;
+		logline.Printf(_("Succeed loading antiLeech! Version: %d"), antiLeech->GetDLPVersion());
+		AddLogLineC( logline);
+		return 0;
+	}
+	//else
+	antiLeechLib.Unload();
+	AddLogLineC(  _("FAIL! An error occur when setting up antiLeech."));
+	return 3;	//Fail to create antiLeech instant
+
+}
+
+DLP::~DLP(){
+	if(antiLeechLib.IsLoaded()){
+		Destoryer fn = (Destoryer)(antiLeechLib.GetSymbol( wxT("destoryAntiLeechInstant")));
+		wxASSERT(fn);
+		AddLogLineN(  _("Unload previous antiLeech..."));
+		fn(antiLeech);
+		//antiLeech = NULL;
+		//antiLeechLib.Unload();
+	}
+}
+
+bool DLP::LoadFrom(wxString& file){
+	antiLeechLib.Load(file);
+	return antiLeechLib.IsLoaded();
+}
--- a/src/DLP.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/DLP.h	2020-05-31 20:19:13.000000000 +0800
@@ -0,0 +1,48 @@
+// Copyright (C) 2011 Bill Lee <bill.lee.y@gmail.com>, 2014 Persmule <persmule@gmail.com>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA
+//
+
+class IantiLeech;	//forward declaretion
+
+#include "updownclient.h"	// Needed for CUpDownClient
+#include "antiLeech_wx.h"
+
+#include <wx/dynlib.h>
+
+class DLP
+{
+public:
+	DLP() : antiLeech(NULL) {	DLPInitState=ReloadAntiLeech();	}
+	~DLP();
+
+	void CheckHelloTag(CUpDownClient*, UINT tagnumber);
+	void CheckInfoTag(CUpDownClient*, UINT tagnumber);
+	bool DLPCheck(CUpDownClient*);
+
+	int ReloadAntiLeech();
+	int GetInitState(void){return DLPInitState;}
+	bool IsValid(void){return (0==DLPInitState);}
+
+private:
+	typedef IantiLeech* (*Creator)();
+	typedef int (*Destoryer)(IantiLeech*);
+
+	wxDynamicLibrary antiLeechLib;
+	IantiLeech* antiLeech;
+	int DLPInitState;
+
+	bool LoadFrom(wxString& file);
+};
--- a/src/DLPPref.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/DLPPref.h	2020-05-31 20:19:13.000000000 +0800
@@ -0,0 +1,15 @@
+#ifndef ANTILEECH_AMULE_H
+#define ANTILEECH_AMULE_H
+
+/* Define DLPCheck prefs arg */
+#define PF_MODSTRING	0x1
+#define PF_USERHASH		0x2
+#define PF_USERNAME		0x4
+#define PF_HELLOTAG		0x8
+#define PF_INFOTAG		0x10
+#define PF_VERYCDEMULE	0x20
+//#define PF_EASYMULE		0x40
+//#define PF_MINIMULE	0x80
+#define PF_GHOSTMOD	0x100
+
+#endif
--- a/src/DownloadQueue.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/DownloadQueue.cpp	2021-02-11 23:12:27.000000000 +0800
@@ -623,6 +623,15 @@
 		return;
 	}
 
+	//Dynamic Leecher Protect - Bill Lee
+	#ifdef AMULE_DLP
+	if ( source->IsBanned() ){
+		source->Safe_Delete();
+		return;
+	}
+	#endif
+	//Bill Lee end
+
 	// Filter sources which are known to be dead/useless
 	if ( theApp->clientlist->IsDeadSource( source ) || sender->IsDeadSource(source) ) {
 		source->Safe_Delete();
--- a/src/ExternalConn.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/ExternalConn.cpp	2021-02-11 23:12:35.000000000 +0800
@@ -55,6 +55,9 @@
 #include "kademlia/kademlia/UDPFirewallTester.h"
 #include "Statistics.h"
 
+#ifdef AMULE_DLP
+#include "DLP.h"
+#endif
 
 //-------------------- File_Encoder --------------------
 
@@ -1388,6 +1391,15 @@
 				}
 			}
 			break;
+		//Dynamic Leech Protect - Bill Lee
+		#ifdef AMULE_DLP
+		case EC_OP_ANTILEECH_RELOAD:
+			if( theDLP->ReloadAntiLeech() )
+				response = new CECPacket(EC_OP_FAILED);
+			else
+				response = new CECPacket(EC_OP_NOOP);
+			break;
+		#endif
 		//
 		// Status requests
 		//
--- a/src/libs/ec/abstracts/ECCodes.abstract	2021-02-08 06:25:11.000000000 +0800
+++ b/src/libs/ec/abstracts/ECCodes.abstract	2021-02-11 23:10:18.000000000 +0800
@@ -148,6 +148,8 @@
 
 EC_OP_FRIEND                        0x57
 
+EC_OP_ANTILEECH_RELOAD              0x80	
+
 [/Section]
 
 [Section Content]
--- a/src/libs/ec/cpp/ECCodes.h	2021-02-08 06:25:11.000000000 +0800
+++ b/src/libs/ec/cpp/ECCodes.h	2021-02-11 23:10:27.000000000 +0800
@@ -121,7 +121,8 @@
 	EC_OP_CLIENT_SWAP_TO_ANOTHER_FILE   = 0x54,
 	EC_OP_SHARED_FILE_SET_COMMENT       = 0x55,
 	EC_OP_SERVER_SET_STATIC_PRIO        = 0x56,
-	EC_OP_FRIEND                        = 0x57
+	EC_OP_FRIEND                        = 0x57,
+	EC_OP_ANTILEECH_RELOAD              = 0x80
 };
 
 enum ECTagNames {
@@ -556,6 +557,7 @@
 		case 0x55: return wxT("EC_OP_SHARED_FILE_SET_COMMENT");
 		case 0x56: return wxT("EC_OP_SERVER_SET_STATIC_PRIO");
 		case 0x57: return wxT("EC_OP_FRIEND");
+		case 0x80: return wxT("EC_OP_ANTILEECH_RELOAD");
 		default: return CFormat(wxT("unknown %d 0x%x")) % arg % arg;
 	}
 }
--- a/src/libs/ec/java/ECCodes.java	2021-02-08 06:25:11.000000000 +0800
+++ b/src/libs/ec/java/ECCodes.java	2021-02-11 23:10:34.000000000 +0800
@@ -112,6 +112,7 @@
 public final static byte EC_OP_SHARED_FILE_SET_COMMENT       = 0x55;
 public final static byte EC_OP_SERVER_SET_STATIC_PRIO        = 0x56;
 public final static byte EC_OP_FRIEND                        = 0x57;
+public final static byte EC_OP_ANTILEECH_RELOAD              = 0x80;
 
 public final static short EC_TAG_STRING                             = 0x0000;
 public final static short EC_TAG_PASSWD_HASH                        = 0x0001;
--- a/src/LoggerConsole.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/LoggerConsole.cpp	2021-02-11 23:12:40.000000000 +0800
@@ -94,6 +94,8 @@
 }
 
 CLogger theLogger;
+//Dynamic Leech Protect - persmule
+CLogger dlpLogger;
 
 BEGIN_EVENT_TABLE(CLogger, wxEvtHandler)
 END_EVENT_TABLE()
--- a/src/Logger.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/Logger.cpp	2021-02-11 23:12:46.000000000 +0800
@@ -297,6 +297,8 @@
 }
 
 CLogger theLogger;
+//Dynamic Leech Protect - persmule
+CLogger dlpLogger;
 
 BEGIN_EVENT_TABLE(CLogger, wxEvtHandler)
 	EVT_MULE_LOGGING(CLogger::OnLoggingEvent)
--- a/src/Logger.h	2021-02-08 06:25:11.000000000 +0800
+++ b/src/Logger.h	2021-02-11 23:12:53.000000000 +0800
@@ -310,6 +310,8 @@
 };
 
 extern CLogger theLogger;
+//Dynamic Leech Protect - persmule
+extern CLogger dlpLogger;
 
 /**
  * This class forwards log-lines from wxWidgets to CLogger.
@@ -456,5 +458,8 @@
 	#define AddLogLineF(string) theLogger.AddLogLine(__TFILE__, __LINE__, false, logStandard, string, false, false)
 #endif
 
+//Dynamic Leech Protect - persmule
+#define DlpAddLogLine(string) dlpLogger.AddLogLine(__TFILE__, __LINE__, false, logStandard, string, false, false)
+
 #endif
 // File_checked_for_headers
--- a/src/Makefile.am	2021-02-08 06:25:11.000000000 +0800
+++ b/src/Makefile.am	2021-02-11 23:12:59.000000000 +0800
@@ -178,6 +178,13 @@
 	kademlia/routing/RoutingZone.cpp
 
 
+#Dynamic Leecher Protection - Bill Lee
+if ENABLE_DLP
+core_sources += \
+	DLP.cpp
+AM_CPPFLAGS += -DAMULE_DLP
+endif
+
 gui_sources = \
 	amule-gui.cpp \
 	amuleDlg.cpp \
--- a/src/muuli_wdr.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/muuli_wdr.cpp	2021-02-11 23:13:14.000000000 +0800
@@ -1772,6 +1772,51 @@
     return item0;
 }
 
+#ifdef AMULE_DLP
+wxSizer *PreferencesDLPTab( wxWindow *parent, bool call_fit, bool set_sizer )
+{
+	wxBoxSizer *item0 = new wxBoxSizer( wxVERTICAL );
+
+	wxButton* btnReload = new wxButton( parent, IDC_RELOADANTILEECH, _("Reload antiLeech"), wxDefaultPosition, wxDefaultSize, 0 ); //Bill Lee
+
+	wxStaticBox *item2 = new wxStaticBox( parent, -1, _("Dynamic Leecher Protection Options") );
+	wxStaticBoxSizer *item1 = new wxStaticBoxSizer( item2, wxVERTICAL );
+
+	wxCheckBox *item4 = new wxCheckBox( parent, IDC_CHECKMODSTRING, _("Check bad modstring"), wxDefaultPosition, wxDefaultSize, 0 );
+	item1->Add( item4, 0, wxALIGN_CENTER_VERTICAL, 5 );
+
+	wxCheckBox *item5 = new wxCheckBox( parent, IDC_CHECKUSERNAME, _("Check bad username"), wxDefaultPosition, wxDefaultSize, 0 );
+	item1->Add( item5, 0, wxALIGN_CENTER_VERTICAL, 5 );
+
+	wxCheckBox *item6 = new wxCheckBox( parent, IDC_CHECKUSERHASH, _("Check bad userhash"), wxDefaultPosition, wxDefaultSize, 0 );
+	item1->Add( item6, 0, wxALIGN_CENTER_VERTICAL, 5 );
+
+	wxCheckBox *item7 = new wxCheckBox( parent, IDC_CHECKHELLOTAG, _("Check bad hello tag"), wxDefaultPosition, wxDefaultSize, 0 );
+	item1->Add( item7, 0, wxALIGN_CENTER_VERTICAL, 5 );
+
+	wxCheckBox *item8 = new wxCheckBox( parent, IDC_CHECKINFOTAG, _("Check bad info tag"), wxDefaultPosition, wxDefaultSize, 0 );
+	item1->Add( item8, 0, wxALIGN_CENTER_VERTICAL, 5 );
+
+	wxCheckBox *item9 = new wxCheckBox( parent, IDC_CHECKGHOSTMOD, _("Check ghost mod"), wxDefaultPosition, wxDefaultSize, 0);
+	item1->Add( item9, 0, wxALIGN_CENTER_VERTICAL, 5 );
+
+	wxCheckBox *item10 = new wxCheckBox( parent, IDC_CHECKVERYCDMOD, _("Ban eMule VeryCD mod(Please consider carefully whether to use)"), wxDefaultPosition, wxDefaultSize, 0 ); //Modified by Bill Lee
+	item1->Add( item10, 0, wxALIGN_CENTER_VERTICAL, 5 );
+
+	item0->Add( btnReload, 0, wxGROW|wxALL, 5); //Bill Lee
+	item0->Add( item1, 0, wxGROW|wxALL, 5 );
+
+	if (set_sizer)
+	{
+	parent->SetSizer( item0 );
+	if (call_fit)
+	    item0->SetSizeHints( parent );
+	}
+
+	return item0;
+}
+#endif
+
 wxSizer *PreferencesFilesTab( wxWindow *parent, bool call_fit, bool set_sizer )
 {
     wxBoxSizer *item0 = new wxBoxSizer( wxVERTICAL );
@@ -2590,6 +2635,42 @@
     return item0;
 }
 
+wxSizer *DLPInfoLog( wxWindow *parent, bool call_fit, bool set_sizer )
+{
+    wxBoxSizer *item0 = new wxBoxSizer( wxVERTICAL );
+
+    wxBoxSizer *item1 = new wxBoxSizer( wxHORIZONTAL );
+
+    wxStaticBitmap *item2 = new wxStaticBitmap( parent, -1, amuleDlgImages( 3 ), wxDefaultPosition, wxDefaultSize );
+    item2->SetToolTip( _("Display DLP log") );
+    item1->Add( item2, 0, wxALIGN_CENTER|wxALL, 5 );
+
+    wxStaticText *item3 = new wxStaticText( parent, -1, _("DLP Info"), wxDefaultPosition, wxDefaultSize, 0 );
+    item1->Add( item3, 0, wxALIGN_CENTER|wxALL, 5 );
+
+    item0->Add( item1, 0, wxALIGN_CENTER_VERTICAL, 5 );
+
+    wxBoxSizer *item4 = new wxBoxSizer( wxHORIZONTAL );
+
+    CMuleTextCtrl *item5 = new CMuleTextCtrl( parent, ID_DLPINFO, wxT(""), wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE|wxTE_READONLY|wxVSCROLL );
+    item4->Add( item5, 1, wxGROW|wxALIGN_CENTER_HORIZONTAL, 5 );
+
+    wxButton *item6 = new wxButton( parent, ID_BTN_RESET_DLP, _("Reset"), wxDefaultPosition, wxDefaultSize, 0 );
+    item6->SetToolTip( _("Click this button to reset the log.") );
+    item4->Add( item6, 0, wxGROW|wxALIGN_CENTER_HORIZONTAL|wxALL, 5 );
+
+    item0->Add( item4, 1, wxGROW|wxALIGN_CENTER_VERTICAL, 5 );
+
+    if (set_sizer)
+    {
+        parent->SetSizer( item0 );
+        if (call_fit)
+            item0->SetSizeHints( parent );
+    }
+    
+    return item0;
+}
+
 wxSizer *serverListDlgDown( wxWindow *parent, bool call_fit, bool set_sizer )
 {
     wxStaticBox *item1 = new wxStaticBox( parent, -1, wxT("") );
@@ -2618,6 +2699,10 @@
     Kad_Info( item7, FALSE );
     item3->AddPage( item7, _("Kad Info") );
 
+	wxPanel *item8 = new wxPanel( item3, -1);
+	DLPInfoLog( item8, FALSE);
+	item3->AddPage(item8, _("DLP Info"));
+
     item0->Add( item2, 1, wxGROW|wxALIGN_CENTER_VERTICAL, 5 );
 
     if (set_sizer)
--- a/src/muuli_wdr.h	2021-02-08 06:25:11.000000000 +0800
+++ b/src/muuli_wdr.h	2021-02-11 23:13:22.000000000 +0800
@@ -336,6 +336,10 @@
 #define ID_BTN_RESET_SERVER 10241
 wxSizer *ServerInfoLog( wxWindow *parent, bool call_fit = TRUE, bool set_sizer = TRUE );
 
+#define ID_DLPINFO 22001
+#define ID_BTN_RESET_DLP 22002
+wxSizer *DLPInfoLog( wxWindow *parent, bool call_fit = TRUE, bool set_sizer = TRUE );
+
 #define ID_LOGVIEW 10242
 #define ID_BTN_RESET 10243
 wxSizer *aMuleLog( wxWindow *parent, bool call_fit = TRUE, bool set_sizer = TRUE );
@@ -425,6 +429,21 @@
 #define ID_DEBUGCATS 10308
 wxSizer *PreferencesDebug( wxWindow *parent, bool call_fit = TRUE, bool set_sizer = TRUE );
 
+/* Dynamic Leecher Protection */
+#define IDC_CHECKMODSTRING 11001
+#define IDC_CHECKUSERNAME 11002
+#define IDC_CHECKUSERHASH 11003
+#define IDC_CHECKHELLOTAG 11004
+#define IDC_CHECKINFOTAG 11005
+#define IDC_CHECKEASYMULE 11006
+#define IDC_CHECKVERYCDMOD 11007
+#define IDC_CHECKMINIMULE 11008
+#define IDC_CHECKGHOSTMOD 11009
+#ifdef AMULE_DLP
+#define IDC_RELOADANTILEECH 11010 //Bill Lee
+wxSizer *PreferencesDLPTab( wxWindow *parent, bool call_fit = TRUE, bool set_sizer = TRUE );
+#endif
+
 extern wxSizer *IDC_CURJOB;
 #define IDC_CONV_PB_LABEL 10309
 #define IDC_CONV_PROZENT 10310
--- a/src/Preferences.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/Preferences.cpp	2021-02-11 23:13:42.000000000 +0800
@@ -49,6 +49,11 @@
 
 #include "UserEvents.h"
 
+#ifdef AMULE_DLP
+#include "DLPPref.h"
+#include "antiLeech.h"
+#endif
+
 #ifndef AMULE_DAEMON
 #include <wx/valgen.h>
 #include "muuli_wdr.h"
@@ -343,6 +348,19 @@
 	wxWindow*	m_widget;
 };
 
+/* Dynamic Leecher Protection */
+#ifdef AMULE_DLP
+bool CPreferences::s_DLPCheckModString;
+bool CPreferences::s_DLPCheckUsername;
+bool CPreferences::s_DLPCheckUserHash;
+bool CPreferences::s_DLPCheckHelloTag;
+bool CPreferences::s_DLPCheckInfoTag;
+//bool CPreferences::s_DLPCheckEasyMule;
+bool CPreferences::s_DLPCheckVeryCDMod;
+//bool CPreferences::s_DLPCheckminiMule; //Added by Bill Lee
+bool CPreferences::s_DLPCheckGhostMod;
+unsigned int CPreferences::s_DLPCheckMask;
+#endif
 
 /** Cfg class for wxStrings. */
 class Cfg_Str : public Cfg_Tmpl<wxString>
@@ -952,6 +970,11 @@
 	s_userhash[5] = 14;
 	s_userhash[14] = 111;
 
+	// Dynamic Leecher Protection
+	#ifdef AMULE_DLP
+	CalcDLPCheckMask();
+	#endif
+
 #ifndef CLIENT_GUI
 	LoadPreferences();
 	ReloadSharedFolders();
@@ -1061,6 +1084,20 @@
 	NewCfgItem( IDC_NETWORKKAD, (new Cfg_Bool( wxT("/eMule/ConnectToKad"),	s_ConnectToKad, true )) );
 	NewCfgItem( IDC_NETWORKED2K, ( new Cfg_Bool( wxT("/eMule/ConnectToED2K"),	s_ConnectToED2K, true ) ));
 
+	/**
+	 * Dynamic Leecher Protection
+	 **/
+	#ifdef AMULE_DLP
+	NewCfgItem(IDC_CHECKMODSTRING, 		(new Cfg_Bool( wxT("/DLP/CheckModString"), s_DLPCheckModString, true )));
+	NewCfgItem(IDC_CHECKUSERNAME, 		(new Cfg_Bool( wxT("/DLP/CheckUsername"), s_DLPCheckUsername, true )));
+	NewCfgItem(IDC_CHECKUSERHASH, 		(new Cfg_Bool( wxT("/DLP/CheckUserHash"), s_DLPCheckUserHash, true )));
+	NewCfgItem(IDC_CHECKHELLOTAG, 		(new Cfg_Bool( wxT("/DLP/CheckHelloTag"), s_DLPCheckHelloTag, true )));
+	NewCfgItem(IDC_CHECKINFOTAG, 		(new Cfg_Bool( wxT("/DLP/CheckInfoTag"), s_DLPCheckInfoTag, true )));
+	//NewCfgItem(IDC_CHECKEASYMULE, 		(new Cfg_Bool( wxT("/DLP/CheckEasyMule"), s_DLPCheckEasyMule, true ))); //Modified by Bill Lee
+	NewCfgItem(IDC_CHECKVERYCDMOD, 		(new Cfg_Bool( wxT("/DLP/CheckVeryCDMod"), s_DLPCheckVeryCDMod, false )));
+	//NewCfgItem(IDC_CHECKMINIMULE,		(new Cfg_Bool( wxT("/DLP/CheckminiMule"), s_DLPCheckminiMule, true))); //Added by Bill Lee
+	NewCfgItem(IDC_CHECKGHOSTMOD, 		(new Cfg_Bool( wxT("/DLP/CheckGhostMod"), s_DLPCheckGhostMod, true ))); //Added by Bill Lee.
+	#endif
 
 	/**
 	 * Files
@@ -1472,6 +1509,11 @@
 
 	SavePreferences();
 
+	// Dynamic Leecher Protection
+	#ifdef AMULE_DLP
+	CalcDLPCheckMask();
+	#endif
+
 	#ifndef CLIENT_GUI
 	CTextFile sdirfile;
 	if (sdirfile.Open(s_configDir + wxT("shareddir.dat"), CTextFile::write)) {
@@ -1483,6 +1525,21 @@
 	#endif
 }
 
+#ifdef AMULE_DLP
+void CPreferences::CalcDLPCheckMask()
+{
+	s_DLPCheckMask = 0;
+	if (s_DLPCheckModString) s_DLPCheckMask |= PF_MODSTRING;
+	if (s_DLPCheckUsername) s_DLPCheckMask |= PF_USERNAME;
+	if (s_DLPCheckUserHash) s_DLPCheckMask |= PF_USERHASH;
+	if (s_DLPCheckHelloTag) s_DLPCheckMask |= PF_HELLOTAG;
+	if (s_DLPCheckInfoTag) s_DLPCheckMask |= PF_INFOTAG;
+	if (s_DLPCheckGhostMod) s_DLPCheckMask |= PF_GHOSTMOD;
+	//if (s_DLPCheckEasyMule) s_DLPCheckMask |= PF_EASYMULE;
+	if (s_DLPCheckVeryCDMod) s_DLPCheckMask |= PF_VERYCDEMULE;
+	//if (s_DLPCheckminiMule) s_DLPCheckMask |= PF_MINIMULE; //Added by Bill Lee
+}
+#endif
 
 CPreferences::~CPreferences()
 {
--- a/src/Preferences.h	2021-02-08 06:25:11.000000000 +0800
+++ b/src/Preferences.h	2021-02-11 23:13:52.000000000 +0800
@@ -580,6 +580,11 @@
 	// Sleep
 	static bool		GetPreventSleepWhileDownloading() { return s_preventSleepWhileDownloading; }
 	static void		SetPreventSleepWhileDownloading(bool status) { s_preventSleepWhileDownloading = status; }
+
+	// Dynamic Leecher Protection
+	#ifdef AMULE_DLP
+	static unsigned int GetDLPCheckMask()		{return s_DLPCheckMask;}
+	#endif
 protected:
 	static	int32 GetRecommendedMaxConnections();
 
@@ -601,6 +606,11 @@
 	void LoadPreferences();
 	void SavePreferences();
 
+	// Dynamic Leecher Protection
+	#ifdef AMULE_DLP
+	void CalcDLPCheckMask();
+	#endif
+
 protected:
 	static wxString	s_configDir;
 
@@ -815,6 +825,20 @@
 	// Stats server
 	static wxString s_StatsServerName;
 	static wxString s_StatsServerURL;
+
+	// Dynamic Leecher Protection
+	#ifdef AMULE_DLP
+	static bool s_DLPCheckModString;
+	static bool s_DLPCheckUsername;
+	static bool s_DLPCheckUserHash;
+	static bool s_DLPCheckHelloTag;
+	static bool s_DLPCheckInfoTag;
+	//static bool s_DLPCheckEasyMule;
+	static bool s_DLPCheckVeryCDMod;
+	//static bool s_DLPCheckminiMule; //Added by Bill Lee
+	static bool s_DLPCheckGhostMod; //Added by Bill Lee
+	static unsigned int s_DLPCheckMask;
+	#endif
 };
 
 
--- a/src/PrefsUnifiedDlg.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/PrefsUnifiedDlg.cpp	2021-02-11 23:14:04.000000000 +0800
@@ -53,6 +53,11 @@
 #include "UserEvents.h"
 #include "PlatformSpecific.h"		// Needed for PLATFORMSPECIFIC_CAN_PREVENT_SLEEP_MODE
 
+//Dynamic Leech Protect - Bill Lee
+#ifdef AMULE_DLP
+#include "DLP.h"
+#endif
+
 BEGIN_EVENT_TABLE(PrefsUnifiedDlg,wxDialog)
 	// Events
 #define USEREVENTS_EVENT(ID, NAME, VARS) \
@@ -114,6 +119,11 @@
 	EVT_CHOICE(IDC_COLORSELECTOR,		PrefsUnifiedDlg::OnColorCategorySelected)
 	EVT_LIST_ITEM_SELECTED(ID_PREFSLISTCTRL,PrefsUnifiedDlg::OnPrefsPageChange)
 
+	//Dynamic Leech Protect - Bill Lee
+	#ifdef AMULE_DLP
+	EVT_BUTTON(IDC_RELOADANTILEECH,		PrefsUnifiedDlg::OnButtonReloadAntiLeech)
+	#endif
+
 	EVT_INIT_DIALOG(PrefsUnifiedDlg::OnInitDialog)
 
 	EVT_COMMAND_SCROLL(IDC_SLIDER,		PrefsUnifiedDlg::OnScrollBarChange)
@@ -187,6 +197,9 @@
 	{ wxTRANSLATE("Online Signature"),	PreferencesOnlineSigTab,	21 },
 	{ wxTRANSLATE("Advanced"),			PreferencesaMuleTweaksTab,	12 },
 	{ wxTRANSLATE("Events"),			PreferencesEventsTab,		5 }
+#ifdef AMULE_DLP
+	,{ wxTRANSLATE("DLP"),				PreferencesDLPTab,			5}
+#endif
 #ifdef __DEBUG__
 	,{ wxTRANSLATE("Debugging"),		PreferencesDebug,			25 }
 #endif
@@ -1096,6 +1109,21 @@
 	theApp->ipfilter->Update( CastChild( IDC_IPFILTERURL, wxTextCtrl )->GetValue() );
 }
 
+//Bill Lee
+#ifdef AMULE_DLP
+void PrefsUnifiedDlg::OnButtonReloadAntiLeech(wxCommandEvent& WXUNUSED(event)){
+	#ifndef CLIENT_GUI
+	if( theDLP->ReloadAntiLeech() )
+		wxMessageBox(_("Cannot load antiLeech!"), _("Message"), wxOK | wxICON_EXCLAMATION, this);
+	else
+		wxMessageBox(_("Succeed loading antiLeech!"), _("Message"), wxOK | wxICON_INFORMATION, this);
+	#else
+	AddLogLineN(_("Reload antiLeech from remote GUI has not been implemented."));
+	wxMessageBox(_("Sorry, it has not been implemented yet!"));
+	#endif
+}
+#endif
+
 
 void PrefsUnifiedDlg::OnPrefsPageChange(wxListEvent& event)
 {
--- a/src/PrefsUnifiedDlg.h	2021-02-08 06:25:11.000000000 +0800
+++ b/src/PrefsUnifiedDlg.h	2021-02-11 23:14:11.000000000 +0800
@@ -124,6 +124,9 @@
 	void OnUserEventSelected(wxListEvent& event);
 	void OnLanguageChoice(wxCommandEvent &event);
 	void CreateEventPanels(const int idx, const wxString& vars, wxWindow* parent);
+	#ifdef AMULE_DLP
+	void OnButtonReloadAntiLeech(wxCommandEvent &event); /* Dynamic Leech Protect - Bill Lee */
+	#endif
 
 	void OnInitDialog( wxInitDialogEvent& evt );
 
--- a/src/ServerWnd.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/ServerWnd.cpp	2021-02-11 23:14:22.000000000 +0800
@@ -46,6 +46,7 @@
 	EVT_BUTTON(ID_BTN_RESET, CServerWnd::OnBnClickedResetLog)
 	EVT_BUTTON(ID_BTN_RESET_SERVER, CServerWnd::OnBnClickedResetServerLog)
 	EVT_SPLITTER_SASH_POS_CHANGED(ID_SRV_SPLITTER,CServerWnd::OnSashPositionChanged)
+	EVT_BUTTON(ID_BTN_RESET_DLP, CServerWnd::OnBnClickedResetDLPLog)
 END_EVENT_TABLE()
 
 
@@ -152,6 +153,11 @@
 	theApp->GetServerLog(true); // Reset it
 }
 
+void CServerWnd::OnBnClickedResetDLPLog(wxCommandEvent& WXUNUSED(evt))
+{
+	wxTextCtrl* cv= CastByID( ID_DLPINFO, this, wxTextCtrl );
+	cv->Clear();
+}
 
 void CServerWnd::UpdateED2KInfo()
 {
--- a/src/ServerWnd.h	2021-02-08 06:25:11.000000000 +0800
+++ b/src/ServerWnd.h	2021-02-11 23:14:27.000000000 +0800
@@ -50,6 +50,7 @@
 	void OnBnClickedUpdateservermetfromurl(wxCommandEvent& evt);
 	void OnBnClickedResetLog(wxCommandEvent& evt);
 	void OnBnClickedResetServerLog(wxCommandEvent& evt);
+	void OnBnClickedResetDLPLog(wxCommandEvent& evt);
 
 	DECLARE_EVENT_TABLE()
 };
--- a/src/TextClient.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/TextClient.cpp	2021-02-11 23:14:38.000000000 +0800
@@ -67,6 +67,7 @@
 	CMD_ID_RELOAD_SHARED,
 	CMD_ID_RELOAD_IPFILTER_LOCAL,
 	CMD_ID_RELOAD_IPFILTER_NET,
+	CMD_ID_RELOAD_ANTILEECH, /* Only used internally - Dynamic Leech Protect - Bill Lee */
 	CMD_ID_SET_IPFILTER_ON,
 	CMD_ID_SET_IPFILTER_OFF,
 	CMD_ID_SET_IPFILTER_CLIENTS_ON,
@@ -234,6 +235,12 @@
 		case CMD_ID_DISCONNECT_KAD:
 			request_list.push_back(new CECPacket(EC_OP_KAD_STOP));
 			break;
+		//Dynamic Leech Protect - Bill Lee
+		#ifdef AMULE_DLP
+		case CMD_ID_RELOAD_ANTILEECH:
+			request_list.push_back(new CECPacket(EC_OP_ANTILEECH_RELOAD));
+			break;
+		#endif
 
 		case CMD_ID_RELOAD_SHARED:
 			request_list.push_back(new CECPacket(EC_OP_SHAREDFILES_RELOAD));
@@ -904,6 +911,9 @@
 	tmp2->AddCommand(wxT("Net"), CMD_ID_RELOAD_IPFILTER_NET, wxTRANSLATE("Update IP filtering table from URL."),
 					wxTRANSLATE("If URL is omitted the URL from the preferences is used."), CMD_PARAM_OPTIONAL);
 
+	#ifdef AMULE_DLP
+	tmp->AddCommand(wxT("AntiLeech"), CMD_ID_RELOAD_ANTILEECH, wxTRANSLATE("Reloads antiLeech."), wxEmptyString, CMD_PARAM_NEVER); //Bill Lee
+	#endif
 	tmp = m_commands.AddCommand(wxT("Connect"), CMD_ID_CONNECT, wxTRANSLATE("Connect to the network."),
 				    wxTRANSLATE("This will connect to all networks that are enabled in Preferences.\nYou may also optionally specify a server address in IP:Port form, to connect to\nthat server only. The IP must be a dotted decimal IPv4 address,\nor a resolvable DNS name."), CMD_PARAM_OPTIONAL);
 	tmp->AddCommand(wxT("ED2K"), CMD_ID_CONNECT_ED2K, wxTRANSLATE("Connect to eD2k only."), wxEmptyString, CMD_PARAM_NEVER);
--- a/src/updownclient.h	2021-02-08 06:25:11.000000000 +0800
+++ b/src/updownclient.h	2021-02-11 23:14:49.000000000 +0800
@@ -408,7 +408,13 @@
 	bool		GetSentCancelTransfer() const	{ return m_fSentCancelTransfer; }
 	void		SetSentCancelTransfer(bool bVal)	{ m_fSentCancelTransfer = bVal; }
 
-	DEBUG_ONLY( wxString	GetClientFullInfo(); )
+#if defined (__DEBUG__) || defined (AMULE_DLP)
+	/* 
+	 * This function is essential for dlp to produce ban log.
+	 * So I decide to retain it when dlp is enabled.
+	 */
+	wxString	GetClientFullInfo();
+#endif
 	wxString	GetClientShortInfo();
 
 	const wxString& GetClientOSInfo() const		{ return m_sClientOSInfo; }
@@ -582,6 +588,10 @@
 
 	bool		HasDisabledSharedFiles() const { return m_fNoViewSharedFiles; }
 
+	#ifdef AMULE_DLP
+	bool		HasNonOfficialOpCodes() const { return dlp_nonofficialopcodes; }	 //Dynamic Leecher Protection - Bill Lee
+	#endif
+
 private:
 
 	CClientCredits	*credits;
@@ -842,6 +852,10 @@
 #ifdef __DEBUG__
 	wxString	connection_reason;
 #endif
+
+	#ifdef AMULE_DLP
+	bool dlp_nonofficialopcodes; //Dynamic Leecher Protect - Bill Lee
+	#endif
 };
 
 
--- a/src/UploadQueue.cpp	2021-02-08 06:25:11.000000000 +0800
+++ b/src/UploadQueue.cpp	2021-02-11 23:14:56.000000000 +0800
@@ -390,6 +390,11 @@
 		return;
 	}
 
+	//Dynamic Leecher Protect - Bill Lee
+	#if defined AMULE_DLP && defined __DEBUG__
+	AddLogLineN(client->GetClientFullInfo());
+	#endif
+
 	client->AddAskedCount();
 	client->SetLastUpRequest();
 
